<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[刷题啦]]></title>
    <url>%2F2019%2F03%2F09%2F%E5%88%B7%E9%A2%98%E5%95%A6%2F</url>
    <content type="text"><![CDATA[剑指offer的JavaScript实现（除开一些强类型考察和指针题型）： 一、数据结构2、二维数组查找在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 123456789101112131415161718function Find(target, array)&#123; const n = array.length, m = array[0].length; if(n===0&amp;&amp;m===0) return false; let row = n-1, col = 0; while(col&lt;=m-1&amp;&amp;row&gt;=0)&#123; if(array[row][col]&gt;target)&#123; row--; &#125; else if(array[row][col]&lt;target)&#123; col++; &#125; else &#123; return true; &#125; &#125; return false;&#125; 4、替换空格请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 1234function replaceSpace(str)&#123; return str.replace(/\s/g,'%20');&#125; 5、从尾到头打印链表输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 1234567891011121314/*function ListNode(x)&#123; this.val = x; this.next = null;&#125;*/function printListFromTailToHead(head)&#123; let stack = [], current = head; while(current!==null)&#123; stack.unshift(current.val); current=current.next; &#125; return stack&#125; 6、重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 12345678910111213141516171819/* function TreeNode(x) &#123; this.val = x; this.left = null; this.right = null;&#125; */function reConstructBinaryTree(pre, vin)&#123; if(pre.length===0||vin.length===0)&#123; return null; &#125;; const index = vin.indexOf(pre[0]), left = vin.slice(0,index), right = vin.slice(index+1); return &#123; val:pre[0], left:reConstructBinaryTree(pre.slice(1,index+1),left), right:reConstructBinaryTree(pre.slice(index+1),right) &#125;&#125; 7、用两个栈实现队列用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 12345678910111213141516const instack=[], outstack=[];function push(node)&#123; return instack.push(node);&#125;function pop()&#123; //!!!! if(!outstack.length)&#123; while(instack.length)&#123; outstack.push(instack.pop()) &#125; &#125; return outstack.pop()&#125; 二、算法和数据操作：查找、排序算法，算法递归和非递归实现（循环）等 #####]]></content>
  </entry>
  <entry>
    <title><![CDATA[【你不知道的JavaScript中】]]></title>
    <url>%2F2018%2F12%2F03%2F%E3%80%90%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%AD%E3%80%91%2F</url>
    <content type="text"><![CDATA[第一部分 类型和语法第一章 类型第二章 值第三章 原生函数第四章 强制类型转换第五章 语法第二部分 异步和性能第一章 异步：现在与将来第二章 回调第三章 Promise第四章 生成器第五章 程序性能第六章 性能测试与调优]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【你不知道的JavaScript上】]]></title>
    <url>%2F2018%2F11%2F15%2F%E3%80%90%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%8A%E3%80%91%2F</url>
    <content type="text"><![CDATA[第一部分 作用域和闭包第一章 作用域是什么一套设计良好的规则：存储变量，和在哪里找到这些变量。 1.1 编译原理尽管JavaScript归类为“动态”或“解释执行语言”，但事实上它是一门编译语言。 传统编译语言（提前编译）执行前的编译（静态）有三步： 分词/词法分析：将字符组成的字符串（如var a = 2;）分解成有意义的代码块（var、a、=、2、;），这种代码块被称为词法单元（token）； 解析/语法分析：将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树(AST，示例讲解)”（var a = 2;的抽象语法树可能有一个叫做VariableDeclaretion的顶级节点，接下来是一个叫做Identifier（它的值是a）的子节点，以及一个叫做AssignmentExpression的子节点。AssignmentExpression节点有一个叫做NumericLiteral（它的值是2）的子节点）； 代码生成：将AST转换为可执行代码的过程被称为代码生成，这个过程与语言、目标平台等息息相关（抛开具体细节，简单来说就是有某种方法可以将var a=2;的AST转化为一组机器指令，用来创建一个叫做a的变量（包括分配内存等），并将一个值储存在a中）。 JavaScript的编译不是发生在构建前，是在执行前几微秒甚至更短，其引擎要更加复杂比如在语法分析和代码生成阶段有特定步骤对性能进行优化；简单地说，任何JavaScript代码片段在执行前都要进行编译（通常就在执行前）（JavaScript编译器首先会对var a = 2;进行编译，然后做好执行它的准备，并且通常马上就会执行它）。 1.2 理解作用域 引擎：从头到尾负责整个JavaScript程序的编译及执行过程 编译器：负责语法分析及代码生成 作用域：负责收集并维护所有申明的标志符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标志符的访问权限 1var a = 2; 总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有申明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它进行赋值。 编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量a来判断它是否已经声明过。查找的过程由作用域进行协助，但引擎执行怎样的查找，会影响最终的查找结果。 LHS查询：赋值操作的目标是谁（找到变量容器本身） RHS查询：谁是赋值操作的源头（查找到某个变量的值） 1.3 作用域嵌套上文说过：作用域是根据名称查找变量的一套规则。实际情况中，通常要同时顾及几个作用域（ES5中没有（不绝对）块级作用域，函数内部是局部作用域，最外层是全局作用域）。 在一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。 遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找（RHS和LHS）过程都会停止。 1.4 异常为何区分RHS和LHS呢，因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。 1234function foo(a)&#123; console.log( a + b ); //b的第一次查找是RHS b = a; //第二次是LHS&#125; RHS在查询所有嵌套的作用域中遍寻不到所需的变量，引擎就回抛出ReferenceError异常；LHS查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有改名称的变量（非严格模式下）。 接下来，如果RHS查询到一个变量，但你尝试对这个变量进行不合理的操作，比如对一个非函数类型的值进行函数调用，那么引擎会抛出TypeError异常。 总：ReferenceError同作用域判别识别相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或者不合理的。 1.5 小结作用域是一套规则，用于确定在何处以及如何查找变量（标志符）。如果查找的目的是对变量进行赋值（=操作符或调用函数时传入参数都会导致关联作用域的赋值操作），那么就回使用LHS查询；如果目的是获取变量值，就会使用RHS查询。 JavaScript引擎首先会在代码执行前对其进行编译，在这个过程中，像var a = 2;这样的声明会被分解成两个独立的步骤： 首先，var a在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。 接下来，a = 2 会查询（LHS查询）变量a并对其进行赋值。 RHS和LHS查询都会在当前执行作用域中开始，如果有需要（没有找到所需的标志符），就会向上级作用域继续查找目标标志符，这样每次上升一级作用域（一层），最后抵达全局作用域（顶层），无论找到没找到都将停止。 不成功的RHS引用会导致抛出ReferenceError异常。不成功的LHS引用会导致自动隐式地创建一个全局变量（非 严格模式下），该变量使用LHS引用的目标作为标志符，或者抛出ReferenceError异常（严格模式下）。 第二章 词法作用域2.1 词法阶段第一章介绍过，大部分标准语言编译器的第一个工作阶段叫词法化（也叫单词化）。词法化的过程会对源代码中的字符进行检查。这个概念是理解词法作用域及其名称来历的基础。 简单说，词法作用域就是定义在词法阶段的作用域。它在你写代码时将变量和块作用域写在哪里来决定，因此在词法分析器处理代码时，会保持作用域不变（大部分情况下）。 查找作用域的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标志符的位置。 作用域查找会在找到第一个匹配的标识符时停止。 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。 词法作用域查找只会查找一级标志符，比如foo.bar只会查找foo，找到这个变量之后对象属性访问规则就会接管对bar属性的访问 2.2 欺骗词法词法作用域完全由写代码期间函数所声明的位置来定义，在怎样能在运行时“修改”（也可以说欺骗）词法作用域呢？ 2.3.1 eveleval函数动态插入代码。 如果eval(..)中所执行的代码包含一个或多个声明（无论是变量还是函数），就会对eval(..)所在的词法作用域进行修改。 setTimeout(..)和setInterval(..)、new Function(..)的功能效果与eval类似，它们某个参数可以是字符串，就可以是一段动态生成的函数代码，这种用法要避免使用！ 2.3.2 withwith关键字。 with通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。 with可以将一个没有或者多个属性的对象处理为一个完全隔离的词法作用域，因此对这个对象的属性也会被处理为定义在这个作用域中的词法标志符，其内部存在对变量的引用（LHS）查找失败时，会创建全局变量。 2.3.3 性能eval(..)函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而with声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。 JavaScript引擎会在编译阶段进行数项的性能优化。有些优化依赖于根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标志符。 2.3 小结词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标志符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。 JavaScript有两个机制可以“欺骗”词法作用域：eval(..)和with。 这两个机制的副作用是引擎无法在编译时对作用域查找进行优化 第三章 函数作用域和块作用域第二章讲了，作用域作为包含标识符（变量、函数）定义的容器，相互嵌套排列，排列的结构是在写代码时定义的。 但是，究竟如何生成一个新的作用域？只有函数可以生成作用域吗？JavaScript中的其他结构能生成作用域气泡吗？ 3.1 函数中的作用域对于以上疑问，最常见的答案是JavaScript只有基于函数的作用域，并不完全正确。 函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数范围内使用及复用（事实上在嵌套的作用域中也可以使用）。这种设计方案非常有用，能充分利用JavaScript变量可以根据需要改变值类型的“动态”特性。 3.2 隐藏内部实现可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域来“隐藏”它们。为什么隐藏它们是一个有用的技术？ 软件设计中，最小授权/最小暴露原则，如模块设计或对象的API设计。 这个原则延伸在如何选择作用域包含变量和函数。暴漏过多的变量和函数会破坏这个原则，并不是所有变量和函数都应该在全局作用域中。 具体内容私有化规避冲突1、全局命名空间 2、模块管理 3.3 函数作用域我们已经知道，在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。 但这不是最理想的方案，这会导致一些额外问题：必须声明一个具名函数，这个函数名标志符本身“污染”了所在作用域；其次，必须显式地通过函数名调用这个函数才能运行其中的代码。 如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行，这将会更加理想，JavaScript提供了解决方案 将包装函数声明放在()中，函数会被当作【函数表达式】而不是一个标准的函数声明来处理，它们的重要区别是名称标识符绑定不同，函数表达式的函数名被绑定在函数表达式自身的函数中而不是所在作用域中。 即，(function foo(){..})作为函数表达式意味着foo只能在..所代表的位置中被访问，外部作用域则不行。foo变量名被隐藏在自身中意味着不会非必要地污染外部作用域。 3.3.1 匿名和具名函数表达式可以是匿名的，而函数声明则不可以省略函数名——在JavaScript的语法中这是非法的。 匿名函数表达式书写起来简单快捷，但有几个缺点： 栈追踪不会显示有意义的函数名，调试困难 引用自身只能使用argument.callee，比如递归和事件触发解绑 可读性/可理解性低 【行内函数表达式】非常强大且有用——匿名和具名之间的区别不会对这点有任何影响。始终个函数表达式命名是一个最佳实践。 123setTimeout( function timeroutHandler()&#123; // &lt;--快看我有名字了！ console.log("I wanted 1 second!");&#125;,1000); 3.3.2 立即执行函数表达式由于函数被包含在一对()括号内部因此成为了一个表达式，通过在末尾加上另外一个()可以立即执行这个函数，这种模式叫做：IIFE，立即执行函数表达式。 (function foo(){..})()或(function foo(){..}()) IIEF普遍的进阶用法： 把它们当作函数调用并传递参数进去（如解决undefined标志符的默认值被错误覆盖的异常） 倒置代码的运行顺序 3.4 块作用域尽管函数作用域是最常见的作用域单元，也是现行大多数JavaScript中最普遍的设计方法，但其他类型的作用域单元也是存在的，并且通过使用其他类型的作用域单元甚至可以实现维护起来更加优秀、简洁的代码。 1234567var foo = true;if(foo)&#123; var bar = foo * 2; // bar属于外部作用域，在外部确保没有同名参数只能依靠自觉性，很容易产生冲突 bar = something(bar); console.log(bar)&#125; 123for(var i=0;i&lt;10;i++)&#123; console.log(i); //只在内部使用的i变量污染了外部作用域&#125; 块作用域是一个用来对之前的最小授权原则进行扩展的工具，将代码从在函数中隐藏信息扩展为在块中隐藏信息 表面上JavaScript并没有块作用域的相关功能，除非你更加深入的研究 3.4.1 with第二章讨论过with关键字，它是块级作用域的一个例子（块作用域的一种形式） 3.4.2 try/catchJavaScript的ES3规范中规定try/catch的catch分句会创建一个块作用域，其中声明的变量仅在catch内部有效。看起来没有什么用处，实际上在ES6环境以前使用块作用域都是靠转换为try/catch实现的。 3.4.3 let幸好ES6改变了现状，引入了新的let关键字，提供了除var以外的另一种变量声明方式。它可以将变量绑定到所在的任意作用域中（通常是{..}内部）。 但【使用let进行的声明不会在块作用域中进行提升】（第四章会讲提升），声明的代码运行前，声明并不“存在” 1、垃圾收集 2、let循环 3.4.4 const除了let以外，ES6还引入了const，可以用来创建块作用域常量。 3.5 小结函数是JavaScript中最常见的作用域单元。本质上，声明一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。 但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，还可以属于某个代码块（通常指{..}内部）。 从ES3开始，try/catch结构在catch分句中具有块作用域。 在ES6中引入了let关键字（var 关键字的表亲），用来在任意的代码块中声明变量。if(..){let a=2;}会声明一个劫持了if的{..}块的变量，并且将这个变量添加到这个块中。 块级作用域和函数作用域应该根据情况选择，创造可读、可维护的优良代码 第四章 提升作用域同其中的变量声明出现的位置有某种微妙的联系，这个细节正式我们要讨论的内容 4.1 先有鸡还是先有蛋直觉上会认为JavaScript代码在执行时是由上到下一行一行执行的。但实际上并不完全正确，有一种特殊情况会导致这个假设是错误的。 【声明会提前】 4.2 编译器再度来袭回顾第一章关于编译器的内容，引擎会在解释JavaScript代码之前首先对其进行编译。编译阶段的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。第二章展示了这个机制，也正是词法作用域的核心内容。 因此，正确的思考思路是，包含变量和函数在内的所有声明都会在任何代码被执行前首先被处理，这个过程就像变量和函数声明从它们在代码中出现的位置被“移动”到了其作用域的最上面。这个过程就叫做提升。 4.3 函数优先函数声明和变量声明都会被提升。但一个细节值得注意（有多个“重复”声明时），是函数会首先被提升，然后才是变量 1234567891011foo(); //1var foo;function foo()&#123; console.log(1);&#125;foo = function()&#123; console.log(2);&#125; 4.4 小结我们习惯将var a = 2;看作一个声明，而实际上JavaScript引擎将其分成两个任务，第一个是编译阶段的任务，第二个是执行阶段的任务。 这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先被“移动”到各自作用域的顶端。可以将这个过程称为提升。 声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。 要注意避免重复声明，特别是当普通的var声明和函数声明混合在一起时。 第五章 作用域闭包接下来的内容需要对作用域工作原理相关的基础知识有非常深入的理解。 5.1 启示闭包是基于词法作用域书写代码时所产生的自然结果。 5.2 实质问题定义：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 无论通过何种手段将内部函数传递到所在词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。 5.3 现在我懂了本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！ 5.4 循环和闭包5.5 模块5.5.1 现代的模块机制5.5.2 未来的模块机制5.6 小结第二部分 this和对象原型第一章 关于thisthis关键字是JavaScript中最复杂的机制之一。它是一个很特别的关键字，被自动定义在所有函数的作用域中。 1.1 为什么要用this12345678910111213141516171819202122function identify() &#123; return this.name.toUpperCase();&#125;function speak() &#123; var greeting = "Hello, I'm" + identify.call(this); console.log(greeting);&#125;var me = &#123; name: "Kyle"&#125;;var you = &#123; name: "Reader"&#125;identify.call(me); //KYLEidentify.call(you); //READERspeak.call(me); //Hello, I'm KYLEspeak.call(you); //Hello, I'm READER 这段代码可以在不同的【上下文对象】（you和me）中重复使用函数identify和speak，不用针对每个对象编写不同版本的函数。如果不使用this，就需要显式地给两个函数传入一个上下文对象： 1234567891011function identify(context) &#123; return context.name.toUpperCase();&#125;function speak(context) &#123; var greeting = "Hello, I'm" + identify(context); console.log(greeting);&#125;identify(me); //KYLEspeak(you); //Hello, I'm READER this提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将API设计得更加简洁并易于复用 1.2 误解有两种关于this的常见解释都是错误的 1.2.1 指向自身1.2.2 它的作用域第二种常见的误解，this指向函数的作用域。【this在任何情况下都不指向函数的词法作用域】。在JavaScript内部，作用域确实和对象很相似，可见的标志符都是它的属性。但作用域“对象”无法通过JavaScript代码访问，它存在于JavaScript引擎内部。 12345678910function foo() &#123; var a = 2; this.bar();&#125;function bar() &#123; console.log(this.a);&#125;foo(); //ReferenceError: a is not defined 首先，这段代码试图通过this.bar()来引用bar函数，这是绝对不可能成功的，之后会解释原因。调用bar最自然的方式是省略前面的this，直接使用词法引用标志符；此外，还试图使用this联通foo()和bar()的词法作用域，从而让bar访问foo作用域里的变量a，这是不可能实现的，你不能用this来引用一个词法作用域内部的东西。 1.3 this到底是什么排除了一些错误理解之后，我们来看看this到底是一种什么样的机制。 1.4 小结学习this的第一步是明白this既不指向函数自身也不指向函数的词法作用域，你也许被这样的解释误导过，但其实它们都是错误的。 this实际上是在函数被调用时发生绑定，它指向什么完全取决于函数在哪里被调用。 第二章 this全面解析2.1 调用位置理解this的绑定过程之前，首先要理解调用位置：就是函数在代码中被调用的位置（而不是被声明的位置）。分析调用栈例子： 123456789101112131415161718192021222324function baz() &#123; //当前调用栈是：baz //因此，当前调用位置是全局作用域 console.log("baz"); bar(); // &lt;-- bar的调用位置&#125;function bar() &#123; //当前调用栈是 baz -&gt; bar //因此，当前调用位置在baz中 console.log("bar"); foo(); // &lt;-- foo的调用位置&#125;function foo() &#123; //当前调用栈是 baz -&gt; bar -&gt; foo //因此，当前调用位置在bar中 console.log("foo");&#125;baz(); // &lt;-- baz的调用位置 2.2 绑定规则函数的执行过程中调用位置如何决定this的绑定对象： 你必须先找到调用位置，然后判断需要应用下面四条规则中的哪一条。我们首先会分别解释这四条规则，然后解释多条规则都可用时它们的优先级如何排列。 2.2.1 默认绑定首先看最常用的函数调用类型：独立函数调用。可把这条规则看作无法应用其他规则时的默认规则。 123456function foo() &#123; console.log( this.a );&#125;var a = 2;foo(); //2 this指向全局对象，严格模式下指向undefined。 2.2.2 隐式绑定另一条需要考虑的规则时调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能造成一些误导。 12345678910function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;;obj.foo(); //2，调用位置会使用obj上下文来引用函数，此时函数被调用时obj对象“包含”它 隐式丢失一个最常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把this绑定到全局对象或者undefined上。 123456789101112function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;;var bar = obj.foo; //函数别名!var a = "opps, global"; //a是全局对象的属性bar(); //”opps, global“，bar引用的是foo函数本身，此时的函数调用不带任何修饰符，因此应用的默认绑定 例2，传入回调函数时丢失this 12345678910111213141516function foo() &#123; console.log(this.a);&#125;function doFun(fn)&#123; //参数传递其实是一种隐式赋值 //fn其实引用的是foo fn(); // &lt;-- 调用位置&#125;var obj = &#123; a: 2, foo: foo&#125;;var bar = obj.foo; //函数别名!var a = "opps, global"; //a是全局对象的属性doFun(obj.foo); //”opps, global“ 2.2.3 显式绑定如上在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并且通过这个属性简洁引用函数，从而把this间接（隐式）绑定到这个对象上。 如果不想在对象内部包含函数引用，而想在某个对象上强制调用函数，JavaScript提供的绝大多数函数和你自己创建的函数都可以使用函数的call(..)和apply(..)方法。 这两个方法的第一个参数是一个对象，它们会把这个对象绑定到this，接着在调用函数指定这个this。 123456789function foo() &#123; console.log( this.a );&#125;var obj = &#123; a:2&#125;;foo.call(obj); //2，如果传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作this的绑定对象，这个原始值会被转换成它的对象形式（new String(..)、new Boolean(..)或者new Number(..)） 可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题。 1、硬绑定123456789101112131415function foo(something) &#123; console.log( this.a, something ); return this.a + somethig;&#125;var obj = &#123; a:2&#125;;var bar = function() &#123; return foo.apply(obj,arguments);&#125;;var b = bar(3); //2 3console.log(b); //5 一种显式的强制绑定，典型应用时创建一个包裹函数，传入所有的参数并返回接收到的所有值。 由于硬绑定是一种非常常用的模式，所以在ES5中提供了内置的方法Function.prototype.bind，用法如下： 12345678910111213function foo(something) &#123; console.log( this.a, something ); return this.a + somethig;&#125;var obj = &#123; a:2&#125;;var bar = foo.bind(obj);var b = bar(3); //2 3console.log(b); //5 2、API调用的“上下文”第三方库和JavaScript语言以及宿主环境很多内置函数，都提供了一个可选的参数“上下文”（context），其作用和bind(..)一样，确保你的回调函数使用指定的this，举例来说： 12345678910function foo(el) &#123; console.log( el, this.id );&#125;var obj = &#123; id: "awesome"&#125;;//调用foo(..)时把this绑定到obj[1,2,3].forEach(foo,obj); //1 awesome 2 awesome 3 awesome 这些函数实际上就是通过call(..)或者apply(..)实现了显式绑定 2.2.4 new绑定这是最后一条this的绑定规则。首先重新定义一下JavaScript中的“构造函数”，在JavaScript中构造函数只是一些使用new操作符时被调用的普通函数，所以包括内置对象函数（比如Number(..)）在内的所有函数都可以用new来调用，这种函数调用被称为构造函数调用：实际上并不存在所谓的“构造函数”，只有对与函数的“构造调用”。 使用new来调用函数，或者发生构造函数调用时，会自动执行下面的操作： 创建（或者说构造）一个全新的对象 这个新对象会被执行[[ 原型 ]]连接 这个新对象会被绑定到函数调用的this 如果这个函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象 123456function foo(a) &#123; this.a = a;&#125;var bar = new foo(2); //创建一个新对象并把它绑定到foo(..)调用中的this上console.log(bar.a) //2 2.3 优先级new绑定&gt;显式绑定&gt;隐式绑定&gt;默认绑定 2.4 绑定例外规则总有例外，这里也一样。某些场景下this的绑定行为会出乎意料 ，你认为应该应用其他绑定规则时，实际上应用的可能是默认绑定规则。 2.4.1 被忽略的this如果把null和undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则： 123456function foo() &#123; console.log( this.a );&#125;var a = 2;foo.call(null) //2 那么什么情况下会传入null呢？一种非常常见的做法是使用apply(..)来“展开数组”（【注意：现在ES6有更好的展开做法】），并且当作参数传入一个函数。类似地，bind(..)可以对参数进行柯里化（预先设置一些参数），这种方法有时非常有用： 12345678910function foo(a,b)&#123; console.log("a:" + a + ",b:" + b);&#125;//把数组“展开”成参数foo.apply(null,[2,3]); //a:2,b:3//使用bind(..)进行柯里化var bar = foo.bind(null,2);bar(3); //a:2,b:3 这两种 方法都需要传入一个参数当作this的绑定对象。如果函数并不关心this的话，传入null是个不错的选择。然而总是使用null来忽略this绑定可能产生一些副作用。如果某个函数确实使用了this（比如第三方库的一个函数），那默认的绑定规则会把this绑定到全局对象，这将导致不可预计的后果（比如修改全局对象） 更安全的this一种更安全的做法是传入一个特殊的对象，把this绑定到这个“DMZ”对象——一个空的非委托对象（委托在第四章第五章介绍）。 2.4.2 间接引用有可能不小心创建一个函数的“间接引用”，比如赋值的时候（this丢失），会应用默认绑定。 2.4.3 软绑定之前我们已经看到过，硬绑定可以把this强制绑定到指定的对象（除了使用new时），防止函数调用应用默认绑定规则。但它会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或显式绑定来修改this。 如果可以给默认绑定制定一个全局对象和undefined以外的值，那就可以实现和硬绑定相同的效果同时保留隐式绑定和显式绑定修改this的能力 2.5 this词法之前介绍的四条规则已经可以包含所有正常的函数。但是在ES6中介绍了一种无法使用这些规则的特殊函数类型：箭头函数。 箭头函数并不是使用function关键字定义的，而是使用称为“胖箭头”的操作符 =&gt; 定义的。箭头函数不使用this的四种标准规则，而是根据外层（函数或者全局）作用域来决定this。箭头函数的绑定无法被修改。（new也不行！） 2.6 小结如果要判断一个运行中函数的this绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺心应用下面这四条规则来判断this的绑定对象： 由new调用？绑定到新创建的对象。 由call或者apply（或者bind）调用？绑定到指定的对象。 由上下文对象调用 ？绑定到那个上下文对象。 默认：在严格模式下绑定到undefined，否则绑定到全局对象 一定要注意有些调用可能在无意中使用了默认绑定规则。如果想“更安全”地忽略this绑定，你可以使用一个DMZ对象以保护全局对象。 ES6中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定this，具体来说，箭头函数会继承外层函数调用的this绑定（无论this绑定到什么）。这其实和ES6之前代码中的self=this机制一样。 第三章 对象在第一章和第二章中，我们介绍了函数调用位置的不同会造成this绑定对象的不同。但是对象到底是什么，为什么我们需要绑定它们呢？ 3.1 语法对象可以通过两种形式定义：声明（文字）形式和构造形式。前者更为常见。 1234567var myObj = &#123; key: value //...&#125;;var myObj1 = new Object();myObj.key = value; 3.2 类型对象是JavaScript的基础。在JavaScript中一共有六种主要类型（术语是“语言类型”）： string number boolean null undefined object 注意，简单基本类型（string、boolean、number、null、undefined）本身并不是对象，常见的错误说法“JavaScript中万物皆对象”。实际上JavaScript中有许多特殊的对象子类型，我们可以称之为复杂基本类型如函数、数组。在调用普通基本类型的“方法”时，JavaScript会自动转换其为复杂基本类型。 内置对象JavaScript中还有一些对象子类型，通常被称为为内置对象。有些内置对象的名字看起来和简单基础类型一样，不过实际它们的关系更复杂，下面详细介绍 String Number Boolean Function Array Date RegExp Error 3.3 内容之前提到过，对象的内容是由一些存储在特定命名位置的（任意类型的）值组成的，我们称之为属性。存储在对象容器内部的是这些属性的名称，它们就像指针（从技术角度来说就是引用）一样，指向这些真正的存储位置。 123456var myObject = &#123; a: 2&#125;;myObject.a; //2myObject["a"]; //2 使用.操作符或者[]操作符能访问属性值，前者被称为“属性访问”，后者“键访问”。主要区别在于.操作符要求属性名满足标识符的命名规范，而[“..”]语法可以接受任意UTF-8/Unicode字符串作为属性名，该字符串还可以在程序中构造。 1myObject[prefix + name]; 【在对象中，属性名永远都是字符串】。即使数字也不例外，在数组下标访问时其实被转化成字符串了，当心不要搞混对象和数组中数字的用法。 3.3.1 可计算属性名(ES6)在文字【声明】对象时使用[]包裹一个表达式来作为属性名： 123456789var prefix = "foo";var myObject = &#123; [prefix + "bar"]: "Hello", [prefix + "baz"]: "World"&#125;myObject["foobar"]; //HellomyObject["foobaz"]; //World 3.3.2 属性与方法如果访问的对象属性是一个函数，从技术角度来说，函数永远都不会“属于”一个对象，所以不应该把对象内部引用的函数称为“方法”，即使一些函数具有this引用也不能把它变成一个“方法”，因为this是在运行时根据调用位置动态绑定的。属性访问返回的函数和其他函数没有任何区别（除了刚刚提到可能发生的隐式绑定）。 最保险的说法可能是，“函数”和“方法“在JavaScript中是可以互换的。 3.3.3 数组数组也支持[]访问，不过期望的是数值（【注意，[“3”]等于[3]，上文提到过属性名永远是字符串】），虽然每个下标都是整数，但仍可给数组添加属性但不会改变length值，这不是一个好主意，最好只用对象存储键/值对，只用数组存储数值下标/值对。 3.3.4 复制对象复制一个对象，ES6可用Object.assign(..)实现浅复制，保证对象安全的情况下还可以 1var newObj = JSON.parse( JSON.stringfy( someObj) ); 3.3.5 属性描述符在ES5之前，JavaScript语言本身并没有提供可以直接检测属性特性的方法，比如判断属性是不是只读。从ES5开始，所有属性都具备了属性描述符。 1234567891011var myObject = &#123; a: 2&#125;;Object.getOwnPropertyDescriptor( myObject, "a");//&#123;// value: 2,// writable: true,// enumerable: true,// configurable: true//&#125; 在创建普通属性时属性描述符会使用默认值，我们也可以用Object.defineProperty(..)来添加一个新属性或者修改一个已有属性（如果它是configurable）并对特性进行设置。 3.3.6 不变性有时候你会希望属性或者是对象是不可改变的，ES5中有多种方法实现。很重要的一点是，所有的方法创建的都是浅不变性，也就是说它们只会影响目标对象和它的直接属性，如果目标对象引用的其他对象（数组、对象、函数等），其他对象的内容不受影响仍然是可变的。（虽然JavaScript程序中很少需要深不可变性） 1、对象常量结合writable:false和configurable:false可以创建一个真正的常量属性（不可修改、重定义或删除）。 2、禁止扩展如果你想禁止一个对象添加新属性并且保留已有属性，可以使用Object.preventExtension(..)。 3、密封Object.seal(..)会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.prebentExtension(..)并把所有现有属性标记为configurable:false。 4、冻结Object.freeze(..)会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.seal(..)并把所有“数据访问”属性标记为writable:false。 这个方法是你可以应用在对象上的级别最高的不可变性。 3.3.7 [[Get]]属性访问有一个细节：myObject.a这种语句并不仅仅是在myObject中查找名字为a的属性，它实际上是实现了[[Get]]操作。对象默认的内置[[Get]]操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值；没有找到，遍历可能存在的[[Prototype]]链寻找；无论如何都没有找到名称相同的属性，那么[[Get]]操作会返回值undefined。 【注意：这种方法与访问变量时是不一样的】如果你引用了一个当前词法作用域中不存在的变量，并不会像对象属性一样返回undefined的，而是会抛出一个ReferenceError异常 3.3.8 [[Put]]有[[Get]]就会有[[Put]]操作，可能会认为对象属性赋值会触发[[Put]]来设置或者创建这个属性，并不完全这样：[[Put]]操作被触发时，实际的行为取决于很多因素，主要因素是对象中是否已经存在这个属性，若存在，[[Put]]算法大致会检查以下内容： 如果对象中不存在这个属性，[[Put]]操作会更加复杂，第五章讨论[[Prototype]]时会详细介绍。 3.3.9 Getter和Setter对象默认的[[Get]]和[[Put]]操作分别可以控制属性值的设置和获取。 在ES5中可以使用setter和getter部分改写默认操作，这两个是隐藏函数，会在设置/获取属性值时调用。当你给一个属性定义getter、setter或两者都有时，这个属性会被定义为“访问描述符”（和“数据描述符”相对），对于访问描述符来说，JavaScript会忽略它们的value和writable特性，取而代之是关心set和get（还有configurable和enumerable）特性。 3.3.10 存在性in操作符会检查属性是否存在对象及其[[Prototype]]原型链中（参见第五章）。相比之下，hasOwnProperty(..)只会检查属性是否在对象中，不会检查[[Prototype]]链 1、枚举“可枚举”就相当于“可以出现在对象属性的遍历中”。除了看是否出现在for..in循环（会查找原型链并且满足enumerable:true）中，还可以利用propertyIsEnumerable(..)检查给定的属性名是否直接存在于对象中（不会查找原型链）并且满足enumerable:true。 只在对象中查找的一些方法：Object.keys(..)会返回一个数组，包含所有可枚举属性；Object.getOwnPropertyNames(..)会返回一个数组，无论它们是否可以枚举 3.4 遍历for..in可以遍历对象的可枚举属性列表（包括[[Prototype]]链），如何遍历属性的值呢？ 对于数值索引的数组来说，可以使用标准的for循环来遍历值；ES5中增加了一些数组的辅助迭代器，包括forEach(..)、every(..)和some(..)。 ES6增加了一种遍历数组的for..of循环语法（如果对象本身定义了迭代器的话也可以遍历对象）。for..of循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来遍历所有返回值。 3.5 小结JavaScript中的对象有字面形式（比如var a={..}）和构造形式（比如var a=new Array(..)）。字面形式更常用，不过有时候构造形式可以提供更多选项。 “JavaScript中万物都是对象”这是错误的，对象是6个（或者7个，取决于你的观点）基础类型之一。对象有包括function在内的子类型，不同子类型具有不同的行为。 对象就是键/值对的集合。可以通过.propName或者[“propName”]语法来获取属性值。访问属性时，引擎实际上会调用内部默认[[Get]]操作（设置属性是[[Put]]），[[Get]]操作会检查对象本身是否包含这个属性，没有找到的话还会查找[[Prototype]]链（见第五章）。 属性的特性可以通过属性描述符来控制，还可以使用一些方法来设置对象（及其属性）的不可变性级别。 属性不一定包含值——它可能是具备getter/setter的“描述访问符”；属性可以是可枚举的或不可枚举的，这决定了它们是否会出现在for..in循环中。 你可以使用ES6的for..of语法来遍历数据结构（数组、对象等）中的值，for..of会寻找内置或者自定义的@@iterator对象并调用它的next()方法来遍历数据值。 第四章 混合对象“类”上一章介绍了对象，这章介绍和类相关的面向对象编程。在研究类的具体机制之前首先介绍一下面向对象的设计模式：实例化、继承和多态。 我们将会看到，这些概念实际上无法直接对应到JavaScript的对象机制，因此我们会介绍许多JavaScript开发者所使用的解决方法（比如混入，mixin） 4.1 类理论类/继承描述了一种代码的组织结构形式——一种在软件中对真实世界中问题领域的建模方法。 面向对象编程强调的是数据和操作数据的行为本质上是互相关联的（当然，不同的数据有不同的行为），因此好的设计就是把数据以及和它相关的行为打包（或者说封装）起来。这在正式的计算机科学中有时被称为数据结构。 4.1.1 “类”设计模式类并不是必须的编程基础，而是一种可选的代码抽象。 4.1.2 JavaScript中的“类”类是一种在软件设计中可选的模式，你可以用一些方法在JavaScript中（本章之后会介绍）近似实现类的功能。为了满足对于类设计模式最普遍的需求，JavaScript提供了一些近似类的语法。 4.2 类的机制4.2.1 建造“类”和“实例”的概念来自于房屋建造。 一个类就是一张蓝图，为了获得真正可以交互的对象，我们必须按照类来建造（也可以说实例化）一个东西，这个东西通常被称为实例，有需要的话，我们可以直接在实例上调用方法并访问其公有数据属性。 4.2.2 构造函数类示例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。这个方法的任务就是初始化实例需要的所有信息（状态）。 构造函数会返回一个对象（也就是类的一个实例）。类构造函数属于类，大多需要用new来调，这样语言引擎才知道你想要构造一个新的类实例。 4.3 类的继承在面向类的语言中，你可以先定义一个类，然后定义一个继承前者的类。 4.3.1 多态多态是一个非常广泛的话题，我们在JavaScript中所说的“相对多态”只是多态的一个方面：任何方法都可以引用和继承层次中高层的方法（无论高层的方法名和当前方法名是否相同）。之所以说“相对”是因为我们并不会定义想要访问的绝对继承层次（或者说类），而是使用相对引用“查找上一次层”。许多语言中可以使用super，它的含义是“超类”，表示当前类的父/祖先类。 多态的另一个方面是，在继承链的不同层次中一个方法名可以被多次定义，当调用方法时会自动选择合适的定义。方法的多态性取决于你是在哪个类的实例中引用它。 多态并不表示子类和父类有关联，子类得到的只是父类的一份副本。类的继承其实就是复制。 4.3.2 多重继承有些面向类的语言允许你继承多个“父类”。多重继承意味着所有父类的定义都会被复制到子类中。从表面上看这个功能非常有用，可以把许多功能组合到一起。其实会带来很多复杂的问题，比如两个父类都定了同名方法，子类引用会很麻烦。 相比之下，JavaScript要简单得多：它本身并不提供“多重继承”功能。很多JavaScript开发者会尝试各种方法来实现多重继承，我们马上会看到。 4.4 混入在继承会这实例化时，JavaScript的对象机制并不会自动执行复制行为。JavaScript中只有对象，并不存在可以被实例化的“类”。一个对象并不会被复制到其他对象，它们会被关联起来（第五章介绍）。 由于在其他语言中类表现出来的都是复制行为，因此JavaScript开发者想出一个方法来模拟类的复制行为，这个方法就是混入。接下来我们会看到两种类型的混入：显式和隐式。 4.4.1 显式混入由于JavaScript不会自动实现复制行为，所以我们需要手动实现复制功能。这个功能在许多库和框架中被称为extend(..)，但是为了方便理解我们称之为mixin(..) 12345678910//非常简单的mixin(..)例子：function mixin( sourceObj, targetobj ) &#123; for(var key in sourceObjr) &#123; //只会在不存在的情况下复制 if(!(key in targetObj)) &#123; tergetObj[key]=sourceObj[key]; &#125; &#125; return tergetObj;&#125; 1、再说多态2、混合复制现在我们分析一下mixin(..)工作原理。它遍历sourceObj的属性，如果在tergetObj没有这个属性就会进行复制。由于是在目标对象初始化之后再进行复制，因此存在覆盖目标对象的原有属性可能。 如果选择先复制再对目标对象进行特殊化，就可以跳过存在性检查，不过这种方法并不好而且效率低，不如第一种方法常用。 这两种方法都可以把不重叠的内容从源对象中复制到目标对象 。但在JavaScript中函数无法真正的复制，你只能复制对其共享函数对象的引用。如果你向目标对象中显式混入超过一个对象，就可以部分模仿多重继承行为。 3、寄生继承显式混入模式的一种变体称为“寄生继承”，既是显式的又是隐式的。 4.4.2 隐式混入隐式混入和之前提到的显式伪多态很像，因此也具备同样的问题 4.5 小结第五章 原型第三章和第四章多次提到了[[Prototype]]链，但没有说它到底是什么，现在我们来详细介绍一下它。 第四章介绍的所有模拟类复制行为的方法，比如各种混入，都【没有】使用[[Prototype]]链机制。 5.1 [[Prototype]]JavaScript中的对象都有一个特殊的[[Prototype]]内置属性，其实就是对于其他对象的引用。 它有什么用呢，之前说过当试图引用对象的属性时会触发[[Get]]操作，比如myObject.a，第一步就是检查对象本身是否有个属性，有的话就使用它；但是如果a不在myObject中，就需要使用对象的[[Prototye]]链了。这个过程会持续到找到匹配的属性名或查找完整的[[Prototype]]链，仍找不到[[Get]]操作返回值undefined。 使用for..in遍历对象时也是这个原理，任何可以通过原型链访问（并且是enumerable）的属性都会被枚举。使用in操作符来检查属性在对象中是否存在时，同样也会查找对象的整条原型链（无论是否可枚举）。 5.1.1 Object.prototype所有普通的[[Prototype]]链最终都会指向内置的Object.prototype，它包含JavaScript中许多通用的功能，比如.toString()和.valueOf()，第三章的.hasOwnProperty(..)，接下来还会介绍的.isPrototypeOf(..)等。 5.1.2 属性设置和屏蔽第三章提到过给一个对象设置属性并不仅仅是添加一个新属性或者修改已有属性值，myObject.foo=”bar”完整过程： 如果myObject对象中包含名为foo的数据访问属性，这条赋值语句只会修改已有的属性值； 如果foo不是直接存在于myObject中，[[Prototype]]链就会被遍历，类似[[Get]]操作，如果原型链上找不到foo，foo就会被直接添加到myObject上； 如果foo既出现在myObject中也出现在myObject的[[Prototype]]链上层，那么就会发生【屏蔽】。myObject中包含的foo属性会屏蔽原型链上层的所有foo属性； 然而，如果foo只存在于原型链上层，myObject.foo=”bar”会出现三种情况： 大多数开发者都认为如果向[[Prototype]]链上层存在的属性赋值（[[Put]]），就一定会触发屏蔽，实际上只有第一种情况是这样的，如果希望在第二种第三种情况下都屏蔽foo，就不能使用=操作符来赋值，而是使用Object.defineProperty(..)来向myObject添加foo（参见第三章）。 如果需要对屏蔽方法进行委托委托的话就不得不使用丑陋的显式伪多态（参见第四章）。通常来说，使用屏蔽得不偿失，所以应当避免使用。第六章会介绍一种不使用屏蔽的更加简洁的设计模式。 5.2 “类”为什么一个对象需要关联到另一个对象？第四章我们说过JavaScript和面向对象的语言不同，它没有类来作为对象的抽象模式或者蓝图。JavaScript中只有对象。 5.2.1 “类”函数很多年来，JavaScript中有一种奇怪的行为被滥用，这就是模仿类，利用函数的一种特殊特性：所有函数都会拥有一个名为prototype的公有并且不可枚举的属性，它会指向另一个对象： 12345function Foo() &#123; //..&#125;Foo.prototype; //&#123;&#125; 这个对象通常被称为Foo的原型，非常容易造成歧义。抛开名字不谈，这个对象到底是什么？最直接的解释是，这个对象是在调用new Foo()时创建的，最后关联到这个Foo.prototype对象上： 123456function Foo() &#123; //...&#125;var a = new Foo();Object.getPrototypeOf(a)===Foo.prototype; //true 在面向类的语言中，类可以被复制（或者说实例化）多次，但是在JavaScript中，并没有类的复制机制，你不能创建一个类的多个实例，只能创建多个对象，它们[[Prototype]]关联的是同一个对象。 关于名称在JavaScript中并不会将一个对象（“类”）复制到另一个对象（“实例”），只是将它们关联起来，这个机制常常被称为原型继承，被视为动态语言版本的类继承。这个术语“原型继承”（以及使用其他面向类的术语比如“类”、“构造函数”、“实例”、“多态”等等）严重影响了大家对于JavaScript机制真实原理的理解。 继承意味着复制操作，JavaScript（默认）并不会复制对象属性。相反，JavaScript会在两个对象之间创建关联，这样一个对象可以通过【委托】访问另一个对象的属性和函数。【委托】这个术语可以更加精准地描述JavaScript中对象的关联机制。 5.2.2 “构造函数”12345function Foo() &#123; //...&#125;var a = new Foo(); 到底是什么让我们认为Foo是一个“类”呢？一个原因是使用了关键字new，在面向类的语言中构造实例时也会用到它；另一个原因是Foo()的调用方式很像初始化类时类构造函数的调用方式。 除了令人迷惑的“构造函数”语义外，Foo.prototype还有另一个绝招： 12345678function Foo() &#123; //...&#125;Foo.prototype.constructor === Foo; //truevar a = new Foo();a.constructor === Foo; //true Foo.prototype默认（在代码第一行声明时！）有一个公有且不可枚举的属性.constructor，这个属性引用的是对象关联的函数（本例中是Foo）。此外，可以看到通过“构造函数”调用new Foo()创建的对象也有一个.constructor属性，指向“创建这个对象的函数”。 构造函数还是调用上一段代码很容易让人认为Foo是一个构造函数，因为我们使用new来调用它并且看到它“构造”了一个对象。 实际上Foo和其他任何函数没有任何区别。函数本身并不是构造函数，使用new关键字把这个函数调用变成了一个“构造函数调用” 5.3 （原型）继承检查“类”关系假设有对象a，如何寻找对象a委托的对象（如果存在）呢？，在传统面向类的环境中，检查一个实例（JavaScript中的对象）的继承祖先（JavaScript中的委托关联）通常被称为内省。 1234567function Foo() &#123; //...&#125;Foo.prototype.blah = ...;var a = new Foo();a instanceof Foo； //true 第一种方法是站在“类”的角度来判断：a instanceof Foo；instanceof回答的问题是：在a的整条[[Prototype]]链中是否有指向Foo.prototype的对象？ 可惜这个方法只能处理对象（a）和函数（带.prototype引用的Foo）之间的联系，如果想判断两个对象（比如a和b）之间是否通过[[Prototype]]链关联，只用instanceof无法实现。 下面是第二种判断[[Prototype]]内省的方法，它更加简洁： 1Foo.prototype.isPrototypeOf(a); //true 这个方法不需要使用函数（“类”），它直接判断对象之间的关系，isPrototypeOf问的问题是：在a的整条[[Prototype]]链中是否出现过Foo.prototype? 我们也可以直接获取一个对象的[[Prototype]]链： 123Object.getPrototypeOf(a);a.__proto__ 5.4 对象关联现在知道了[[Prototype]]机制就是存在于对象中的一个内部链接，它会引用其他对象。这个链接的作用是：如果在对象上没有找到需要的属性和方法引用，引擎就会继续在[[Prototype]]关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它的[[Prototype]]，以此类推。这一系列对象的链接被称为“原型链”。 5.4.1 创建关联[[Prototype]]机制的意义是什么呢？为什么JavaScript开发者费这么大力气（模拟类）在代码中创建这些关联呢？ 5.4.2 关联关系是备用看起来对象之间的关联关系是处理“缺失”属性或者方法时的一种备用选项，但这并不是[[Prototype]]的本质。 5.5 小结第六章 行为委托第五章详细介绍了[[Prototype]]机制并说明了为什么在“类”或者“继承”的背景下讨论[[Prototype]]容易产生误解（这种不恰当方式已经持续了20年）。我们搞清楚了繁杂的语法（各种.prototype代码），也见识了各种各样的陷阱（比如出人意料的.contructor和丑陋的伪多态语法），还有用来解决这些问题的各种“混入”方法。 JavaScript中[[Prototype]]机制的本质就是对象之间的关联关系。这个观点对于理解本章的内容来说是非常基础并且非常重要的。 6.1 面向委托的设计为了更好地学习如何更直观地使用[[Prototype]]，我们必须认识到它代表的是一种不同于类（参见第四章）的设计模式。我们需要试着把思路从类和继承的设计模式转换到委托行为的设计模式。 6.1.1 类理论6.1.2 委托理论1、相互委托（禁止）2、调试6.1.3 比较思维模型6.2 类与对象6.3 更简洁的设计6.4 更好的语法6.5 内省6.6 小结]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F11%2F15%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAReact%E5%92%8CRedux%2F</url>
    <content type="text"><![CDATA[深入浅出React和Redux第一章 React 新的前端思维方式本章内容： 如何初始化一个React项目 如何创建一个React组件 React的工作方式 1.1 初始化一个React项目1、安装Node.js 2、快速开发工具：create-react-app create-react-app是一个通过npm发布的安装包，确认Node.js和npm安装好后： 12345npm install --g create-react-appcreate-react-app first_react_appcd first_react_app npm start 1.2 增加一个新的React组件React的首要思想就是通过组件（Component）来开发应用。所谓组件指的是能完成某个特定功能的独立的、可重用的代码 1.2.1 JSX是JavaScript的语法扩展，让我们可以在JavaScript中可以编写像HTML一样的代码，区别在于： JSX中的元素不限于HTML中的元素，可以时任何一个React组件（使用大写字母开头） JSX中通过onClick方式给元素添加事件处理函数和HTML中给元素添加onclick不同，见下节 1.2.2 JSX是进步还是倒退HTML中onclick： oncick添加的事件处理函数是在全局环境下执行的（污染全局环境） 给很多DOM元素添加onclick事件，可能会影响网页性能 若使用了onclick的DOM元素被动态删除，对应的事件处理器没有注销会造成内存泄漏 以上问题在JSX中都不存在： onClick挂载的每个函数，都可以控制在组件范围内，不会污染全局空间 利用事件委托只挂在最顶层DOM节点，所有点击事件只被这个事件处理函数捕获，然后根据具体组件分配特定函数，效率高 React控制了组件的生命周期，在unmount的时候能清除所有的事件处理函数，不存在内存泄漏 1.3 分解React应用React应用实际上依赖于一个很大很复杂的技术栈 1.4 React的工作方式React与jQuery来比较： 1.4.1 jQuery如何工作用jQuery实现ClickCounter的功能： 内容样式： 12345678910111213&lt;!doctype html&gt;&lt;html&gt; &lt;body&gt; &lt;div&gt; &lt;button id="clickMe"&gt;Click Me&lt;/button&gt; &lt;div&gt; Click Count: &lt;span id="clickCount"&gt;0&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="http://lib.sinaapp.com/js/jquery/1.9.1/jquery-1.9.1.min.js"&gt;&lt;/script&gt; &lt;script src="./clickCounter.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 交互： 1234567$(function() &#123; $('#clickMe').click(function() &#123; var clickCounter = $('#clickCount'); var count = parseInt(clickCounter.text(), 10); clickCounter.text(count+1); &#125;)&#125;) 简言之就是选中一些DOM元素，然后对这些元素进行一些操作。但是，对于庞大的项目，这种模式会造成代码结构复杂，难以维护。 1.4.2 React的理念只关心“想要显示什么”，而不是“怎么去做”。React的理念，归结为一个公式： UI=render(data) 用户看到的界面（UI），应该是一个函数（在这里叫render）的执行结果，只接受数据（data）作为参数。这个函数是一个纯函数：即没有任何副作用，输出完全依赖于输入的函数，两次函数调用如果输入相同，得到的结果也绝对相同。 对于开发者来说，重要的是区分开哪些属于date哪些属于render，想要更新用户界面，要做的就是更新data，用户界面自然会做出响应 1.4.3 Virtual DomReact的确通过重复渲染来实现用户交互，但不同与jQuery每次修改需要变化的那一个DOM，React利用Virtual DOM让每次渲染都只重新渲染最少的DOM元素。 以ClickCounter为例，一开始点击计数为0，用户点击按钮让点击计数变成1，这一次重新渲染，React通过Virtual Dom对比发现其实只是id为clickCount的span元素中内容从0变为1而已，所以React这次渲染要做的事情执行类似于下面的语句： 1document.getElementById("clickCount").innerHTML='1' 1.4.4 React工作方式的优点jQuery虽然直观易懂，当当项目变的庞大时，代码往往相互纠缠，难以维护： 使用React就可以变面构建这样复杂的程序结构，无论何种事件，引发的都是React组件的重新渲染，至于如何治修改必要的DOM部分，则完全交给React去操心，开发者并不需要关心： 1.5本章小节这一章我们利用create-react-app创造了一个简单的React应用，从一开始就按照组件的思想来开发应用，React的主要理念之一就是基于组件来开发应用。 通过和同样功能的jQuery实现方式对比，了解了React的工作方式：利用声明式的语法，让开发者专注于描述用户界面“显示成什么样子”，而不是重复思考“如何去显示”，这样可以大大提高开发效率也让代码更容易管理。 虽然React时通过重复渲染来实现动态更新效果，但是借助Virtual Dom技术，实际上这个过程并不牵涉太多的DOM操作，所以渲染效率很高。 理解React的工作方式，是踏入React世界的关键一步，接下来详细介绍如何构建高质量的React组件 第二章 设计高质量的React组件本章将深入介绍构建高质量React组件的原则和方法，包括以下内容： 划分组件边界的原则 React组件的数据种类 React组件的生命周期 本章的内容知识React组件设计的基础知识，因为React应用都是围绕组件的设计，所有关于组件的设计将贯穿全书 2.1 易于维护组件的设计要素尽量保持一个组件只做一件事。拆分组件最关键的是确定组件边界，满足高内聚，低耦合的原则（高内聚：逻辑紧密相关的内容放在一个组件中；低耦合：不同的组件之间的依赖关系要尽量弱化）。 2.2 React组件的数据React组件的数据分为两种，prop和state，无论prop或者state的改变，都可以引发组件的重新渲染，那么设计组件时，何时选用prop何时state？ prop是组件的对外接口，state是组件的内部状态，对外用prop，内部用state 2.2.1 React的prop每个React组件是独立存在的模块，组件之外的一切都是外部世界，外部世界通过prop（property简写）来和组件对话。从外界到组件使用传数据，从组件反传出来使用回调函数 1、从prop赋值 prop的值可以是任何类型（不同于HTML元素的属性，值都是字符串类型，即使是内嵌的JavaScript），除字符串其他都需要用{}包起来 12345//SampleButton的组件实例，使用了名为id、style、onClick的prop&lt;SampleButtonid=” sample” style=&#123;&#123;color: ” red”&#125;&#125;onClick=&#123;onButtonClick&#125;/ :&gt; 2、读取prop值 【注】如果一个组件需要定义自己的构造函数，一定要记得在构造函数的第一行通过super调用父类也就是React.Component的构造函数。如果在构造函数中没有调用super(props)，那么组件实例被构造之后，类实例的所有成员函数就无法通过this.props访问到父组件传递过来的props值，完整构造函数声明如下： 1234567891011121314151617181920212223242526272829class Counter extends Component &#123; constructor(props) &#123; //调用父类构造函数 super(props); //为成员函数绑定当前this的执行环境，因为ES6方法创造的React组件类并不自动给我们绑定this到当前实例对象 this.onClickIncrementButton = this.onClickIncrementButton.bind(this); this.onClickDecrementButton = this.onClickDecrementButton.bind(this); //初始化state，读取传入的props通过参数props this.state = &#123; count: props.initValue &#125; &#125; //读取参数通过this.props render() &#123; console.log('enter render ' + this.props.caption); const &#123;caption&#125; = this.props; return ( &lt;div&gt; &lt;button style=&#123;buttonStyle&#125; onClick=&#123;this.onClickIncrementButton&#125;&gt;+&lt;/button&gt; &lt;button style=&#123;buttonStyle&#125; onClick=&#123;this.onClickDecrementButton&#125;&gt;-&lt;/button&gt; &lt;span&gt;&#123;caption&#125; count: &#123;this.state.count&#125;&lt;/span&gt; &lt;/div&gt; ); &#125;&#125; 在构造函数中可以通过参数props获得传入prop值，在其他函数中则可以通过this.props访问传入prop值 3、propTypes检查 prop是组件的对外接口，则存在方式让其声明自己的接口规范 这个组件支持哪些prop 每个prop应该是什么样的格式 1234Counter.propTypes = &#123; caption: PropTypes.string.isRequired, initValue: PropTypes.number&#125;; 2.2.2 React的state驱动组件渲染过程的除了prop，还有state，state代表组件的内部状态。由于React组件不能修改传入的prop，所以需要记录自身数据变化，就要使用state 1、初始化state 12345constructor(props) &#123; this.state = &#123; count: props.initValue ||0 &#125;&#125; 通常在构造函数的末尾对this.state进行赋值，若使用的prop给this.state赋值且该prop没有用propTypes标识isRequired，可以用defaultProps功能设定默认值（避免在构造函数中判断是否存在） 123Counter.defaultProps = &#123; initValue: 0&#125;; 2、读取和更新state 通过this.state可以读取到组件的当前state。直接修改this.state无效（强力修改了state的值但没有驱动组件重新渲染），需使用this.setState() 2.2.3 prop和state的对比 prop用于定义外部接口，state用于记录内部状态 prop的赋值在外部世界使用组件时，state的赋值在组件内部 组件不应该改变prop的值，而state存在的目的就是让组件来改变的 组件的state相当于组件的记忆，其存在的意义就是被修改，每一次通过this.setState函数修改state就改变了组件的状态，然后通过渲染过程把这种变化体现出来 但组件绝不应该去修改传入的props值，UI=render(data)，React组件扮演的是render函数的角色，应该是一个没有副作用的纯函数，不修改传入props的值 2.3 组件的生命周期React严格定义了组件的生命周期，生命周期可能会经历如下三个过程： 装载过程（Mount），也就是把组件第一次在DOM树中渲染的过程 更新过程（Update），当组件被重新渲染的过程； 卸载过程（Unmount），组件从DOM删除的过程 三种不同的过程，React库会依次调用组件的一些成员函数，这些函数被称为生命周期函数 2.3.1 装载过程当组件第一次被渲染的时候，依次调用： constructor：ES6中每个类的构造函数，要创造一个组件类的实例，当然会调用对应的构造函数，但不是每个组件都需要定义构造函数（无状态组件），需要构造函数旺旺因为：1、初始化state；2、绑定成员函数的this环境 componentWillMount：作用不大，，， render：一定要实现；纯函数；没有副作用（不调用this.setState()），返回结果用于构建DOM对象 componentDidMount：被调用时render函数的返回值已经引发了渲染，组件已经被装载在DOM树上了，可以放心获取渲染出来的任何DOM 2.3.2 更新过程当组件被装载在DOM树上之后，用户在网页上可以看到组件的第一印象，组件随着用户操作导致props或state被修改时就会引发组件的更新过程： componentWillReceiveProps：只要父组件render被调用，子组件就会触发（不管props有没有变化）；this.setState()引起的改变不会触发 shouldComponentUpdate：React组件生命周期中除了render外最重要的一个函数，render函数决定该渲染什么，而它决定一个组件什么时候不需要渲染。render和shouldComponentUpdate是React生命周期函数中唯二要求有返回结果的函数，它返回布尔值用于告诉React这个组件在这次更新过程中是否要继续 componentWillUpdate render componentDidUpdate 2.3.3 卸载过程 componentWillUnmout：当React组件要从DOM树上删除掉之前，这个函数可以做一些清理性任务比如一些非React方法创建的DOM元素 2.4 组件向外传递数据作为值的函数传递，回调函数的参数 2.5 React组件state和prop的局限多个组件之间的数据管理问题： 数据重复（父子均存逻辑上相同的state）带来的不一致问题； 多层嵌套传递数据（prop）必须中转违反低耦合。 2.6本章小节本章学习了构建高质量组件的原则，应用React一样要以构建高内聚低耦合的组件为目标，而保证组件高质量的一个重要工作就是保持组件对外接口清晰简洁；React利用prop来定义组件的对外接口，用state来代表内部的状态；React的生命周期：装载过程、更新过程和卸载过程涉及的所有生命周期函数。 React的state存储状态有一个缺点：数据冗余重复，是我们接下来要解决的问题 第三章 从Flux到Redux前一章暴露了React管理数据冗余重复问题，这一章介绍Redux这种管理应用状态的框架： 单项数据流框架的始祖Flux Flux理念的一个更强实现Redux 结合React和Redux 3.1 Flux要了解Redux，首先要从Flux说起。和React同时面世时，两者结合在一起才能构架大型的JavaScript应用，做一个类比：React是用来替换jQuery的，那么Flux就是以替换Backbone.js、Ember.js等MVC框架为目的。 在MVC中，React相当于V（View）部分，只涉及到页面的渲染，一旦涉及应用的数据管理部分，还是交给Model和Controller，不过Flux并不是一个MVC框架，它推翻了MVC并用一个新的思维来管理数据流转 3.1.1 MVC框架的缺陷MVC框架是业界广泛接受的一种前端应用框架类型，这种框架把应用分为三个部分： Model（模型）负责管理数据，大部分业务逻辑也应该放在这里； View（视图）负责渲染用户界面，应该避免在View中涉及业务逻辑； Controller（控制器）负责接受用户输入，根据用户输入调用对应的Model部分逻辑，把产生的数据交给View部分，让View渲染出必要的输出。 问题：View和Model能相互直接通信，不同模块之间的依赖关系复杂 3.1.2 Flux应用一个Flux应用包含四个部分，粗略了解一下： Dispatcher，处理动作分发，维持Store之间的依赖关系； Store，负责存储数据和处理数据相关逻辑 Action，驱动Dispatcher的JAvaScript对象； View，视图部分，负责显示用户界面。 在MVC框架中，系统提供的服务都通过Controller暴露函数来实现，每增加一个功能，Controller往往就要增加一个函数；在Flux新增加功能并不需要Dispatcher增加新的函数，增加一种新的Action类型即可 3.1.3 Flux的优势“单向数据流” 3.1.4 Flux的不足1、Store之间的依赖关系 2、难以进行服务器端渲染 3、Store混杂了逻辑和状态 3.2 Redux3.2.1 Redux的基本原则三个基本原则 唯一数据源 保持状态只读 数据改变只能通过纯函数完成（reducer） 3.2.2 Redux实例3.2.3 容器组件和傻瓜组件 3.2.4 组件Context虽然Redux应用全局只有一个Store，这样的直接导入依然有问题。在组件中直接导入Store是非常不利于组件复用的。一个应用中最好只有一个地方需要导入Store，这个位置当然是在调用最顶层React组件的位置。不让组件直接导入Store，那就只能让组件的上层组件把Store传递下来了。用prop传递store不是一个好方法。 React提供了一个叫Context的功能。创建一个特殊的React组件Provider，它将是一个通用的context提供者，它提供一个函数getChildContext，这个函数返回的就是代表Context的对象；还定义了类的childContextTypes。完成这两步子组件才能访问到context 3.2.5 React-Reduxreact-redux两个最主要的功能： connect：连接容器组件和傻瓜组件 Provider：提供包含store的context 3.3 本章小节第四章 模块化React和Redux应用第一部分中，我们已经了解了React的基本工作方式，也知道了Redux在组合React组件中的作用，但是更多的只是了解其基本原理和使用方法。 实际工作中我们要创建的应用无论结构和大小都复杂得多，在这一章中，我们要介绍创建一个复杂一点的应用该如何做，包含： 本章内容： 模块化应用的要点 代码文件的组织方式 状态树的设计 开发辅助工具 4.1 模块化应用要点从架构出发，当我们开始一个新的应用的时候，有几件事情是一定要考虑清楚的； 代码文件的组织结构； 确定模块的边界 Store的状态树设计。 4.2 代码文件的组织方式4.2.1 按角色组织MVC框架之下常常的组织方式：按角色 12345678910controllers/ todoController.js filterController.jsmodels / todoModel.js filterModel.jsviews / todo.js todoitem.js filter.js 把一个类型的代码文件放在一个目录下。当你需要对一个功能进行修改，虽然这个功能知识针对某一具体的应用模块，但是却牵扯到MVC中的三个角色Controller、Model和View，需要在三个目录中分别修改。 4.2.2 按功能组织把完成同一应用功能的代码放在一个目录下，一个应用功能包含多个角色的代码。在Redux中，不同的角色就是reducer、action和视图，而应用功能对应的就是用户界面上的交互模块。 4.3 模块接口4.4 状态树设计4.4.1 一个状态节点只属于一个模块4.4.2 避免冗余数据4.4.3 树形结构扁平4.5 Todo 应用实例4.5.1 Todo状态设计4.5.2 action构造函数4.5.3 组合reducer4.5.4 Todo视图1、todos视图 2、filter视图 4.5.5 样式4.5.6 不使用ref4.6 开发辅助工具4.6.1 Chrome扩展包4.6.2 redux-immutable-state-invariant辅助包4.6.3 工具应用4.7本章小节第五章 React组件的性能优化第六章 React高级组件当开发更多的React组件时，镀铬组件都需要某个功能，这个功能和界面并没有关系，所有也不能简单地抽取成一个新的组件，但是如果让同样的逻辑在各个组件里各自实现，无疑导致重复代码。 我们就会探讨如何构建更易于复用、更灵活的React高级组件，包含： 高级组件的概念及应用 以函数为子组件的模型 这两种方式的最终目的都是为了重用代码，只是策略不同，各有优势，开发者在实际工作中需要根据实际情况决定采用何种方式 6.1 高阶组件6.1.1 代理方式的高阶组件1、操纵prop 2、访问ref 3、抽取状态 4、包装组件 6.1.2 继承方式的高阶组件1、操纵prop 2、操纵生命周期函数 6.1.3 高阶组件的显示名6.1.4 曾经的React Mixin6.2 以函数为子组件6.2.1 实例CountDown6.2.2 性能优化问题6.3 本章小节第七章 Redux和服务器通信无论Redux还是React，工作方式都是靠数据驱动，到目前为止，本书数据都是通过用户输入产生，但现实中应用的数据往往存储在数据库中，通过一个API服务器暴露出来，网页应用要获得数据，就需要与服务器进行通信。 本章内容： React组件访问服务器的方式； Redux架构下访问服务器的方式 前者访问服务器的方式适用于简单的网页应用；对于复杂的网页应用，采用后者来管理数据，所以Redux环境中访问服务器是介绍的重点 7.1 React组件访问服务器最简单的场景，在一个及其简单的网页应用中，有可能单独使用React库而不使用Redux之类的数据管理框架。一个趋势是在React应用中使用浏览器原生支持的fetch函数来访问，fetch返回一个Promise对象，Promise模式能够让需要异步处理的代码简介清晰 7.1.1 代理功能访问API7.1.2 React组件访问服务器的生命周期7.1.3 React组件访问服务器的优缺点7.2 Redux 访问服务器7.2.1 redux-thunk中间件7.2.2 异步action对象7.2.3 异步操作的模式7.2.4 异步操作的中止7.3 Redux异步操作的其他方法7.3.1 如何挑选异步操作方式7.3.2 利用Promise实现异步操作7.4 本章小节第八章 单元测试第九章 扩展Redux第十章 动画第十一章 多页面应用第十二章 同构]]></content>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】新兴的API]]></title>
    <url>%2F2018%2F09%2F07%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E6%96%B0%E5%85%B4%E7%9A%84API%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】最佳实践]]></title>
    <url>%2F2018%2F09%2F07%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】离线应用与客户端存储]]></title>
    <url>%2F2018%2F09%2F07%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[本章内容： 进行离线检测 使用离线缓存 在浏览器中保存数据 支持离线Web应用开发是HTML5的另一个重点。所谓离线Web应用，就是在设备不能上网的情况下仍然可以运行的应用。开发离线Web应用还需要几个步骤。首先是确保应用知道设备是否能上网，以便下一步执行正确的操作。然后，应用还必须能访问一定的资源（图像、JavaScript、CSS等），只有这样才能正常工作。最后，必须有一块本地空间用于保存数据，无论能否上网都不妨碍读写。 23.1 离线检测Navigator.onLine online offline 23.2 应用缓存23.3 数据存储23.3.1 Cookie1、限制 2、cookie的构成 3、JavaScript中的cookie 23.3.2 IE用户数据23.3.3 Web存储机制23.3.4 indexedDB23.4 小结]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】高级技巧]]></title>
    <url>%2F2018%2F09%2F07%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】Ajax与Comet]]></title>
    <url>%2F2018%2F09%2F07%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91Ajax%E4%B8%8EComet%2F</url>
    <content type="text"><![CDATA[本章内容： 使用XMLHttpRequest对象 使用XMLHttpRequest事件 跨域Ajax通信的限制 21.1 XMLHttpRequest 对象21.1.1 XHR的用法open() send() responseText responseXML status statusText 21.1.2 HTTP头部信息 Accept Accept-Charset Accept-Encoding Accept-Language Connection Cookie Host Referer User-Agent 21.1.3 GET请求21.1.4 POST请求21.2 XMLHttpRequest 2级21.2.1 FormData21.2.2 超时设定21.2.3 overrideMimeType()方法21.3 进度事件21.3.1 load事件21.3.2 progress事件21.4 跨源资源共享21.4.1 IE对CORS的实现21.4.2 其他浏览器对CORS的实现21.4.3 Preflighted Reqeusts21.4.4 带凭据的请求21.4.5 跨浏览器的CORS21.5 其他跨域技术21.5.1 图像Ping21.5.2 JSONP21.5.3 Comet21.5.4 服务器发送事件21.5.5 Web Sockets21.5.6 SSE与Web Sockets21.6 安全21.7 小结]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】JSON]]></title>
    <url>%2F2018%2F09%2F07%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91JSON%2F</url>
    <content type="text"><![CDATA[本章内容： 理解JSON语法 解析JSON 序列化JSON 2006年，JSON（JavaScript Object Notation，JavaScript对象表示法）是JavaScript的一个严格的子集，利用了JavaScript中的一些模式来表示结构化数据。与XML相比JSON是在JavaScript中读写结构化数据更好的方式。因为可以把JSON直接传给eval()，而且不必创建DOM对象。 关于JSON，最重要的是理解它只是一种数据格式，不是一种编程语言。虽然具有相同的语法形式，但JSON并不从属于JavaScript。而且，并不是只有JavaScript。而且，并不是只有JavaScript才使用JSON，毕竟JSON只是一种数据格式。很多编程语言都有针对JSON的解析器和序列化器。 20.1 语法20.1.1 简单值20.1.2 对象20.1.3 数组20.2 解析与序列化20.2.1 JSON对象20.2.2 序列化选项1、过滤结果 2、字符串缩进 3、toJSON()方法 20.2.3 解析选项20.3 小结]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】E4X]]></title>
    <url>%2F2018%2F09%2F07%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91E4X%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】JavaScript与XML]]></title>
    <url>%2F2018%2F09%2F07%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91JavaScript%E4%B8%8EXML%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】错误处理与调试]]></title>
    <url>%2F2018%2F09%2F07%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】JavaScript与XML]]></title>
    <url>%2F2018%2F08%2F31%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91JavaScript%E4%B8%8EXML%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】HTML5脚本编程]]></title>
    <url>%2F2018%2F08%2F31%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91HTML5%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】使用Canvas绘图]]></title>
    <url>%2F2018%2F08%2F31%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E4%BD%BF%E7%94%A8Canvas%E7%BB%98%E5%9B%BE%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】表单脚本]]></title>
    <url>%2F2018%2F08%2F31%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E8%A1%A8%E5%8D%95%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[本章内容： 理解表单 文本框验证与交互 使用其他表单控制 JavaScript最初的一个应用，就是分担服务器处理表单的责任。尽管目前的Web和JavaScript已经有了长足的发展，但Web表单的变化并不明显。由于Web表单没有为许多常见任务提供现成的解决手段，很多开发人员不仅会在验证表单时使用JavaScript，而且还增强了一些标准表单控件的默认行为。 14.1 表单的基础知识14.1.1 提交表单14.1.2 重置表单14.1.3 表单字段1、共有的表单字段属性 disabled form name readOnly tabIndex type value 2、共有的表单字段方法 focus() blur() 3、共有的表单字段事件 blur change focus 14.2 文本框脚本1234567891011121314151617181920212223242526272829303132333435363738394041### 14.2.1 选择文本1、选择（select）事件2、取得选择的文本3、选择部分文本### 14.2.2 过滤输入1、屏蔽字符2、操作剪贴板- beforecopy- copy- beforecut- cut- beforepaste- paste### 14.2.3 自动切换焦点### 14.2.4 HTML5约束验证1、必填字段2、其他输入类型3、数值范围4、输入模式5、检测有效性6、禁用验证## 14.3 选择框脚本```&lt;select&gt; add(newOption,relOption) multiple option remove(index) selectedIndex size value &lt;option&gt; index label selected text value 14.3.1 选择选项14.3.2 添加选项14.3.3 移除选项14.3.4 移动和重排选项14.4 表单序列化14.5 富文本编辑14.5.1 使用contenteditable属性14.5.2 操作富文本14.5.3 富文本选区14.5.4 表单与富文本14.6 小结]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】事件]]></title>
    <url>%2F2018%2F08%2F31%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[本章内容： 理解事件流 使用事件处理程序 不同的事件类型 JavaScript与HTML之间的交互式通过事件实现的。事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间。可以使用侦听器（或处理程序）来预定事件，以便事件发生时执行相应的代码。这种在传统软件工程中被称为观察员模式的模型，支持页面的行为（JavaScript代码）与页面的外观（HTML和CSS代码）之间的松散耦合。 事件出现最初是为了分担服务器运算负载的一种手段。浏览器的事件系统相对比较复杂，所有主要浏览器实现的“DOM2级事件”本身没有涵盖所有事件类型，BOM事件与DOM事件之间的关系并不十分清晰。DOM3级事件出现后，增强的DOM事件API变的更加繁琐。使用时或简单或复杂，难易程度会因你的需求不同。不过，有关事件的一些核心概念是一定要理解的。 13.1 事件流事件流描述的是从页面接收事件的顺序。但IE和Netscape开发团队居然提出了差不多是完全相反的事件流的概念。IE的时间流是事件冒泡流，而Netscape Communicator的事件流是事件捕获流。 13.1.1 事件冒泡IE的事件流叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（文档中 嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。以下面的HTML页面为例： 123456789&lt;!DOCUTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Event Bubbling Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="myDiv"&gt;Click Me!&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 如果你单击了页面中的121、```&lt;div&gt; 2、123、```&lt;html&gt; 4、123456### 13.1.2 事件捕捉Netscape Communicator团队提出的另一种事件流叫做**事件捕获**（event capturing）。事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用语在于在事件到达预定目标之前捕获它。以前面的HTML页面为例，单击```&lt;div&gt;```元素会以下列顺序触发click事件：1、```document 2、123、```&lt;body&gt; 4、&lt;div&gt; 老版本的浏览器不支持事件捕获。建议放心使用事件冒泡，在有特殊需要时再使用事件捕获。 13.1.3 DOM事件流“DOM2级事件”规定的时间流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是事件的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件作出响应。以前面的简单HTML页面为例，单击&lt;div&gt;元素会按照如下图所示顺序触发事件： 在DOM事件流中，实际的目标（&lt;div&gt;元素）在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从document到&lt;html&gt;再到&lt;body&gt;后就停止了。下一阶段是“处于目标”阶段，于是事件在&lt;div&gt;发生，并在事件处理（后面会提到这个概念）中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回文档。 但多数支持DOM事件流的浏览器都实现了一种特定的行为；即使“DOM2级事件”规范明确要求捕获阶段不会 涉及事件目标，但都会在捕获阶段触发对象上的事件。结果就是有两个机会在目标对象上面操作事件。 13.2 事件处理程序事件就是用户或浏览器自身执行的某种动作。诸如click、load和mouseover，都是事件的名字。而响应某个事件的函数就叫做事件处理程序（或事件侦听器）。事件处理程序的名字以“on”开头。为事件指定处理程序的方式有好几种。 13.2.1 HTML事件处理程序某个元素支持的每种事件，都可以使用一个与相应时间处理程序同名的HTML特性来指定 13.2.2 DOM0级事件处理程序通过JavaScript指定时间处理程序的传统方式，就是将一个函数赋值给一个事件处理程序 13.2.3 DOM2级事件处理程序addEventListener() removeEventListener() 13.2.4 IE事件处理程序attachEvent() detachEvent() 13.2.5 跨浏览器的事件处理程序创建一个方法addHandler()，它属于一个名叫EventUtil的对象，使用这个对象来处理浏览器之间的差异 13.3 事件对象在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息 13.3.1 DOM中的事件对象兼容DOM的浏览器会将一个event对象传入到事件处理程序中。无论指定事件处理程序时使用什么方法（DOM0级或DOM2级），都会传入event对象 13.3.2 IE中的事件对象13.3.3 跨浏览器的事件对象13.4 事件类型13.4.1 UI事件13.4.2 焦点事件13.4.3 鼠标与滚轮事件13.4.4 键盘与文本事件13.4.5 复合事件13.4.6 变动事件13.4.7 HTML5事件13.4.8 设备事件13.4.9 触摸与手势事件13.5 内存和性能13.5.1 事件委托13.5.2 移出事件处理程序13.6 模拟事件13.6.1 DOM中的事件模拟13.6.2 IE中的事件模拟13.7 小结]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】DOM2和DOM3]]></title>
    <url>%2F2018%2F08%2F31%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91DOM2%E5%92%8CDOM3%2F</url>
    <content type="text"><![CDATA[本章内容： DOM2和DOM3的变化 操作样式的DOM API DOM的遍历和范围 DOM1级主要定义的是HTML和XML文档结构的底层结构。DOM2和DOM3级则在这个结构的基础上引入了更多交互能力，也支持了更高级的XML特性。为此，DOM2和DOM3级分为许多模块（模块之间具有某种关联），分别描述了DOM的某个非常具体的子集。这些模块如下： DOM2级核心（DOM Level 2 Core）：在1级核心基础上构建，为节点添加了更多方法和属性。 DOM2级视图（DOM Level 2 Views）：为文档定义了基于样式信息的不同视图。 DOM2级事件（DOM Level 2 Events）：说明了如何使用事件与DOM文档交互。 DOM2级样式（DOM Level 2 Style）：定义了如何以编程方式来访问和改变CSS样式信息。 DOM2级遍历和范围（DOM Level 2 Travesal and Range）：引入了遍历DOM文档和选择其特定部分的新接口。 DOM2级HTML（DOM Level 2 HTML）：在1级HTML基础上构建，添加了更多属性、方法和新接口。 本章探讨除“DOM2级事件”之外的所有模块，“DOM2级事件”模块将在13章进行全面讲解。 【DOM3级模块又增加了“XPath”模块和“加载和保存”（Load and Save）模块。这些模块将在第18章讨论】 12.1 DOM变化12.1.1 针对XML命名空间的变化1、Node类型的变化 2、Document类型的变化 3、Element类型的变化 4、NamedNodeMap类型的变化 12.1.2 其他方面的变化1、DocumentType类型的变化 2、Document类型的变化 3、Node类型的变化 4、框架的变化 12.2 样式12.2.1 访问元素的样式1、DOM样式属性和方法 2、计算的样式 12.2.2 操作样式表1、CSS规则 2、创建规则 12.2.3 元素大小1、偏移量 2、客户区大小 3、滚动大小 4、确定元素大小 12.3 遍历12.3.1 NodeIterrator12.3.2 TreeWalker12.4 范围12.4.1 DOM中的范围12.4.2 IE8及更早版本中的范围12.5 小结]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】DOM扩展]]></title>
    <url>%2F2018%2F08%2F31%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91DOM%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[本章内容： 理解Selectors API 使用HTML5 DOM扩展 了解专有的DOM扩展 尽管DOM作为API已经非常完善了，但为了实现更多的功能，仍然会有一些标准或专有的扩展。对DOM两个主要的扩展是Selectors API（选择符API）和HTML5。此外还有一个不那么引人瞩目的Element Traversal（元素遍历）规范，为DOM添加了一些属性。虽然前两个扩展已经涵盖了大量的DOM扩展，但专有扩展依然存在。本章也会介绍专有的DOM扩展。 11.1 选择符API11.1.1 querySelector()方法11.1.2 querySelectorAll()方法11.1.3 matchesSelector()方法11.2 元素遍历11.3 HTML511.3.1 与类相关的扩充1、getElementsByClassName()方法 2、classList()方法 11.3.2 焦点管理11.3.3 HTMLDocument的变化1、readyState属性 2、兼容模式 3、head属性 11.3.4 字符集属性11.3.5 自定义数据属性11.3.6 插入标记1、innerHTML属性 2、outerHTML属性 3、insertAdjacentHTML()方法 4、内存和性能问题 11.3.7 scrollIntoView()方法11.4 专有扩展11.4.1 文档模式11.4.2 children属性11.4.3 contains()方法11.4.4 插入文本1、innerText属性 2、outerText属性 11.4.5 滚动11.5 小结]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】DOM]]></title>
    <url>%2F2018%2F08%2F31%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91DOM%2F</url>
    <content type="text"><![CDATA[本章内容： 理解包含不同层次节点的DOM 使用不同的节点类型 克服浏览器兼容性问题及各种陷阱 DOM（文档对象模型）是针对HTML和XML文档的一个API（应用程序编程接口）。DOM描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。它已经成为表现和操作页面标记的真正跨平台、语言中立的方式。 1998年10月DOM1级规范成为W3C的推荐标准，为基本的文档结构及查询提供了接口。本章主要讨论与浏览器中HTML页面相关的DOM1级的特性和应用，以及JavaScript对DOM1级的实现。IE、Firefox、Safari、Chrome和Opera都非常完善地实现了DOM。 【注意，IE中所有的DOM对象都是以COM对象的形式实现的。IE中的DOM对象与原生JavaScript对象的行为或活动特点并不一致。本章将较多地谈及这些差异】 10.1 节点层次DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构。节点分为几种不同的类型，每种类型分别表示文档中不同的信息及（或）标记。每个节点都拥有各自的特点、数据和方法，另外也与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构。以下面HTML为例： 12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;Sample Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; Hello World! &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 其层次结构如下： 在这个例子中，文档节点只有一个子节点即12345678910111213141516171819202122232425262728每一段标记都可以通过树中的一个节点来表示；HTML元素通过元素节点表示，特性（attribute）通过特性节点表示，文档类型节点通过文档类型节点表示，注释节点通过注释节点表示。总共有12中节点类型，这些类型都继承自一个基类型。### 10.1.1 Node类型DOM1级定义了一个Node接口，该接口将由DOM中所有节点类型类型实现。这Node接口在JavaScript中是作为Node类型实现的；JavaScript中的所有节点类型都继承自Node类型，因此所有节点类型都共享着相同的基本属性和方法。每个节点都有一个nodeType属性，用来表明节点的类型。节点类型由在Node类型中定义的下列12个数值常量来表示，任何节点类型必居其一：- Node.ELEMENT_NODE(1)- Node.ATTRIBUTE_NODE(2)- Node.TEXT_NODE(3)- Node.CDATA_SECTION_NODE(4)- Node.ENTITY_REFERENCE_NODE(5)- Node.ENTITY_NODE(6)- Node.PROCESSING_INSTRUCTION_NODE(7)- Node.COMMENT_NODE(8)- Node.DOCUMENT_NODE(9)- Node.DOCUMENT_TYPE_NODE(10)- Node.DOCUMENT_FRAGMENT_NODE(11)- Node.NOTATION_NODE(12)通过比较上面这些常量，就可以很容易地确定节点的类型：```javascriptif(someNode.nodeType == 1)&#123; alert(&quot;Node is an element&quot;)&#125; 开发人员最常用的是元素和文本节点，本章后面将详细讨论每个节点类型的受支持情况及使用方法。 1、nodeName和nodeValue属性 123if(someNode.nodeType == 1)&#123; //先检查是不是一个元素 value = someNode.nodeName; //元素标签名&#125; nodeName中保存的始终是元素的标签名；nodeValue的值始终为null。 2、节点关系 每个节点都有一个childNodes属性，其中保存着一个NodeList对象。NodeList是一种类数组对象，是动态执行查询的结果，用于保存一组有序的节点，这个对象也有length属性，访问这些节点的方式——可以通过方括号，也可以使用item()方法： 123var firstChild = someNode.childNodes[0];var secondChild = someNode.childNodes.item(1);var count = someNode.childNodes.length; //访问那一刻的length 每个节点都有一个parentNode属性，该属性指向文档树中的父节点；previousSibling属性指向前一个同胞节点；nextSibling属性指向后一个同胞节点。这些关系指针都是只读的。 【虽然每种节点类型都继承自Node，但不是每种节点都有子节点。本章后面将会讨论不同节点类型之间的差异】 3、操作节点 appendChild(要插入的节点)用于向childNodes列表末尾添加一个节点。添加后所有关系指针将得到响应的更新； insertBefore(要插入的节点，作为参照的节点)方法用于向childNodes列表特定位置添加一个节点； replacedNode(要插入的节点，要替换的节点)方法用于向childNodes列表特定位置替换一个节点； removeNode(要移除的节点)方法用于向childNodes列表移除一个节点； 后两个方法替换和移除掉的节点仍然为文档所有，只不过在文档中已经没有了自己的位置。这四个方法只能用在支持子节点的节点上。 4、其他方法 有两个方法是所有类型节点都有的。 cloneNode() 用于创建调用这个方法的节点的一个完全相同的副本；复制后的节点属于文档所有，未指定父节点时没有位置，除非通过上面前三个方法添加进文档中； normalize()用于处理文档树中的文本节点；在文本节点不包含文本时删除这个节点，或者接连出现两个文本节点时合并这两个节点。 10.1.2 Document类型JavaScript通过Document类型表示文档。在浏览器中，document对象是HTMLDocument（继承自Document类型）的一个实例，表示整个HTML页面。而且document对象是window对象的一个属性，因此可以作为全局对象来访问。Document节点具有下列特征： nodeType值为9； nodeName值为“#document”； nodeValue值为null； parentNode值为null； ownerDocument值为null； 其子节点可能是一个DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction或Comment。 Document类型可以表示HTML页面或其他基于XML的文档。不过，最常见的应用还是作为HTMLDocument示例的document对象。通过这个文档对象，不仅可以取得与页面有关的信息，而且还能操作页面的外观及底层结构。 1、文档的子节点 DOM标准规定Document节点的子节点可以是一个DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction或Comment，还有两个内置的访问其字节点的快捷方式：documentElement属性；body属性： 12345&lt;html&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 上面这个页面经浏览器解析后其文档中只包含一个子节点即1234567```javascriptvar html = document.documentElement; //取得对&lt;html&gt;的调用alert(html === document.childNodes[0]); //truealert(html === document.firstChild); //truevar body = document.body; //取得对&lt;body&gt;的引用 Document其他的可能子节点里的DocumentType，可以通过documentType属性访问: 1var doctype = document.documentType; //取得对&lt;!DOCTYPE&gt;的引用 2、文档信息 作为HMTLDocument的一个实例，document对象还有一些标准的Document对象没有的属性： 1234567var title = document.title //取得文档标题document.title = "New page title" //设置文档标题//与网页请求相关的3个属性，只有domain属性是可以设置的var url = document.URL; //取得完整的URLvar domain = document.domain; //取得域名var referrer = document.refferer; //取得来源页面的URL 3、查找元素 最常见的DOM应用，取得特定某个或某组元素的引用，然后执行一些操作。取得元素的操作可以使用document对象的几个方法来完成。Document类型为此提供了两个方法： getElementById()返回查找到的第一个匹配元素； getElementsByTagName()返回零个或多个元素的NodeList（在HTML文档中返回HTMLCollection对象）； getElementsByName()返回特定name特性值的零个或多个元素的NodeList（在HTML文档中返回HTMLCollection对象）。 4、特殊集合 除了属性和方法，document对象还有一些特殊的结合。这些集合都是HTMLCollection对象(会随着文档内容的更新而更新)，为访问文档常用的部分提供了快捷方式： document.anchors document.applets document.forms document.images document.links 5、DOM一致性检测 由于DOM分级别，包含多个部分，因此检测浏览器实现了DOM哪些部分就十分必要了。document.implementation属性的hasFeature(要检测的DOM功能，版本号)方法，支持则返回true： 1var hasXMLDom= document.implementation.hasFeature("XML","1.0") 最好出了检测hasFeatrue前也进行能力检测，因为各个浏览器对这个方法支持不一致。 6、文档写入 document对象有4个方法，将输入流写入网页中，都接收一个写入流字符串参数： write() 原样写入字符串 writeIn() 在字符串末尾再加上一个换行符（12345678910111213141516171819202122232425262728293031323334353637383940414243open() 打开网页输出流close() 关闭网页输出流### 10.1.3 Element类型出了Document类型之外，Element类型就要算是Web编程中最常用的类型了。它用于表现HTML和XML元素，提供了对元素标签名、字节点及特性的访问，有以下特征：- nodeType值为1；- nodeName值为元素的标签名；- nodeValue值为null；- parentNode值可能是Document或Element；- 其子节点可能是一个Element、Text、ProcessingInstruction、CDATASection、Comment或EntityReference。要访问元素的标签名，可以使用nodeName属性，也可以使用tagName属性；这两个值会返回相同的值1、HTML元素 所有的HTML元素都由HTMLElement类型表示，不是直接通过这个类型，也是通过它的子类型来表示。HTMLElement类型直接继承自Element并添加了一些属性。添加的这些属性分别对应于每个HTML元素中都存在的下列标准特性：可以获取和设置- id- title- lang- dir- className2、取得特性（文档里面元素的属性）每个元素都有一或多个特性（与DOM对象的属性区分开），这些特性的用途是给出相应元素或其内容的附加内容。操作特性的DOM方法主要有三个，均接收特性名作为参数：getAttribute()setAttribute()removeAttribute()```html&lt;div id=&quot;myDiv&quot; align=&quot;left&quot; my_special_attribute=&quot;hello!&quot;&gt;&lt;/div&gt; 123var div = document.getElementById("myDiv");alert(div.getAttribute("id")); //"myDiv"alert(div.id == div.getAttribute("id")); //true 有两类特殊的特性，虽然有对应的属性名，但属性的值与通过getAttribute()返回的值不一样。第一个是style，通过getAttribute()返回CSS文本，通过属性返回对象（因为style属性是用于编程方式访问元素样式的，因此并没有直接映射到style特性）；第二个特性是onclick这样的事件处理程序，通过getAttribute()返回相应代码的字符串，通过属性返回JavaScript函数（如未在元素中指定相应特性，则返回null），这是因为onclick及其他事件处理程序属性本事就应该被赋予函数值。 由于存在这些差别，在通过JavaScript以编程方式操组DOM时，开发人员经常不使用getAttribute()，而是只使用对象的属性。只有在取得自定义特性值的情况下，才会使用getAttribute() 3、设置特性 与getAttribute()相对的setAttribute(要设置的特性名，值) 4、attributes属性（不如2常用） Element类型是使用attributes属性的唯一一个DOM节点类型。attributes属性中包含一个NamedNodeMap，与NodeList类似，也是一个动态的集合。元素的每一个特性都由一个Attr节点表示，每个节点都保存在NamedNodeMap对象中。NamedNodeMap对象拥有以下方法： getNamedItem(name)： 返回nodeName属性等于name的节点； removeNamedItem(name)： 从列表中移除nodeName属性等于name的节点；与在元素上调用removeAtrribute效果相同，但会返回被删除特性的Attr节点 setNamedItem(node)： 向列表中添加节点，以节点的nodeName属性为索引； item(pos)：返回位于数字pos位置处的节点 attributes属性中包含的节点的nodeName就是特性的名称，而节点的nodeValue就是特性的值： 123//取得元素的id特性var id = element.attributes.getNamedItem("id").nodeValue;var id = element.attributes["id"].nodeValue; //使用方括号访问 5、创建元素 document.createElement(标签名)方法，再使用appendChild()、insertBefore()或replaceChild()方法添加到文档元素中； document.createElement(完整元素标签) 6、元素的字节点 元素可以有任意树木的子节点和后代节点，因为元素可以是其他元素的子节点。元素的childNodes属性中包含了它的所有子节点，这些子节点有可能是元素、文本节点、注释或处理指令。 10.1.4 Text类型文本节点由Text类型表示，包含的是可以照字面解释的纯文本内容： nodeType值为3； nodeName值为”#text”； nodeValue值为节点所包含的文本； parentNode值是一个Element； 不支持（没有）子节点。 可以通过nodeValue属性或data属性访问Text节点中包含的文本。操作节点文本的方法： appendDate(text) deleteDate(offset,count) insertData(offset,text) replaceDate(offset,count,text) splitText(offset) substringData(offset,count) 除这些方法外，文本节点还有一个length属性 1、创建文本节点 document.createTextNode(要插入节点的文本) 2、规范化文本节点 在一个包含两个或多个文本节点的父元素上调用normalize()方法，则会将所有文本节点合并成一个。 3、分割文本节点 与normalize()方法相反splitText()方法将一个文本节点分成两个文本节点。 分割文本节点是从文本节点中提取数据的一种常见的DOM解析技术。 10.1.5 Comment类型注释在DOM中是通过Comment类型来表示的。有以下特征： nodeType值为8； nodeName值为”#comment”； nodeValue值为注释的内容； parentNode值可能是Document或Element； 不支持（没有）子节点。 Comment类型与Text类型继承自相同的基类，因此它拥有除splitText()以外的所有字符串操作方法。与Text类型相似，也可以通过nodeValue属性或data属性访问注释内容。 还可以使用document.createComment()创建注释节点 10.1.6 CDATASection类型CDATASection类型只针对基于XML的文档 10.1.7 DocumentType类型DocumentType包含着与文档doctype有关的所有信息，它具有下列特征： nodeType值为10； nodeName值为doctype的名称； nodeValue值为null； parentNode值是Document； 不支持（没有）子节点。 10.1.8 DocumentFragment类型10.1.9 Attr类型10.2 DOM操作技术很多时候，DOM操作都比较简明，因此用JavaScript生成那些通常原本是用HTML代码生成的内容并不麻烦。不过有些时候，操作DOM并不像表面上看起来那么简单 10.2.1 动态脚本使用&lt;script&gt;元素可以向页面中插入JavaScript代码，一种方式是通过其src特性包含外部文件，另一种方式就是用这个元素本事来包含代码。动态脚本指的是在页面加载时不存在，但在将来的某一时刻通过修改DOM动态添加的脚本。跟操作HTML元素一样，创建动态脚本也有两种方式：插入外部文件和直接插入JavaScript代码 10.2.2 动态样式10.2.3 操作表格10.2.4 使用NodeList10.3 小结]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】客户端检测]]></title>
    <url>%2F2018%2F08%2F31%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[本章内容： 使用能力检测 用户代理检测的历史 选择检测方式 浏览器提供商虽然在实现公共接口方面投入了很多精力，但结果任然是每一种浏览器都有各自的长处和缺点。面对普遍存在的不一致性问题，开发人员要么采取迁就各方的“最小公分母”策略，要么（也是更常见的）就得利用各种客户端检测方法，来突破或者规避种种局限性。 9.1 能力检测9.1.1 更可靠的能力检测9.1.2 能力检测，不是浏览器检测9.2 怪癖检测9.3 用户代理检测9.3.1 用户代理字符串的历史9.3.2 用户代理字符串检测技术9.3.3 完整的代码9.3.4 使用方法9.4 小结]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】BOM]]></title>
    <url>%2F2018%2F08%2F31%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91BOM%2F</url>
    <content type="text"><![CDATA[本章内容： 理解window对象——BOM的核心 控制窗口、框架和弹出窗口 利用location对象中的页面信息 使用navigator对象了解浏览器 ECMAScript是JavaScript的核心，但如果要在Web中使用JavaScript，那么BOM（浏览器对象模型）则无疑才是真正的核心。BOM提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。W3C把浏览器中JavaScript最基本的部分标准化，已经将BOM中的主要方面纳入了HTML5的规范中。 8.1 window对象8.1.1 全局作用域8.1.2 窗口关系及框架8.1.3 窗口位置8.1.4 窗口大小8.1.5 导航和打开窗口8.1.6 间歇调用和超时调用8.1.7 系统对话框8.2 location对象8.2.1 查询字符串参数8.2.2 位置操作8.3 navigator对象8.3.1 检测插件8.3.2 注册处理程序8.4 screen对象8.5 history对象8.6 小结]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES5和ES6的继承]]></title>
    <url>%2F2018%2F08%2F25%2FES5%E5%92%8CES6%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[Javascript中的继承一直是个比较麻烦的问题，prototype、constructor、proto在构造函数，实例和原型之间有的复杂的关系，不仔细捋下很难记得牢固。ES6中又新增了class和extends，和ES5搅在一起，加上平时很少自己写继承，简直乱成一锅粥。不过还好，画个图一下就清晰了，下面不说话了，直接上图，上代码。 ES5ES5中的继承，看图： 123456789101112function Super() &#123;&#125; function Sub() &#123;&#125;Sub.prototype = new Super();Sub.prototype.constructor = Sub; var sub = new Sub(); Sub.prototype.constructor === Sub; // ② truesub.constructor === Sub; // ④ truesub.__proto__ === Sub.prototype; // ⑤ trueSub.prototype.__proto__ == Super.prototype; // ⑦ true ES5中这种最简单的继承，实质上就是将子类的原型设置为父类的实例。 ES6ES6中的继承，看图： 1234567class Super &#123;&#125; class Sub extends Super &#123;&#125; var sub = new Sub(); Sub.prototype.constructor === Sub; // ② true sub.constructor === Sub; // ④ true sub.__proto__ === Sub.prototype; // ⑤ true Sub.__proto__ === Super; // ⑥ true Sub.prototype.__proto__ === Super.prototype; // ⑦ true 所以ES6和ES5的继承是一模一样的，只是多了class 和extends ，ES6的子类和父类，子类原型和父类原型，通过__proto__ 连接。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】面向对象的程序设计]]></title>
    <url>%2F2018%2F08%2F25%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[本章内容： 理解对象属性 理解并创建对象 理解继承 面向对象的语言有一个标志，那就是它们都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。前面提到过，ECMAScript中没有类的概念，因此它的对象也与基于类的语言中的对象有所不同。 ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因），我们可以把ECMAScript的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数。 每个对象都是基于一个引用类型创建的，这个引用类型可以是第5章讨论的原生类型，也可以是开发人员定义的类型。 6.1 理解对象上一章介绍过，创建自定义对象最简单的方式就是创建一个Object的实例，然后再为它添加属性和方法；对象字面量创建对象更为常用： 12345678910111213141516171819var person = new Object();person.name = "Nicholas";person.age = 29;person.jon = "Software Engineer";person.sayName = function () &#123; alert(this.name);&#125;;-------------------------------------------------------------var person = &#123; name: "Nicholas", age: 29, job: "Software Engineer", sayName: function() &#123; alert(this.name); &#125;&#125;; person对象包含一些属性和方法。这些属性在创建时都带有一些“特征值”，JavaScript通过这些特征值来定义它们的行为 6.1.1 属性类型ECMA-262描述了属性的各种特征的【特性】，属于内部特性，在JavaScript中不能直接访问它们。ECMAScript中有两种属性：数据属性和访问器属性 1、数据属性 数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性： [[Configurable]]：表示能否通过delete删除属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性的默认值时true； [[Enumerable]]：表示能否通过for-in循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性的默认值时true； [[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性的默认值时true； [[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置度；写入属性值的时候，把新值保存在这个位置。这个特性的默认值是undefined。 要修改属性的默认的特性，必须使用ECMAScript5的Object.defineProperty()方法。这个方法接收三个参数Object.defineProperty(属性所在的对象，属性的名字，描述符对象)，描述符对象的属性必须是：configurable、enumerable、writable和value 12345678910var person = &#123;&#125;Object.defineProperty(person,"name",&#123; writeble:false, value: "Nicholas"&#125;);alert(person.name); //"Nicholas"person.name="Greg";alert(person.name) //"Nicholas" 2、访问器属性 访问器属性不包含数据值；它们包含一对儿getter和setter函数（不过，这两个函数都不是必须的）。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性： [[Configurable]]：表示能否通过delete删除属性，能否修改属性的特性，或者能否把属性修改为访问器属性。对于直接在对象上定义的属性，它们的这个特性的默认值是true； [[Enumerable]]：表示能否通过for-in循环返回属性。对于直接在对象上定义的属性，它们的这个特性的默认值是true； [[Get]]：在读取属性时调用的函数。默认值为undefined； [[Set]]：在写入属性时调用的函数。默认值为undefined。 访问器属性不能直接定义，必须使用Object.defineProperty()方法来定义。示例： 12345678910111213141516171819var book = &#123; _year: 2004, //"_"常用来表示只能通过对象方法访问的属性 edition: 1&#125;;Object.defineProperty(book, "year", &#123; //访问器属性“year” get: funtion()&#123; return this._year; &#125;, set: funtion()&#123; if (newValue &gt; 2004)&#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;);book.year = 2005;alert(book.edition); //2 以上是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化 6.1.2 定义多个属性ECMAScript5定义一个defineProperties()方法，利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：defineProperties(要添加和修改其属性的对象，往第一个对象中要添加和修改的属性) 12345678910111213141516171819202122var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; //数据属性 value: 2004, writable: false &#125;, edition: &#123; //数据属性 value: 1 &#125;, year: &#123; //访问器属性 get: function()&#123; return this._year; &#125;, set: function()&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue -2004; &#125; &#125; &#125;&#125;); 6.1.3 读取属性的特性ECMAScript5中Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、writable和value： 1234567891011121314151617181920212223242526272829303132var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; //数据属性 value: 2004, writable: false &#125;, edition: &#123; //数据属性 value: 1 &#125;, year: &#123; //访问器属性 get: function()&#123; return this._year; &#125;, set: function()&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue -2004; &#125; &#125; &#125;&#125;);var descriptor = Object.getOwnPropertyDescriptor(book, "_year");alert(descriptor.value); //2004alert(descriptor.configurable); //falsealert(descriptor.get); //undefinedvar descriptor = Object.getOwnPropertyDescriptor(book, "year");alert(descriptor.value); //undefinedalert(descriptor.configurable); //falsealert(descriptor.get); //"function" 6.2 创建对象虽然Object构造函数或对象字面量都可以用来创建单个对象，但是这些方式有明显的缺点：使用同一个接口创建很多对象，会产生大量重复代码。为解决这个问题，人们开始使用工厂模式的一种变体 6.2.1 工厂模式工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。考虑到ECMAScript中无法创建类，开发人员救发明了一种函数，用函数来封装以特定接口创建对象的细节： 12345678910111213function createPerson(name,age,job) &#123; var o = new Object(); o.name=name; o.age=age; o.job=job; o.sayName=function()&#123; alert(this.name); &#125;; return o;&#125;var person1=createPerson("Nicholas",29,"Software Engineer");var person2=createPerson("Greg",27,"Doctor"); 函数createPerson能根据接收的参数来构建一个包含所有必要信息的Person对象。每次返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（如何知道对象的类型） 6.2.2 构造函数模式前几章介绍过ECMAScript中的构造函数可以用来创建特定类型的对象。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。此外也可以自定义构造函数，从而定义自定义对象类型的属性和方法： 1234567891011function Person(name,age,job) &#123; this.name=name; this.age=age; this.job=job; this.sayName=function()&#123; alert(this.name); &#125;;&#125;var person1 = new Person("Nicholas",29,"Software Engineer");var person2 = new Person("Greg",27,"Doctor"); 要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历以下4个步骤： 1、创建一个新对象； 2、将构造函数的作用域赋给新对象（因此这个this指向了这个新对象） 3、执行构造函数中的代码（为这个新对象添加属性） 4、返回新对象 在前面例子的最后，person1和person2分别保存着Person的一个不同实例。这两个对象都有一个constructor（构造函数）属性，该属性指向Person 创建自定义的构造函数意味着可以使用其示例标识为一种特定的类型，工厂模式就不行 1、将构造函数当作函数构造函数和其他函数的唯一区别就是调用方式不同。任何函数只要通过new操作符调用，它就可以作为构造函数；任何函数只要不通过new操作符调用，它就跟普通函数没有什么区别 2、构造函数的问题每个方法都要在每个实例上重新创建一遍 12345678910111213function Person(name,age,job) &#123; this.name=name; this.age=age; this.job=job; this.sayName=function()&#123; //等于this.sayName = new Function(" alert(this.name);") alert(this.name); &#125;;&#125;var person1 = new Person("Nicholas",29,"Software Engineer");var person2 = new Person("Greg",27,"Doctor");alert(person1.sayName==person2.sayName) //false 6.2.3 原型模式每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有示例所共享的属性和方法。即prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处就是可以让所有对象实例共享它所包含的属性和方法 12345678910111213141516function Person()&#123;&#125;Person.prototype.name="Nicholas";Person.prototype.age=29;Person.prototype.job="Software Engineer";Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); //"Nicholas"var person1 = new Person();person1.sayName(); //"Nicholas"alert(person1.sayName==person2.sayName) //true 所有的属性和方法都直接添加到Person的prototype属性中，构造函数成了空函数。新对象的属性和方法是所有实例共享的。要理解原型模式的原理，先要了解原型对象的性质： 1、理解原型对象无论什么时候只要创建了一个新函数，就会为（自动）该函数创建一个prototype属性，这个属性指向新函数的原型对象。默认情况下，所有原型对象都会自动获得一个constructor属性，包含一个指向 指向自己的 prototype属性 所在的函数 的指针 虽然这两个实例都不包含属性和方法，但我们却可以调用person1.sayName()，这是通过查找对象属性的过程来实现的。虽然在所有实现中都无法访问到[[prototype]]，但是可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系。ECMAScript5中新增了Object.getPrototypeOf()返回[[prototype]]的值 123alert(Person.isPrototypeOf(person1)); //truealert(Object.getPrototypeOf(person1)==Person.prototype); //true hasOwnProperty()方法可以检测一个属性是否存在【实例】中 2、原型与in操作符in操作符只要能访问到的属性就返回true，如果in操作符返回true，hasOwnProperty()方法返回false，则可以判断属性在原型中 使用for-in循环返回的是所有能够通过对象访问的、可枚举的属性；ECMAScript5中新增了Object.keys()方法返回一个对象里所有可枚举属性组成的数组；hasOwnPropertyNames()方法返回所有属性，不管可不可以枚举 3、更简单的原型语法用一个包含所有属性和方法的对象字面量 4、原型的动态性对原型对象所做的任何修改，都能立即从实例上反映出来 5、原生对象的原型原型模式的重要性不仅体现在自定义类型方面，原生的引用类型，都是采用这种模式船舰的。所有原生引用类型（Object、Array、String等）都在其构造函数的原型上定义了方法 6、原型对象的问题省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下取得相同的属性值，和 1、包含引用类型的值的原型属性被共享 2、创建子类型的实例时，不能向超类型的构造函数传递参数 6.2.4 组合使用构造函数模式和原型模式组合使用构造函数模式和原型模式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性 1234567891011121314function Person(name,age,job) &#123; this.name=name; this.age=age; this.job=job;&#125;Person.prototype&#123; constuctor: Person, sayName: function()&#123; alert(this.name); &#125;&#125;;var person1 = new Person("Nicholas",29,"Software Engineer");var person2 = new Person("Greg",27,"Doctor"); 6.2.5 动态原型模型封装构造函数和原型，通过把所有信息都封装在构造函数中，在构造函数中初始化原型（仅在必要情况下），又保持了同时使用构造函数和原型的优点 12345678910function Person(name,age,job) &#123; this.name=name; this.age=age; this.job=job; if(typeOf(this.sayName != "undefined"))&#123; Person.prototype.sayName= function()&#123; alert(this.name); &#125; &#125;&#125;; 6.2.6 寄生构造函数模式其实寄生构造函数就是在原生构造函数上的一个扩展，也就是你可以利用寄生构造函数来自定义一种引用类型，实现自己想要达到的效果 6.2.7 稳妥构造函数模式所谓稳妥对象， 指的是没有公共属性， 而且其方法也不引用this的对象。稳妥对象函数遵循与寄生构造函数类似的模式， 但有两点不同： 一是新创建对象的实例方法不引用this； 二是不使用new操作符调用构造函数。 最近在浏览博客时发现很多人好像理解错这个稳妥构造函数了， 这个函数与在《javascript 高级程序设计》中提到的其他构造函数的一大特点在于可以利用js作用域实现私有变量化。 123456789101112function Process (nameF) &#123; var o = new Object(); var name = nameF;//1 o.sayName = function()&#123; alert(name);//2 &#125;; return o;&#125;var friend = Process('Nick');friend.sayName(); //"Nick"console.log(friend.name);//undefined//3 注意： （以下3点） 在稳妥构造函数中变量不能挂到要返回的对象o中 在稳妥构造函数中的自定义函数操作元素时使用不要用this 在函数外部使用稳妥构造函数时不用new。 6.3 继承由于函数没有签名，在ECMAScript中无法实现接口继承，只支持实现继承，而且其实现继承主要是依靠原型链来实现的 6.3.1 原型链使用一个原型的实例作为另一个函数的原型 1、别忘记默认的原型2、确定原型与实例的关系instanceof操作符，isPrototypeOf()方法 3、谨慎地定义方法给原型添加方法的代码一定要放在替换原型的语句之后 4、原型链的问题1、包含引用类型的值的原型属性被共享 2、创建子类型的实例时，不能向超类型的构造函数传递参数 6.3.2 借用构造函数也称为伪造对象或经典继承。在子类型构造函数的内部调用超类型构造函数（使用apply()和call()） 12345678function SuperType (name) &#123; this.name=name;&#125;;function SubType(name)&#123; SuperType.call(this,"Nicholas"); //继承了SuperType还传递了参数 this.age=29; //实例属性&#125; 存在的问题：方法都在构造函数中定义，函数复用无从谈起 6.3.3 组合继承也叫伪经典继承，即原型链+构造函数。使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承 6.3.4 原型式继承6.3.5 寄生式继承6.3.6 寄生组合式继承6.4 小结]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】变量、作用域和内存问题]]></title>
    <url>%2F2018%2F08%2F25%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本章内容： 理解基本类型和引用类型的值 理解执行环境 理解垃圾收集 JavaScript变量松散类型的本质决定了它只是在特定时间用于保存特定值的一个名字而已。变量的值及其数据类型可以在脚本的生命周期内改变。JavaScript变量实际的复杂程度还远不止如此 4.1 基本类型和引用类型ECMAScript变量可能包含两种不同数据类型的值：基本类型和引用类型值。基本类型值指的是简单的数据段，引用类型值指那些可能由多个值构成的对象 5种基本数据类型Undefined、Null、Boolean、Number和String是按值访问的，可以直接操作保存在【变量】中的实际的值 引用类型的值是保存在【内存】中的对象。JavaScript不允许直接访问内存中的位置（不能直接操作对象的内存空间）。在操作对象时，实际上是在操作对象的引用而不是实际的对象，引用类型的值是按引用访问的 【在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的。ECMAScript放弃了这一传统】 4.1.1 动态的属性定义基本类型值和引用类型的值的方式是类似的：创建一个变量并为它赋值。值保存到变量以后，对引用类型的值可以动态的添加／删除属性和方法，基本类型的值不行 4.1.2 复制变量值除了保存方式不同，在从一个变量向另一个变量复制基本类型值和引用类型值也存在不同。总的来说都是复制变量值的内容，因为引用类型保存的是对象指针，所以被复制的引用类型值都是指向同一个对象 4.1.3 传递参数ECMAScript中所有函数的参数都是【按值传递】的。基本类型值的传递如同基本类型变量的复制，引用类型值的传递如同引用类型变量的复制 在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，argument对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反应在函数外部，但它仍然是【按值传递】，而非引用 【可以把ECMAScript函数的参数想象成局部变量】 4.1.4 检测类型要检测一个变量是不是基本数据类型，章3介绍了typeof操作符，能确定一个变量是字符串、数值、布尔值还是undefined。一个变量如果是null或对象，typeof都返回“object”，可以使用instanceof操作符（根据原型链识别，第6章详细介绍）判断对象是什么类型： 1234result = variable instanceof constuctoralert(person instanceof Object); //truealert(colors instanceof Array); 4.2 执行环境及作用域执行环境（execution，简称“环境”）是JavaScript中最为重要的一个概念。定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问到这个对象，但解析器在处理数据时会在后台使用它。 全局执行环境是最外围的一个执行环境。在Web浏览器中，全局环境被认为是window对象。每个函数都有自己的执行环境。当代码在一个环境中执行时，会创建变量对象的一个作用域链，用于保证对执行环境有权访问的所有变量和函数的有序访问。如果这个环境是函数，则将其活动对象作为变量对象。活动对象在最开始时只包含一个变量，即argument对象（这个对象在全局对象中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境，一直延伸到全局执行环境；全局执行环境的变量对象是种都是作用域链中的最后一个对象。 标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直到找到标识符为止 【函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同】 4.2.1 延长作用域链虽然执行环境的类型只有两种——全局和局部（函数），还是有其他办法来延长作用域链。因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。有两种情况会发生这种情况： try-catch语句的catch块：创建一个新的变量对象，其中包含的是被抛出的错误对象的声明 with语句：会将指定的对象添加到作用域链中 123456789function bulidUrl() &#123; var qs = "?debug=true"; with (location) &#123; //location对象被加到了作用域链的前端 var url = href + qs; &#125; return url;&#125; 4.2.2 没有块级作用域（ES5）JavaScript没有块级作用域。在if、for等语句中声明的变量会被添加到当前的执行环境 1、声明变量使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境就是函数环境。如果初始化没有用var声明，该变量会自动被添加到全局环境【建议初始化变量前都要先声明】 2、查询标识符当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符 4.3 垃圾收集 JavaScript具有自动的垃圾收集机制：找出那些不再继续使用的变量，然后释放其占用的内存。用于表示无用变量的策略具体在浏览器中的实现有两种： 4.3.1 标记清除 JavaScript最常见的垃圾收集方式是标记清除。当变量进入环境（如在函数中声明一个变量），将其标记为“进入环境”。而当变量离开环境，则将其标记为“离开环境”，在垃圾收集器运行时，销毁那些不在环境中或不被环境中的变量所引用的变量 4.3.2 引用计数另一种不太常见的垃圾收集策略叫引用计数。跟踪记录每个值被引用的次数，当一个值的引用次数变为0，就收回其占用的内存。有循环引用问题 4.3.3 性能问题垃圾收集器是周期性运行的，如果为变量分配的内存数量很客观，那么回收工作量也是相当大的。确定一个垃圾收集的时间间隔非常重要 4.3.4 管理内存使用具备垃圾收集机制的语言编写程序，一般不必操心内存管理的问题。 但JavaScript在进行内存管理及垃圾收集时面临的问题还是有点与众不同，主要因为分配给Web浏览器的可用内存数量通常要比非配给桌面应用程序的少，内存限制不仅会影响给变量分配内存，还会影响调用栈以及在一个线程中能够同时执行的语句数量 因此确保占用最少的内存可以让页面获得更好的性能。优化内存占用的最好方式就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其设置为null来释放其引用（引用解除），适用于大多数全局变量和全局对象的属性。局部变量会在离开执行环境时被自动解除引用 123456789function createPerson(name)&#123; var lacalPerson = new Object(); localPerson.name = name; return localPerson&#125;var globalPerson = createPerson("Nicholas");//手工解除globalPerson的引用globalPerson = null; 4.4 小结JavaScript变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自一下5种基本数据类型：Undefined、Null、Boolean、Number和String。基本类型值和引用类型值具有以下特点： 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中； 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本； 引用类型的值是对象，保存在堆内存中； 包含引用类型值的变量实际上包含的并不是对象本身，而是指向该对象的指针； 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量始终都指向同一个对象； 确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符 所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结： 执行环境有全局执行环境（也称全局环境）和函数执行环境之分； 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链； 函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境； 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部欢聚中的任何数据； JavaScript是一门具有自动垃圾收集机制的编程语言，开发人员不必关系内存分配和回收问题。可以对JavaScript的垃圾回收例程作如下总结： 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除； “标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存； 另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数； 当代码中存在循环引用现象时，“引用计数”算法就会导致问题 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】基本概念]]></title>
    <url>%2F2018%2F08%2F25%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[本章基本内容： 语法 数据类型 流控制语句 理解函数 描述所有语言的工作原理，描述的内容涵盖语法、操作符、数据类型、内置功能等用于构建复杂解决方案的基本概念。ECMA-262通过ECMAScript的伪语言描述了JavaScript的所有这些基本概念 3.1 语法ECMAScript的语法大量借鉴C以及其他类C语言（如Java和Perl）的语法 3.1.1 区分大小写ECMAScript中的一切（变量、函数名和操作符）都区分大小写 3.1.2 标识符标识符：变量、函数、属性的名字，或者函数的参数。标识符可以是按照以下格式规则组合起来的一个或多个字符： 第一个字符必须是字母、下划线_、或者美元符号💲 其他字符可以是字母、下划线、美元符号或数字 【不能把关键字、保留字、true、false和null用作标识符】，ECMAScript标志符采用驼峰大小写格式 3.1.3 注释1234//单行注释/*多行注释*/ 3.1.4 严格模式ECMAScript 5 引入了严格模式的概念，要在整个脚本中启用严格模式，在顶部添加：”use strict”;，在函数内部也可以 1234function()&#123; "use strict"; //函数体&#125; 本书将随时指出严格模式下的区别 3.1.5 语句ECMAScript中语句以分号结尾；控制语句等使用{代码块} 3.2 关键字和保留字ECMA-262描述了一组有特定用途的关键字，可以用于表示控制语句的开始或结束，或者用于执行特定操作等。不能用作标识符： break、do、instanceof等 还描述了另外一组不能用作标识符的保留字，暂时无用途 abstract、int、long等 3.3 变量ECMAScript的变量是松散类型的，即可以用来保存任何类型的数据，每个变量仅仅是一个用于保存值的占位符 123var a; //定义变量a=100; //为变量赋值var a = 100; //定义时赋值 使用var操作符定义的变量将成为该变量的作用域中的局部变量 3.4 数据类型ECMAScript有5种简单数据类型（基本数据类型）：Undefined、Null、Boolean、Number和String；和一种复杂数据类型Object：一组无序的键值对。ECMAScript不支持任何创建自定义类型的机制，而所有值最终都将是上述6种数据类型之一 3.4.1 typeof 操作符使用typeof【操作符】（不是函数）可以检测给定变量或值（数值字面量）的数据类型，typeof操作符的操作数可以是变量也可以是数值字面量。返回值： “undefined”——这个值未定义 “boolean”——这个值是布尔值 “string”——这个字是字符串 “number”——这个值是数值 “object”——这个值是对象或null（特殊值null是一个空对象引用） “function”——这个值是函数 【技术角度讲ECMAScript中，函数是对象不是一种数据类型。然而函数也确实有一些特殊的属性，因此通过typeof操作符来区分函数和其他对象是有必要的】 3.4.2 Undefined类型Undefined类型只有一个值，即特殊的undefined。使用var声明变量但未对齐加以初始化时，这个变量的值即undefined 未初始化的变量和未声明的变量通过typeof都会返回undefined，所以显示地初始化变量是明智的选择 3.4.3 Null类型 Null类型是第二个只有一个值的数据类型，这个特殊的值是null。逻辑上它表示一个空对象指针（typeof操作符检测null会返回“object”） 如果定义的变量准备在将来用于保存对象，最好初始化为null 3.4.4 Boolean类型Boolean类型只有两个字面值：true和false。但ECMAScript中所有类型的值都有与这两个值等价的值，要将一个值转化为对应的Boolean值可以调用转型函数Boolean()，转换规则如下： 数据类型 转换为true的值 转换为false的值 Boolean true false String 任何非空字符串 “”(空字符串) Number 任何非零数字值（包括无穷大） 0和NaN Object 任何对象 null Undefined n/a undefined 1234var a = "hello"if (a)&#123; //【控制流语句自动执行Boolean转换】 alert("value is true"); &#125; ps：n/a是not available的缩写，意思是“不适用” 3.4.5 Number类型Number类型使用 IEEE754格式来表示整数和浮点数。ECMAScript定义了不同的数值字面量格式：十进制、八进制（第一位必须是0）、十六进制（第一位必须是0x） 1、浮点数值数值中必须包含小数点，且小数点后必须至少有一位数字。最高精度为17个小数，算数运算时有精度误差 2、数值范围ECMAScript能够表示的最小／大数值存在Number.MIN_VALUE（5e-324）／Number.MAX_VALUE中（1.797693…e+308）。如果某次计算的结果超过了这个范围，数值将被自动转换成特殊的Infinity 值，无法参与下一次的计算 3、NaN NaN，即非数值是一个特殊的数值，用于表示一个本来要返回数值的操作数未返回数值的情况（例除零） NaN有两个特点， 任何涉及到NaN的操作（例NaN／10）都会返回NaN NaN与任何值都不相等 ECMAScript针对这两个特点定义了isNaN()函数，接受任何类型的参数，判断是否“不是数值”。接受到一个值之后会尝试将这个值转换为数值，任何不能转换为数值的值都会导致这个函数返回NaN: 12345alert(isNaN(NaN)) //truealert(isNaN(10)) //false（10是一个数值）alert(isNaN('10')) //false（可以被转换成数值10）alert(isNaN('blue')) //true（不能被转换为数值）alert(isNaN(true)) //false（可以被转换成数值1） 【isNaN()也能用于对象】：首先调用对象的valueof()方法，确定是否可以转换为数值；若不能则基于这个返回值调用toString()方法，再测试返回值 4、数值转换有3个函数可以把非数值转换为数值：Number()、parseInt()、parseFloat()。第一个转型函数Number()可以用于任何数据类型，另外两个专门用于字符串转换成数值。 转换规则： 3.4.6 String类型String类型用于表示零或多个16位 Unicode字符组成的字符序列，即字符串。可由单／双引号表示 1、字符字面量String数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符或其他用途。 字面量 含义 \n 换行 \t 制表 \b 空格 \r 回车 \f 进纸 \\ 斜杠 \’ 单引号 \” 双引号 \xnn 以十六进制代码nn表示的一个字符 \unnn 以十六进制代码nnnn表示的一个Unicode字符 2、字符串的特点ECMAScript中【字符串是不可变的】，字符串一旦创建，它的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，在用另一个包含新值的字符串填充该变量 3、转换为字符串把一个值转换为一个字符串有两种方式，第一种是几乎所有值都有的toString()方法（章5讨论这个方法的特点），这个方法返回相应值的字符串表现。数值、布尔值、对象和字符串值都有这个方法，但null和undefined值没有 在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String()，这个函数能够将任何类型的值转换为字符串 【要把某个值转换为字符串，还可以使用加号操作符把它与一个字符串加在一起（见3.5节）】 3.4.7 Object类型ECMAScript中的对象其实就是一组数据和功能的集合。对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。而创建Object类型的实例并为其添加属性和（或）方法，就可以创建自定义对象 Object的每个实例都具有下列属性和方法： Constructor：保存着用于创建当前对象的函数（构造函数） hasOwnProperty(prorertyName)：检测给定的属性在【当前对象实例】中是否存在（属性名必须以字符串形式传入） isPrototypeOf(object)：用于检查传入的对象是否是另一个对象的原型（章5讨论） propertyIsEnumerable(propertyName)：用于检查是否能够用for-in语句（本章后面会讨论）来枚举 toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应 toString()：返回对象的字符串表示 valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString ()方法的返回值相同 在ECMAScript中Object是所有对象的基础。所有的对象都具有这些基本的属性和方法。章5和章6将详细介绍Objetc与其他对象的关系 3.5 操作符ECMA-262描述了一组用于操作数据值的操作符，包括算数操作符（加号、减号）、位操作符、关系操作符和相等操作符。ECMAScript操作符的与众不同之处在于能够接受很多值，例如字符串、数字值、布尔值、甚至对象。不过在应用与对象时，相应的操作符通常会调用对象的valueof()和（或）toString()方法，以便取得可以操作的值 3.5.1 一元操作符只能操作一个值的操作符 1、递增和递减操作符这四个操作符对任何值都适用，不光整数，还可以用于字符串、布尔值、浮点数值和对象。应用于不同的值时，递增递减操作符遵循下列规则： 2、一元加和减操作符 3.5.2 位操作符对非数值应用位操作符时，会先使用Number()函数将数值转换为一个数值（自动），然后再应用位操作符 1、按位非（NOT）2、按位与（AND）3、按位或（OR）4、按位异或（XOR）5、左移6、有符号的右移7、无符号右移3.5.3 布尔操作符用于测试两个值的关系 1、逻辑非逻辑非操作符（!）首先会把它的操作数转换成一个布尔值，然后对其求反。规则是： 操作数为对象，返回false 空字符串，返回true 非空字符串，返回false 数值0，返回true 任意非0数值（包括Infinity），返回false null／NaN／undefined，返回true 2、逻辑与逻辑与操作符（&amp;&amp;）有两个操作数，对布尔值的真值表： 第一个操作数 第二个操作数 结果 true true true true false false false true false false false false 还可用于其他任何类型的操作书。有一个操作数不是布尔值的情况下，不一定返回布尔值，规则是： 第一个操作数是对象，返回第二个操作数 第二个操作数是对象，只在第一个操作数求值结果为true的情况下返回该对象 两个操作数都是对象，返回第二个操作数 有一个是null／NaN／undefined，返回null／NaN／undefined 逻辑与是一个【短路操作符】，第一个操作数为false直接返回false 3、逻辑或逻辑或操作符（||）有两个操作数，对布尔值的真值表： 第一个操作数 第二个操作数 结果 true true true true false true false true true false false false 与逻辑与相似，有一个操作数不是布尔值的情况下，不一定返回布尔值，规则是： 第一个操作数是对象，返回第一个操作数 第一个操作数求值结果为false，返回第二个操作数 两个操作数都是对象，返回第一个操作数 有一个是null／NaN／undefined，返回null／NaN／undefined 逻辑与是一个【短路操作符】，第一个操作数为true直接返回true 可以利用逻辑或的这一行为来避免为变量赋null或undefined值。如 1var myObeject = preferredObject || backupObject 3.5.4 乘性操作符 P47ECMAScript定义了三个乘性操作符：乘法（*）、除法（／）和求模（%）。操作数在非数值的轻快小会执行自动的类型转换（Number()转型函数） 3.5.5 加性操作符加法（+）和减法（-） 3.5.6 关系操作符小于（&lt;）、大于（&gt;）、小于等于（&lt;=）、大于等于（&gt;=） 3.5.7 相等操作符1、相等和不相等== 和!= ：先转换再比较 2、全等和不全等=== 和 ！== : 仅比较不转换 3.5.8 条件操作符123variable = boolean_expression ? true_value : false_value;var max = (num1 &gt; num2) ? num1 : num2; 3.5.9 赋值操作符=表示赋值操作符，在其前加算术操作符可以完成复合复制操作符 3.5.10 逗号操作符在一条语句中执行多个操作 3.6 语句ECMA-262规定了一组语句（也称为流控制语句），定义了ECMAScript的主要语法。语句通常使用一个或多个关键字来完成给定任务 3.6.1 if语句12345if (condition) &#123; //自动调用Boolean()函数转换condition statement1 //转换为true时执行&#125; else &#123; statement2 //false时执行&#125; 3.6.2 do-while语句一种后测试循环语句 123do &#123; statement //至少执行一次，才测试出口条件&#125; while (expression) 3.6.3 while语句属于前测试循环语句， 123while (expression) &#123; //先测试出口条件 statement. //可能永远不会执行&#125; 3.6.4 for语句也是一种前测试循环语句，且具有在执行循环之前初始化变量和定义循环后要执行的代码的能力 123for (initialization; expression; post-loop-expression)&#123; statement&#125; 以上代码与在循环初始化表达式中声明变量的效果是一样的。由于【ECMAScript（ES5）中不存在块级作用域】，因此在循环内部定义的变量也可以在外部访问（第四章进一步讨论） 3.6.5 for-in语句for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。【顺序不定】 123for (var property in expression)&#123; statement &#125; 迭代对象的值是null或者undefined时，会停止循环，建议使用for-in循环前，先检测值 3.6.6 label语句使用label语句可以在代码中添加标签，以便将来使用 123456label: statement//示例：start: for (var i = 0; i &lt; count; i++)&#123; alert(i)&#125; //start标签可以在将来由break或continue语句引用。 加标签的语句一般都要与for语句等循环语句配合使用（类似c的goto，不建议使用） 3.6.7 break和continue语句break、continue语句用于在循环中精确地控制代码的执行 1234567891011121314151617var num = 0;for (var i = 0; i &lt; 10; i++) &#123; if (i % 5)&#123; break; &#125; num++;&#125;alert(num) //4var num = 0;for (var i = 0; i &lt; 10; i++) &#123; if (i % 5 == 0)&#123; continue; &#125; num++;&#125;alert(num) //8,i为5时少递增一次 3.6.8 with语句with语句的作用是将代码的作用域设置到一个特定的对象中 123456789101112131415with (expression) &#123; statement&#125;//示例：with (location) &#123; var qs = search.substring(1); var hostName = hostname; var url = href;&#125;//等同于var qs = location.search.substring(1);var hostName = location.hostname;var url = location.href; 大量使用with语句会导致性能下降，不建议大型应用使用 3.6.9 switch语句swith语句与if语句关系密切，也是其他语言中普遍使用的一种流控制语句 123456789switch (expression) &#123; case value: statement break; case value: statement break; case value: statement break; default: statement&#125; 【switch语句在比较值时使用的是全等操作符，因此不会发生类型转换】 3.7 函数ECMAScript中函数使用function关键字来声明，后跟一组参数以及函数体 123456789101112//语法function functionName(arg0,arg1,...,argN)&#123; statements&#125;//示例function sayHi(name,message)&#123; alert("hello"+ name + "," + message);&#125;//调用sayHi("Nicholas","how are you?"); ECMAScript中函数在定义时不必指定是否返回值。实际上，任何函数在任何时候都可以通过return语句后跟要返回的值（可以不跟，返回undefined）来实现返回值。return语句后的代码永远不会执行 【推荐的做法是要么让函数始终都返回一个值，要么永远都不要返回值】 3.7.1 理解参数ECMAScript函数的参数与其他语言有所不同。ECMAScript函数不介意传进来多少个参数，也不在乎传进来的参数是什么数据类型。原因是ECMAScript参数在内部通过arguments对象访问参数值，从而获取到传递给函数的每一个参数 123function sayHi()&#123; alert(&quot;hello&quot; + arguments[0] + arguments[1]);&#125; 命名的参数只提供便利，不是必须； 【ECMAScrpt中所有参数传递的都是值，不可能通过引用传递参数】 3.7.2 没有重载因为ECMAScript函数没有签名（接受的参数数量和类型），所以ECMAScript函数不能像传统意义上那样实现重载。在ECMAScript定义了两个名字相同的函数，则改名字只属于后定义的函数 通过检测函数中传入参数的类型（typeof arguments[n]）和数量（arguments.length）并作出不同的反应，可以模拟方法的重载 3.8 小结JavaScript的核心语言特性在ECMAScript-262中是以名为ECMAScript的微语言的形式来定义的。ECMAScript中包含了所有基本的语言、操作符、数据类型以及完成基本计算任务所必需的对象，但没有取得对输入和产生输出的机制作出规定（对宿主环境没有要求：如浏览器）。理解ECMAScript及其纷繁复杂的各种细节，是理解其在Web浏览器中的实现——JavaScript的关键。以下简要总结ECMAScript中基本的要素： ECMAScript中的基本数据类型包括Undefined、 Null、Boolean、Number、String 与其他语言不同，ECMAScript没有为整数和浮点数定义不同的数据类型， Number类型可以用于表示所有数值 ECMAScript中也有一种复杂的数据类型，即Object类型，这类型是这门语言中所有对象的基础类型 严格模式为这么语言中容易出错的地方施加了限制 ECMAScript提供了很多与C及其他类C语言中相同的基本操作符，包括算术操作符、布尔操作符、关系操作符、相等操作符及赋值操作符等 ECMAScript从其他语言中借鉴了很多流控制语句。 ECMAScript中的函数与其他语言中的函数有诸多不同之处： 无须指定函数的返回值，因为任何ECMAScript函数可以在任何时候返回任何值 实际上，未指定返回值的函数返回的是一个特殊的undefined值 ECMAScript中也没有函数签名的概念，因为函数参数是一个包含零或多个值的数组（类数组的对象）的形式传递的 可以向ECMAScript函数传递任意数量的参数，并且可以通过arguments对象访问这些参数 由于不存在函数签名的特性，ECMAScript函数不能重载]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】函数表达式]]></title>
    <url>%2F2018%2F08%2F25%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%20%2F</url>
    <content type="text"><![CDATA[本章内容： 函数表达式的特征 使用函数实现递归 使用闭包定义私有变量 函数表达式是JavaScript中一个既强大又容易令人困惑的特性。第五章层介绍过，定义函数的方式有两种：一种是函数声明，另一种就是函数表达式。 函数声明的语法： 123function functionName(arg0,arg1,arg2)&#123; //函数体&#125; 函数声明有一个重要特征是函数声明提升，执行代码会先读取函数声明，意味着可以把函数声明放在调用它的语句后面： 1234sayHi();function sayHi()&#123; alert("Hi!"); //正确&#125; 第二种创建函数的方式是使用函数表达式： 123var functionName = function(arg0,arg1,arg2)&#123; //函数体&#125; 这种形式看起来就像常规的变量赋值语句，即创建一个函数并将它赋值给变量functionName。这种情况下创建的函数叫匿名函数，因为function关键字后面没有标识符。函数表达式和其他表达式一样，在使用前必须先赋值 1234sayHi(); //错误：函数还不存在var sayHi = function ()&#123; alert("Hi!"); &#125; 7.1 递归递归函数是在一个函数通过名字调用自身的情况下构成的： arguments.callee是一个指向正在执行函数的指针，因此可以用它来实现对函数的递归调用（避免通过函数名调用时，函数名改变引起的错误）： 严格模式下，arguments.callee不能访问，可以利用命名函数表达式： 7.2 闭包闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。 内部函数的作用域链中包含外部函数的作用域，要彻底搞清细节，必须从理解函数第一次被调用的时候发生了什么入手：章4介绍了作用域链的概念，作用域链如何创建以及作用：当某个函数第一次被调用时，会创建一个执行环境(excution context)及相应的作用域链，并把作用域链赋值给一个特殊的内部属性（即[[scope]]）。然后，使用this、arguments和其他命名参数的值来初始化函数的活动对象(activation object)。但在作用域链中，外部函数的活动对象始终处在第二位，外部函数的外部函数的活动对象处在第三位…，直至作为作用域链终点的全局执行环境。在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。p179 无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是闭包情况又有所不同： 7.2.1 闭包与变量作用域链的这种配置机制引出一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。闭包保存的是整个变量对象，而不是某个特殊的变量： 1234567891011function createFunctions()&#123; var result = new Array(); for (var i = 0; i &lt; 10; i++)&#123; result[i] = funtion()&#123; return i; &#125;; &#125; return result; //[10,10,10,10,10...]&#125; 出现上面这种情况的原因时每个函数的作用域链中都保存着createFunctions()函数的活动对象，所以它们引用的都是同一个变量i。当createFunctions()函数返回后，变量i的值是10，此时每个函数都引用着保存变量i的同一个变量对象，所以在每个函数内部i的值都是10。但是我们可以通过创建另一个匿名函数强制让闭包的行为符合预期： 1234567891011function createFunctions()&#123; var result = new Array(); for (var i = 0; i &lt; 10; i++)&#123; result[i] = funtion(num)&#123; return num; &#125;; &#125;(i); //利用命名函数表达式立即执行 return result; //[0,1,2,3,4...9]&#125; 7.2.2 关于this对象在闭包中使用this对象也会导致一些问题。我们知道，this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。不过，匿名函数的执行环境具有全局性，因此其this对象通常指向window（当然，通过call()和apply()改变函数执行环境的情况下，this就会指向其他对象）： 123456789101112var name = 'The Window';var object = &#123; name : 'My Object', getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); //'The Window' 前面提到过，每个函数在被调用时，其活动对象都会自动取得两个特殊变量：this、arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中 的这两个对象。不过，把外部作用域中的this对象保存在一个闭包能访问到的变量里，就可以让闭包访问该对象了： 12345678910111213var name = 'The Window';var object = &#123; name : 'My Object', getNameFunc : function()&#123; var that = this; //that引用着object return function()&#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); //'My Object' 【arguments和this存在着同样的问题。如果想访问作用域中的arguments对象，必须将对该对象的引用保存到另一个闭包能访问到的变量中】 在几种特殊情况下，this的值可能会意外地改变。下面的代码修改前面的例子，这里的getName()方法只是简单地返回this.name的值： 123456789101112var name = 'The Window';var object = &#123; name : 'My Object', getName : function()&#123; return this.name; &#125;&#125;;object.getName(); //'My Object'(object.getName)(); //'My Object'(object.getName = object.getName)(); //'The Window' 7.2.3 内存泄漏IE9对不同对象使用不同的垃圾回收例程，因此闭包的作用域链中保存着一个HTML元素，就意味着该元素将无法被销毁： 利用变量存储DOM引用可以消除循环引用 7.3 模仿块级作用域如前所述，JavaScript没有块级作用域的概念。这意味着在块语句中定义的变量，实际上是在包含函数中而非语句中创建的： 123456function outputNumbers(count)&#123; for (var i=0; i &lt; count; i++)&#123; alert(i); &#125; alert(i); //计数，可以访问变量i&#125; 匿名函数可以用来模仿块级作用域并避免多次声明同一个变量的问题。用作块级作用域（通常称为私有作用域）的匿名函数语法如下： 123(function()&#123; //这里是块级作用域&#125;)(); 以上代码定义并立即调用了一个匿名函数。将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式，而紧随其后的另一对圆括号会立即调用这个函数，通过例子理解： 123456789var count = 5; //赋值语句aoutputNumbers(count); //和下一句等价outputNumbers(5); //传入实际的值代替变量//对照var someFunction = function() &#123; //赋值语句b //这里是块级作用域&#125;;someFunction(); //定义一个函数，立即执行它 既然赋值语句a中的值5可以代替变量count，那么赋值语句b中的值（匿名函数）也可以取代变量someFunction：（但因JavaScript将function关键字当作一个函数声明的开始，而函数声明后面不能跟圆括号，但函数表达式后面可以，所以要将函数声明转换成函数表达式 ）a是错误的，b是正确的 1234567function()&#123; //a //这里是块级作用域&#125;(); //出错！(function()&#123; //b //这里是块级作用域&#125;)(); //正确 无论在什么地方，只要临时需要一些变量，就可以使用私有作用域： 123456789function outputNumbers(count)&#123; (function()&#123; for (var i=0; i &lt; count; i++)&#123; alert(i); &#125; &#125;)(); //私有作用域中的变量执行结束即销毁 alert(i); //导致一个错误！&#125; 这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数（过多的全局变量和函数容易导致命名冲突） 【这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用，只要函数执行完毕，就可以立即销毁其作用域链了】 7.4 私有变量JavaScript没有私有成员的概念；所有对象属性都是公有的。不过，倒是有一个私有变量的概念。任何在函数内部定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其他函数： 1234function add(num1,num2)&#123; var sum = num1 + num2; return sum;&#125; num1、num2和sum就是函数内部的私有变量。如果在函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访问这些变量。利用这一点，就可以创建用于访问私有变量的公有方法，称为特权方法(privileged method)。有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法： 12345678910111213function MyObject()&#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; //特权方法 this.publicMethod = function ()&#123; privateVariable++; return privateFunction(); &#125;&#125; 在创建MyObject的实例后，除了使用publicFunction()这一个途径外，没有任何办法可以直接访问privateVariable和privateFunction()。利用私有和特权成员，可以隐藏那些不该直接修改的数据。 利用在构造函数中定义特权方法的缺点在章6也有提过，它针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法就可以避免这个问题 7.4.1 静态私有变量通过在私有作用域中定义私有变量和函数，同样也可以创建特权方法： 1234567891011121314151617(function()&#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; //构造函数 MyObject = function()&#123;&#125;; //公有／特权方法 MyObject.prototype.publicMethod = function()&#123; privateVariable++; return privateFunction(); &#125;; &#125;)() 这个模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法 7.4.2 模块模式7.4.3 增强的模块模式7.5 小结在JavaScript编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无需对函数命名，从而实现动态编程。匿名函数，也称为拉姆达函数，是一种使用JavaScript函数的强大方式。以下总结了函数表达式的特点： 函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫匿名函数。 在无法确定如何引入函数的情况下，递归函数就会变得比较复杂； 递归函数应该始终使用arguments.callee来递归地调用自身，不要使用函数名——函数名可能会发生变化。 当在函数内部定义了其他函数时，就建立了闭包。闭包有权访问包含函数内部的所有变量，原理如下： 在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域。 通常，函数的作用域及其所有变量都会在函数执行后被销毁 但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。 使用闭包可以在JavaScript中模仿块级作用域（JavaScript本身没有块级作用域的概念），要点如下： 创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。 结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外部作用域的变量）。 闭包还可以用在对象中创建私有变量，相关概念和要点如下： 即使JavaScript中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量。 有权访问私有变量的公有方法叫特权方法。 可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强的模块模式来实现单例的特权方法。 JavaScript中的函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过，因为创建闭包必须维护额外的作用域，所有过度使用它们可能会占用大量内存。]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】引用类型]]></title>
    <url>%2F2018%2F08%2F25%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[本章内容： 使用对象 创建并操作数组 理解基本的JavaScript类型 使用基本类型和基本包装类型 引用类型的值（对象）是引用类型的一个实例。在ECMAScript中，引用数类型是一种数据结构，用于将数据和功能组织在一起。有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。 如前所述，对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的。构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。 5.1 Object类型创建Object实例的方式有两种，第一种就是上面new操作符后跟object构造函数；另一种是使用对象字面量表示法： 1234var person = &#123; name : "jack", age = 29 //属性名会自动转换为字符串 如“age”&#125;; 【对象字面量是向函数传递大量可选参数的首选方式。最好的做法是对那些必须值使用命名参数，而使用字面量来封装多个可选参数】 12345678910111213141516171819function displayInfo(args) &#123; var output = ""; if (typeof args.name == 'string')&#123; ooutput += 'name:' + args.name + '\n'; &#125; if (typeof args.age == 'number')&#123; ooutput += 'age:' + args.age + '\n'; &#125; alert(output);&#125;displayInfo(&#123; name: 'Nicholas', age: 29&#125;);displayInfo(&#123; name: 'Greg'&#125;) 访问对象属性可以用点表示法也可以用方括号表示法： 12345alert(person.name);alert(person["name"]); //优势是可以通过变量来访问属性var propertyName = "name"; alert(person[propertyName]); 除非属性名中有导致语法错误的字符或空格只有使用方括号可以访问，一般建议使用点表示法 5.2 Array类型Array类型与其他语数组不同之处在于，ECMAScript数组的每一项可以保存任何列别的数据。创建数组的基本方式有两种，第一种是使用Array构造函数: new可省略 123var colors = new Array();var colors = new Array(20); //可以预先传入项数，自动变为length值var colors = new Array("red","blue","green"); 第二种基本方式是使用数组字面量： 12var colors = [];var colors = ["red","blue","green"]; 数组的项数十种保存在其length属性中，这个属性始终返回0或更大的值 5.2.1 检测数组对于一个网页或者一个全局作用域而言，使用instanceof操作符就能确定某个对象是不是数组。但网页中包含多个框架（全局环境不单一），就会存在两个以上不同版本的Array构造函数，此时可以用Array.isArray()方法 1234567if (value instanceof Array) &#123; //dosomething&#125;if (Array.isArray(value)) &#123; //dosomething&#125; 5.2.2 转换方法之前说到，所有对象都具有toLocaleString()、toString()和valueof()方法。调用数组的toString()和valueof()方法会返回相同的值，即由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。实际上，为了创建这个字符串会调用数组每一项的toString()方法 1234var colors = ["red","blue","green"];alert(colors.toString()); //red,blue,greenalert(colors.valueof()); //red,blue,greenalert(colors); //red,blue,green alert函数接受字符串参数，后台调用toString()方法，因此会得到与直接调用toString()方法相同的结果 toLocaleString()稍有不同的地方是，调用的是每一项的toLocaleString()方法而不是toString() 5.2.3 栈方法ECMAScript数组也提供了一种让数组行为类似于其他数据结构的方法。可以表现得像栈一样。 push()、pop()都是数组的默认方法 5.2.4 队列方法push()、shift() 正向 pop()、unshift()反向 5.2.5 重排序方法reverse()、sort()（会调用每个数组项的toString()方法，然后比较【字符串】不是数值！！！不过sort函数可以传入【比较函数】），这两个方法返回的是【经过排序后的数组】 12var values = [0,1,5,10,15];alert(values.sort()); //0,1,10,15,5 因为比较的是字符串 比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个参数之后则返回一个正数:一个适用大多数数据类型的比较函数（升序） 12345678910111213function compare(value1,value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125;else &#123; return 0; &#125;&#125;var values = [0,15,5,10,1];values.sort(compare); //关键alert(values); //0,1,5,10,15 对于数值类型或其valueof()方法会返回数值类型的对象类型，可以用一个更简单的比较函数： 123function compare(value1,value2)&#123; return value2-value1;&#125; 5.2.6 操作方法concat()：基于当前数组中的所有项创建一个新数组。先创建一个当前数据的副本，再将参数添加到结果数组的末尾，原数组不变 slice()：基于当前数组中的一个或多个项创建一个新数组。接受参数为返回项的位置，原数组不变 splice()：基本是最强大的数组方法了，主要用途是向数组的中部插入项，该方法适中都会返回一个数组，包含从原数组中删除的项（没删除就返回空）。使用方式有： 删除：删除任意数量的项splice(起始项，项数) 插入：向指定位置插入任意数量的项splice(起始位置，0（要删除的项数），要插入的项) 替换：向指定位置插入任意数量的项，同时删除任意数量的项splice(起始位置，要删除的项数，要插入的项) 5.2.7 位置方法比较时使用全等操作符 indexOf(要查找的项，查找起点（可选）) ：从头开始 lastIndexOf(要查找的项，查找起点（可选）)：从尾开始 5.2.7迭代方法ECMAScript为数组定义了5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this的值。传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置、和数组对象本身。根据使用方法不同，这个函数执行后的返回值可能会也可能不会影响访问的返回值 every()：对数组中的每一项运行给定函数，如果该函数每一项都返回true，则返回true filter()：对数组中的每一项运行给定函数，返回该函数返回true的项组成的数组 forEach()：对数组中的每一项运行给定函数。这个方法没有返回值 map()：对数组中的每一项运行给定函数，返回每次函数调用结果组成的数组 some()：对数组中的每一项运行给定函数，如果该函数任一项返回true，则返回true 12345678910111213141516171819202122232425var numbers = [1,2,3,4,5,4,3,2,1]var everyResult = numbers.every(function(item,index,array)&#123; return (item &gt; 2);&#125;);alert(everyResult); //false-------------------------------------------------------------var filterResult = numbers.filter(function(item,index,array)&#123; return (item &gt; 2);&#125;);alert(filterResult); //[3,4,5,4,3]-------------------------------------------------------------var mapResult = numbers.filter(function(item,index,array)&#123; return item * 2;&#125;);alert(mapResult); //[2,4,6,8,10,8,6,4,2]-------------------------------------------------------------var forEachResult = numbers.forEach(function(item,index,array)&#123; //dosomething&#125;);-------------------------------------------------------------var someResult = numbers.some(function(item,index,array)&#123; return (item &gt; 2);&#125;);alert(someResult); //true 这些方法返回的数组的每一项都是在原始数组中对应项上运行传入函数的结果。 5.2.8 缩小方法ECMAScript为数组定义了2个缩小数组的方法：reduce()和reduceRight()。这两个方法都会迭代数组所有的项，然后构建一个最终返回的值。其中reduce()方法从数组第一项开始，reduceRight()从最后一项。 每个方法都接收两个参数：要在每一项上运行的函数和（可选的）作为缩小基础的初始值。传入这些方法中的函数会接收四个参数：前一个值、当前值、项的索引和数组对象本身。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。 reduce() reduceRight() 123456//示例 利用reduce()方法求数组中所有值之和var values = [1,2,3,4,5];var sum = values.reduce(function(prev,cur,index,array)&#123; return prev + cur;&#125;)alert(sum); //15 5.3 Data类型ECMAScript中的Date类型使用自UTC 1970年1月1日午夜（零时）开始经过的毫秒数来保存日期。要创建一个日期对象，使用new操作符合Date构造函数即可 1var now = new Date(); PS:格林尼治标准时间（GMT，旧译“格林威治平均时间”或“格林威治标准时间”）是指位于伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。 协调世界时(UTC) 英文：Coordinated Universal Time ，别称：世界统一时间，世界标准时间国际协调时间， 协调世界时，又称世界统一时间，世界标准时间，国际协调时间，简称UTC。它从英文“Coordinated Universal Time”／法文“Temps Universel Cordonné”而来。 5.3.1 继承的方法与其他引用类型一样，Date类型也重写了toLocaleString()、toString()、valueOf()方法。toLocaleString()按照与浏览器设置的地区响应的格式返回日期时间但不带时区信息；toLocaleString()按照与浏览器设置的地区响应的格式返回日期时间带时区信息；valueOf()则是返回日期的毫秒表示 5.3.2 日期格式方法Date类型还有一些专门用于将日期格式化为字符串的方法： toDateString()——以特定于实现的格式显示星期几、月、日、年 toTimeString()——以特定于实现的格式显示时、分、秒和时区 toLocaleDateString()——以特定于地区的格式显示星期几、月、日、年 toLocaleTimeString()——以特定于地区的格式显示时、分、秒和时区 toUTCString()——以特定于实现的格式显示完整的UTC日期 5.3.3 日期／时间组件方法 p1025.4 RegExp类型ECMAScript通过RegExp类型来支持正则表达式 1var expression = / pattern / flags ; 其中的模式（pattern）部分可以式任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一个或多个标志（flags），用以标明正则表达式的行为。正则表达式的匹配模式支持下列3个标志： g：表示全局模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止； i：表示不区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写 m：表示多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项 12345var pattern1 = /at/g; //匹配字符串中所有“at”的实例var pattern2 = /[bc]at/i; //匹配第一个“bat”或“cat”，不区分大小写var pattern3 = /.at/gi; //匹配所有以“at”结尾的3个字符的组合，不区分大小写var pattern4 = new RegExp ("[bc]at","i"); //等同于pattern2 5.4.1 RegExp实例属性5.4.2 RegExp实例方法5.4.3 RegExp构造函数属性5.4.4 模式的局限性5.5 Function类型ECMAScript函数实际上是对象，每个函数都是Function类型的实例，都和其他引用类型一样具有属性和方法，函数名实际上是一个指向函数对象的指针，不会与某个对象绑定。函数通常是使用函数声明语法定义的： 1234567891011function sum(num1,num2)&#123; return num1 + num2;&#125;//与上述相等var sum = function(num1,num2)&#123; return num1 + num2;&#125;;//使用Function构造函数，不推荐，因为会解析两次var sum = new Function('num1','num2','return num1 + num2'); 5.5.1 没有重载（深入理解）将函数名想象为指针，也有助于理解为什么ECMAScript中没有函数重载 5.5.2 函数声明与函数表达式解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码前可用；而函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行： 123456789alert(sum(10,10)); //可以正常运行function sum(num1,num2)&#123; return num1 + num2;&#125;alert(sum(10,10)); //不可以正常运行var sum = function(num1,num2)&#123; return num1 + num2;&#125; 除了什么时候可以通过变量访问函数这一点区别之外，函数声明和函数表达式其实是等价的 5.5.3 作为值的函数ECMAScript中函数名本身就是变量，所有函数也可以作为值来使用。不仅可以像传递参数一样把一个函数传递给另一个函数，还可以把一个函数作为另一个函数的结果返回 123function callSomeFunction(someFunction,someArgument)&#123; return someFunction(someArgument);&#125; 【要访问函数指针而不执行函数的话，必须去掉函数名后面的圆括号】 5.5.4 函数内部属性函数内部有两个特殊对象：argument和this argument在章3介绍过，是一个类数组对象，包含着传入函数中的所有参数。它还有一个名叫callee的属性，该属性是一个指针，指向拥有这个argument对象的函数。this引用的是函数据以执行的环境对象。函数对象另一个属性caller，保存着调用当前函数的函数的引用 123456789function outer() &#123; inner();&#125;function inner() &#123; alert(inner.caller); //同alert(argumengt.callee.caller); &#125;outer(); //警告框中显示outer()函数的源代码，因为inner.caller指向它 5.5.5 函数属性和方法ECMAScript的函数是对象，因此函数也有属性和方法 每个函数包含两个属性：length和prototype。其中length属性表示函数希望接受的命名参数个数。prototype保存所有实例方法（toString()、valueof()等），但它不可枚举 每个函数都包含两个非继承的方法：apply()和call()。用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。ECMAScript 5 还定义了一个方法bind()，这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值： 12345678window.color = "red";var o = &#123; color = "blue" &#125;;function sayColor()&#123; alert(this.color);&#125;var objectSayColor = sayColor.bind(o);objectSayColor(); //blue apply、call、bind 三者相比较，之间又有什么异同呢？何时使用 apply、call，何时使用 bind 呢。简单的一个例子： 123456789101112var obj = &#123; x: 81,&#125;; var foo = &#123; getX: function() &#123; return this.x; &#125;&#125;console.log(foo.getX.bind(obj)()); //81 注意这里还加了一个括号console.log(foo.getX.call(obj)); //81console.log(foo.getX.apply(obj)); //81 5.6 基本包装类型为了便于操作基本类型值，ECMAScript还提供了3个特殊的引用类型：Boolean、Number和String。这些类型与本章介绍的其他引用类型相似，但同时也具有各自的基本类型相应的特殊行为。实际上，每当读区一个基本类型值的时候后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据 12var s1 = "some text";var s2 = s1.substring(2); 基本类型值不是对象，从逻辑上不应有方法，但后台会自动如下处理： 创建一个String类型的实例 在实例上调用指定的方法 销毁实例 所以以上代码可以想象是执行了下列ECMAScript代码： 123var s1 = new String("some text");var s2 = s1.substring(2);s1 = null; 引用类型和基本包装类型的主要区别就是对象的生存期。 不建议显示创建基本包装类型的对象，尽管它们操作基本类型值的能力还是相当重要的，而每个基本包装类型都提供了操作相应值的便捷方法 5.6.1 Boolean类型 Boolean类型的实例重写了valueOf()和 toString() 5.6.2 Number类型Number类型的实例重写了valueOf()和 toString()、toLocaleString() 除了基础的方法以外，Number类型还提供了一些用于数值格式化为字符串的方法toFixed()、toExponential()和toPrecision() 12 5.6.3 String类型String类型继承的valueOf()和 toString()、toLocaleString()方法都返回对象所表示的基本字符串值。String类型的每个实例都有一个length属性，表示字符串中包含多个字符 1、字符方法 charAt() charCodeAt() 2、字符串操作方法 concat() slice() substr() substring() 3、字符串位置方法 indexOf() lastIndexOf() 4、trim方法 5、字符串大小写转换方法 toLowerCase() toLocaleLowerCase() toUpperCase() toLocaleUpperCase() 6、字符串的模式匹配方法 match() search() replace() split() 7、localeCampare()方法 8、fromCharCode()方法 9、HTML方法 5.7 单体内置对象ECMA-262对内置对象的定义是：“由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行前就已经存在了”。开发人员不用显式的实例话内置对象，如Object、Array、String等。ECMA-262还定义了两个单体内置对象：Global和Math 5.7.1 Global对象1、URI编码方法 2、eval()方法 3、 Global对象的属性 4、window对象 【JavaScript中的window对象除了扮演ECMAScript规定的Global对象的角色外，还承担了很多别的任务，第八章详细介绍window对象】 5.7.2 Math对象1、Math对象的属性 2、min()和max()方法 3、舍入方法 ceil() floor() round() 4、random()方法 5、其他方法 5.8 小结对象在JavaScript中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象，现简要总结如下： 引用类型与传统面向对象程序设计中的类相似，但实现不同； Object是一个基础类型，其他所有类型都从Object继承了基本的行为； Array类型是一组值的有序列表，同时还提供了操作和转换这些值的功能； Date类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能； RegExp类型是ECMAScript支持正则表达式的一个接口，提供了最基本的河一些高级的正则表达式功能。 函数实际上是Function类型的实例，因此函数也是对象；而这一点正是JavaScript最有特色的地方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。 因为有了基本包装类型，所有JavaScript中的基本类型值可以被当作对象来访问。三种基本包装类型分别是：Boolean、Number和String。以下是它们的共同特征： 每个包装类型都映射到同名的基本类型； 在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据操作； 操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象。 在所有代码执行之前，作用域中就已经存在两个内置对象：Global和Math。在大多数ECMAScript实现中都不能直接访问Global对象；不过Web浏览器实现了承担该角色的window对象。全局变量和函数都是Global对象的属性。Math对象提供了很多属性和方法，用于辅助完成复杂的数学计算任务]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JavaScript权威指南】在HTML中使用JavaScript]]></title>
    <url>%2F2018%2F08%2F25%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8JavaScript%2F</url>
    <content type="text"><![CDATA[本章内容： 使用script元素 嵌入脚本与外部脚本 文档模式对JavaScript的影响 考虑禁用JavaScript的场景 2.1 script元素向 HTML页面中插入 JavaScript的主要方法是使用script元素。HTML4.01为其定义了下列属性 async：可选。表示立即下载脚本但不影响页面中的其他操作 chareset：可选。通过chareset属性指定代码的字符集 defer：可选。脚本可以延迟到文档被完全解析和显示之后再执行 language：已放弃。原用于表示编写代码使用的脚本语言 src：可选。表示包含要执行代码的外部文件 type：可选。可看作language的替代属性；表示编写代码使用的脚本语言的内容内行（MIME类型） 使用script有两种方式：直接在页面中嵌入JavaScript代码和包含外部JavaScript文件。【注意，带有src属性的script元素在其标签之间包含的额外的JavaScript代码会被忽略】 无论如何包含代码，只要不存在defer和async属性，浏览器都会按照元素在页面中出现的先后顺序对它们依次进行解析，然后才是第三个、第四个… 2.1.1 标签的位置一般应当将全部JavaScript放置在 元素中，页面的内容后面 2.1.2 延迟脚本HTML4.01定义了在script元素中设置defer属性【只用于外部脚本文件】。HTML5规范要求脚本按出现顺序执行，在现实中，延迟脚本不一定按照顺序执行，也不一定会在 DomcontentLoaded事件（章13）触发前执行，因此最好只包含一个延迟脚本 【立即下载，延迟执行（页面加载完毕）】 2.1.3 异步脚本HTML5定义了在script元素中设置async属性【只用于外部脚本文件】。与defer属性类似，都用于改变处理脚本的行为，告诉浏览器立即下载文件。与defer不同不保证按顺序执行【建议异步脚本不要在加载期间修改 DOM】 【立即下载，不影响页面加载】 2.1.4 在XHTML中的用法2.1.5 不推荐使用的语法所有浏览器已经支持JavaScript，不需要将script标签内的内容注释以防止浏览器不支持JavaScript（针对嵌入代码而言） 12345&lt;script&gt;&lt;!-- function sayhi()&#123; alert("hi") &#125; --&gt;&lt;/script&gt; 2.2 嵌入代码与外部文件在HTML中嵌入JavaScript代码虽然没有问题，但一般认为最好的做法还是尽可能使用外部文件来包含JavaScript代码。不过不存在硬性规定，使用外部文件有如下优点： 可维护性 可缓存：两个页面使用同一个JavaScript文件，只下载一次 适应未来：通过外部引用JavaScript无须使用2.15提到的注释hack，因为引用外部文件的语法是相同的 2.3 文档模式文档模式(doctype)：混杂模式、标准模式。通过声明不同文档模式影响浏览器行为：主要影响CSS内容的呈现，一些情况下也影响JavaScript的解释执行。 没有文档声明类型，浏览器默认开启混杂模式。开启标准模式： 1&lt;!DOCTYPE html&gt; //HTML5标准 2.4 noscript元素浏览器不支持或未开启脚本时使用noscript元素，会显示该元素标签内的内容。启用了脚本的浏览器中，这个元素永远不会显示，尽管它是页面的一部分 2.5 小结把JavaScript插入到HTML页面中要使用script元素。使用这个元素可以把JavaScript嵌入到HTML页面中，让脚本和标记混合在一起；也可以包含外部的JavaScript文件，要注意的有： 在包含外部JavaScript文件时，必须将src属性设置为指向相应文件的URI。这个文件既可以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件 所有script元素都会按照它们在页面中出现的先后顺序依次被解析。在不使用defer和async属性的情况下，只有在解析完前面script元素中的代码之后，才会开始解析后面的script元素中的代码 使用defer属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按指定它们的顺序执行 使用async属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行 另外，使用noscript元素可以制定在不支持脚本的浏览器中显示的替代内容。但启用了脚本的情况下，浏览器不会显示noscrpit元素中的任何内容]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F08%2F25%2F%E3%80%90JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91JavaScript%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[本章内容 JavaScript历史回顾 JavaScript是什么 JavaScript与ECMAScript的关系 JavaScript的不同版本 1.1 JavaScript简介“标准化一种通用、跨平台、供应商中立的脚本语言的语法与语义”——ECMAScript，新脚本语言的标准。浏览器开发商致力于将ECMAScript作为各自JavaScript实现的基础 1.2 JavaScript实现一个完整的JavaScript的实现包含三部分： 核心（ECMAScript） 文档对象模型（DOM） 浏览器对象模型（BOM） 1.2.1 ECMAScript由 ECMA-262定义的ECMAScript与web浏览器没有依赖关系。web浏览器只是其实现可能的宿主环境之一，为其提供基本的实现，同时也提供该语言的扩展，以便语言与环境之间对接交互——如DOM ECMA-262标准定义的这门语言的下列组成部分 语法 类型 语句 关键字 保留字 操作符 对象 ECMAScript就是对该标准规定的各个方面内容的语言的描述。 JavaScirpt实现了 ECMAScript，Adobe ActionScript同样也实现了 ECMAScript 1.2.2 文档对象模型（DOM）文档对象模型（DOM, Document Object Model）是针对XML但经过扩展用于HTML的应用程序编程接口（API，Application Programming Interface）。DOM把整个页面映射为一个多层节点结构，通过DOM创建的节点，开发人员获得了控制页面内容和结构的主动权 1、为什么要使用DOM2、DOM级别 DOM1级两个模块：DOM核心（如何映射基于XML的文档结构）和 DOM HTML DOM2级增加了 DOM视图、DOM事件、DOM样式、DOM遍历和范围等模块 DOM3级则进一步扩展了DOM：DOM加载和保存、DOM验证模块 3、其他DOM标准4、Web浏览器对DOM的支持1.2.3 浏览器对象模型（BOM）浏览器支持可以访问和操作浏览器窗口的浏览器对象模型 BOM（Browser Object Model）。开发人员使用 BOM可以控制浏览器显示的页面以外的部分，从根本上讲，BOM只处理浏览器窗口和框架；习惯上把所有针对 JavaScript扩展也算作BOM的一部分： 弹出新浏览器窗口的功能 移动、缩放和关闭浏览器窗口的功能 提供浏览器详细信息的navigator对象 提供浏览器所加载页面详细信息的location对象 提供用户显示器分辨率详细信息的screen对象 对cookie的支持 像XMLHttpRequest和IE的ActiveXOBject这样的自定义对象 1.3 JavaScript版本1.4 小结JavaScript是一种专为与网页交互而设计的脚本语言，由下列三个不同的部分组成： ECMAScript，由ECMA-262定义，提供核心语言功能 文档对象模型（DOM）,提供访问和操作网页内容的方法和接口 浏览器对象模型（BOM）,提供与浏览器交互的方法和接口]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css属性的继承、初识值、计算值、当前值、应用值]]></title>
    <url>%2F2018%2F08%2F22%2Fcss%E5%B1%9E%E6%80%A7%E7%9A%84%E7%BB%A7%E6%89%BF%E3%80%81%E5%88%9D%E8%AF%86%E5%80%BC%E3%80%81%E8%AE%A1%E7%AE%97%E5%80%BC%E3%80%81%E5%BD%93%E5%89%8D%E5%80%BC%E3%80%81%E5%BA%94%E7%94%A8%E5%80%BC%2F</url>
    <content type="text"><![CDATA[参考来自：https://segmentfault.com/a/1190000010953861 css属性我觉得大部分学习前端的人应该都没有按照教科书一般的来学习css，可能是类似搭积木一样，需要什么拿什么，所以可能最对一些基本的概念没有很好的理解，这里列出的是一些css属性的关键概念： css属性初始值 css属性计算值 css属性应用值 css属性当前值 css属性继承 大部分css属性都可以有这个值：inherit 继承父级值 ：initial 初始值，inherit 继承父级值 对于可继承属性而言，直接继承父级的属性，直接父级元素没有设置的话会一级级往上继承，如果都没有就是默认值； 对于非继承属性而已，这个还是要慎用，当然也可以用，可以继承父级元素的属性，但是父级元素可能没有这个属性，所以避免这种情况考虑使用initial初始值比较合理 初始值在 每个CSS属性 定义的概述中已经给出的 初始值 针对不同的 继承或非继承属性 有着不同的含义. 对于继承属性, 初始值 只能 被用于没有指定值的根元素上【因为不是根元素都会继承其他的父元素指定值】. 对于非继承属性 ,初始值可以被用于 任意 没有指定值的元素上. 在CSS3中允许作者使用 initial 关键词明确的设定初始值. 计算值一个CSS属性的 计算值 (computed value) 通过以下方式从指定的值计算而来： 处理特殊的值 inherit 和 initial，以及进行计算，以达到属性摘要中“计算值”行中描述的值。计算属性的”计算值”通常包括将相对值转换成绝对值(如 em 单位或百分比)。 例如，如一个元素的属性值为 font-size:16px 和 padding-top:2em, 则 padding-top 的计算值为 32px (字体大小的2倍). 然而，有些属性的百分比值会转换成百分比的计算值(这些元素的百分比相对于需要布局后才能知道的值，如 width, margin-right, text-indent, 和 top)。另外，line-height 属性值如是没有单位的数字，则该值就是其计算值。这些计算值中的相对值会在 应用值 确定后转换成绝对值。 计算值的最主要用处是 继承 , 包括 inherit 关键字。 getComputedStyle() DOM API 返回的 解析值, 可能是 计算值或 应用值。 应用值CSS 属性的应用值（used value）是完成所有计算后最终使用的值，可以由 window.getComputedStyle 获取。尺寸 (例如 width, line-height) 单位为像素, 简写属性 (例如 background) 与组成属性相符 (例如 background-color，display) 与 position 、float相符，每个 CSS 属性都有值。 详情 计算出CSS属性的最终值有三个步骤。首先，指定值specified value 取自样式层叠 (选取样式表里权重最高的规则), 继承 (如果属性可以继承则取父元素的值)，或者默认值。然后，按规范算出 计算值computed value (例如， span 指定 position: absolute 后display 变为 block)。最后，计算布局(尺寸比如 auto 或 百分数 换算为像素值 )， 结果即 应用值used value。这些步骤是在内部完成的，脚本只能使用 window.getComputedStyle 获得最终的应用值。 举例 没有明确的宽度。指定的宽度: auto (默认). 计算的宽度: auto. 应用的宽度: 998px (举例而言)。明确的宽度: 50%. 指定的宽度: 50%. 计算的宽度: 50%. 应用的宽度: 447px明确的宽度: inherit. 指定的宽度: 50%. 计算的宽度: 50%. 应用的宽度: 221px . 与计算值的区别 CSS 2.0 只定义了 计算值 computed value 作为属性计算的最后一步。 CSS 2.1 引进了定义明显不同的的应用值，这样当父元素的计算值为百分数时子元素可以显式地继承其高宽。 对于不依赖于布局的 CSS 属性 (例如 display, font-size, line-height)计算值与应用值一样，否则就会不一样 (引自 CSS 2.1 Changes: Specified, computed, and actual values): 实际值一个CSS属性的实际值（actual value）是应用值（used value）被应用后的近似值。例如，一个用户代理可能只能渲染一个整数像素值的边框（实际值），并且该值可能被强制近似于边框的计算宽度值。 继承与非继承每个 CSS 属性定义 的概述都指出了这个属性是默认继承的 (“Inherited: Yes”) 还是默认不继承的 (“Inherited: no”)。这决定了当你没有为元素的属性指定值时该如何计算值。 继承当元素的一个 继承属性 （inherited property ）没有指定值时，则取父元素的同属性的 计算值 computed value 。只有文档根元素取该属性的概述中给定的初始值（initial value）（这里的意思应该是在该属性本身的定义中的默认值）。以下是继承的一些属性 azimuth, border-collapse, border-spacing,caption-side, color, cursor, direction, elevation,empty-cells, font-family, font-size, font-style,font-variant, font-weight, font, letter-spacing,line-height, list-style-image, list-style-position,list-style-type, list-style, orphans, pitch-range,pitch, quotes, richness, speak-header, speaknumeral,speak-punctuation, speak, speechrate,stress, text-align, text-indent, texttransform,visibility, voice-family, volume, whitespace,widows, word-spacing 非继承当元素的一个 非继承属性 (在Mozilla code 里有时称之为 reset property ) 没有指定值时，则取属性的 初始值initial value （该值在该属性的概述里被指定）。以下列出均为非继承 display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。 参考：http://www.w3.org/TR/CSS21/pr…https://developer.mozilla.org…http://www.cnphp.info/css-sty…]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为了谢耳朵看的stand by me]]></title>
    <url>%2F2018%2F08%2F21%2F%E4%B8%BA%E4%BA%86%E8%B0%A2%E8%80%B3%E6%9C%B5%E7%9C%8B%E7%9A%84stand-by-me%2F</url>
    <content type="text"><![CDATA[最近有点疯狂，两天之内把延禧攻略刷了60集，一周内刷完孤独的美食家，一周刷完TBBT，人不能闲啊，我小学之后就没看过古装剧了汗。堕落由自在的开学前，就沉浸在电影和电视剧里，然后刚刚看了stand by me ，就是大爆炸里威尔惠顿成名作。以为是个悲剧，因为看之前扫了一眼豆瓣的简介看到尸体，脑内是伊甸湖那种款式的….结果是成长电影，超级单纯的成长电影，嗯。四个12岁小伙伴寻找失踪男孩的故事，一天一夜，平铺直叙，简简单单，没有煽情，男孩们就在那一天长大了。 在青春期荷尔蒙作祟之前，所有人都应该有一段奇妙的模仿成人期，对未来的期盼，对长大的希冀。我那个时候在干嘛呢？12岁，小学最后一年，在校园欺凌里掰着手指盼着升中学，当时的境遇后来经常讲给朋友听，觉得我真是有一万个机会变成不良少女，阴差阳错的混成了别人家的小孩。12岁没有朋友，以后也不会有了，我有两三个，现在也是那两三个。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>影评</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我可能连百円都不值]]></title>
    <url>%2F2018%2F08%2F14%2F%E6%88%91%E5%8F%AF%E8%83%BD%E8%BF%9E%E7%99%BE%E5%86%86%E9%83%BD%E4%B8%8D%E5%80%BC%2F</url>
    <content type="text"><![CDATA[​ 闲来无事把安藤樱参演第一部电影《百元之恋》看了，这个女人好迷人，外貌不好看，甚至算得上难看，把普通人演得动人又真实。32岁无业单身宅女，内向不善交际，宅被骂，打工被同事强奸，被男人甩，这种设定在别的电影里就是为了逆袭而存在（百万美元宝贝等），偏偏到最后，一子仍然是那个大龄无业宅女，不过有一个打拳的小爱好而已。 ​ 生活就是这样一点戏剧化情节都没有。百元之恋还真的以为说的是爱情，一子爱的是竞技后还能互相抱抱的那种温暖，啊，还是想赢一次。 ​ 转念又好羡慕一子，虽然她什么都没有，可能就因为她什么都没有，作为爱好的打拳可以让她早起，让她努力训练，让她想赢。 ​ 大多数人没有那种谈得上坚持了很多年的爱好吧，我自私地希望是这样。进入大学之后觉得设计有意思，加入了学生组织做海报、做ui；觉得摄影有意思，进了一个需要帮人拍照的团体；觉得画画有意思（更正：应该是觉得画画对设计有帮助），就兴致冲冲的买了绘本…这些过往的“爱好”，无一例外地夭折。毕业前夕，还在为研究生到底是读本专业还是设计而恼火，以“一定追不上人家科班生啦”为由，老老实实继续我的计算机。这样看起来真是没恒心没毅力的一个人啊，怪不得羡慕一子。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>影评</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSS权威指南】第十四章学习笔记：非屏幕媒体]]></title>
    <url>%2F2018%2F08%2F12%2F%E3%80%90CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%9D%9E%E5%B1%8F%E5%B9%95%E5%AA%92%E4%BD%93%2F</url>
    <content type="text"><![CDATA[CSS也可以用于非视觉媒体 设计特定于媒体的样式表利用HTML 和CSS中定义的机制，可以将样式表限制为仅用于特定媒体。对于HTML的样式表，可以通过media属性对媒体作出限制： 1234&lt;link media="print" href="css1.css"&gt;&lt;style media="projection, screen"&gt; body &#123;font-family: sans-serif;&#125;&lt;/style&gt; media属性可以接受一个媒体值或多个媒体值。没有为样式表增加媒体信息，它会应用于所有媒体 CSS2还定义了@media块的语法，允许在同一个样式表中为多个媒体定义样式： 123456789&lt;style&gt;body &#123;background: white; color: black;&#125;@media screen &#123; body &#123;font-family: sans-serif;&#125;&#125;@media print &#123; body &#123;font-family: serif;&#125;&#125;&lt;/style&gt; 分页媒体在CSS术语中，分页媒体是把文档表示处理为一系列离散“页面”的媒体（屏幕媒体是一种滚动的连续型媒体），打印资料，如书、幻灯片、杂志和激光打印机输出，都是分页媒体，每张幻灯片在CSS术语中就是一个“页面” 打印样式最常见的分页媒体是文档的打印输出，创作人员可以采取很多措施让用户更喜欢文档的打印输出，如改变分页或是创建专用的打印的样式 注意，打印样式也会应用于“打印预览”模式的文档显示。因此在某些情况下可以在显示器上看到打印样式 屏幕与打印的区别除了明显的物理差异，最基本的差别是字体选择：如屏幕适合字体sans-serif而打印字体serif更合适；字体大小：web不适合用点作为单位打印相反；背景：大多数打印输出都没有背景；等等 定义页面大小类似于定于元素框的方法，CSS定义了描述页面组建的页框。页框基本上由两个区组成： 页面区，这是页面中放内容的部分，类似于正常元素框中的内容区 外边距区，这是围绕页面区的部分 在CSS2中，可以定义页框的大小，还可以定义外边距大小，在CSS2.1中，创作人员只能设置外边距区的大小，均要使用@page规则来完成设置： 12@page &#123;size: 7.5in 10in; margin: 0.5in;&#125; @page &#123;size: landscape;&#125; //旋转90度打印 上述为CSS2规则，因为属性size已经从CSS2.1去除，因为缺乏实现支持 size 值： {1,2} \ auto \ portrait \ landscape \ inherit 初始值： auto 应用于： 页面区 继承值： 无 选择页面类型CSS2允许通过命名@page规则创建不同的页面类型 分页Orphans和widows分页行为重复元素页面外的元素投影样式声音样式小结]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSS权威指南】第十三章学习笔记：用户界面样式]]></title>
    <url>%2F2018%2F08%2F12%2F%E3%80%90CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[CSS的绝大部分都是关于文档的样式，但还是提供了很多有用的界面样式工具，而不仅仅面向文档。类似可以重用用户默认环境的某些方面来设置文档的字体和颜色样式，甚至可以对焦点强调和鼠标光标施加影响 系统字体和颜色有时你希望自己的稳定尽可能的模仿用户的计算环境，看上去像操作系统的一部分。尽管CSS2不允许在自己的文档中重用操作系统外观的任何一个方面，不过有一组丰富的颜色和有限的字体可供选择 系统字体CSS2定义了6个系统字体关键字，分别描述如下 caption 由标题控件使用的字体样式，如按钮和下拉控件 icon 操作系统图标标签所用的字体样式，如硬盘驱动器、文件夹和文件图标 menu 下拉菜单和菜单列表中文本使用的字体样式 message-box 对话框中文本使用的字体样式 small-caption 由标题小空间的标签使用的字体样式 status-bar 窗口状态条中文本使用的字体样式 1a.widget &#123;font: caption;&#125; //一个功能相当于按钮的控件，使之与有标题控件（如按钮）中文本使用同样的字体系列、字体大小、字体加粗、字体风格以及字体变形 【注意】上述值只能用于font属性，且它们本身都是简写了已经（注意样式覆盖） 系统颜色【警告】CSS3颜色模块已经废弃了系统颜色关键字 CSS2定义了28格系统颜色关键字，只要能用值的环境，就可以使用这些值 p403了解 光标用户界面的另一个重要部分是光标（CSS规范中“指示设备”），由鼠标、写字板、图形书写板甚至光学读取系统之类的设备控制。在大多数Web浏览器中，光标对于提供交互反馈很有用，如光标经过一个超链接时会变成一个小手 改变光标CSS2允许改变光标图标，利用cursor属性 cursor 值： [ [,]* [ auto \ default \ pointer \ crosshair \ move \ e-resize \ ne-resize \ nw-resize \ n-resize \ se-resize \ sw-resize \ s-resize \ w-resize \ text \ wait \ help \ progress ] ] \ inherit 初始值： auto 应用于： 所有元素 继承值： 有 计算值： 对于值，为绝对URI；否则，根据指定确定 默认值auto表示用户代理应当确定最适合当前上下文的光标图标，与default不同，后者要求图标是操作系统的默认光标（通常是一个箭头） 指示和选择光标利用cursor可以将任何元素定义为像链接一样改变图标为“小手”、text图标、十字符号等 1a[href] &#123;cursor: pointer;&#125; 移动光标等待和前进提供帮助图形光标轮廓CSS还引入了用户界面样式最后一个主要方面：轮廓。有点类似于边框，不过有两个重要区别：首先轮廓不像边框那样参与到文档了中，因此轮廓出现和消失不会影响文档流；其次轮廓可能不是矩形 设置轮廓样式类似于边框，轮廓最基本的方面就是样式，利用outline-style设置 outline-style 值： none \ dotted \ dashed \ solid \ double \ groove \ ridge \ inset \ outset \ inherit 初始值： none 应用于： 所有元素 继承值： 无 计算值： 根据指定确定 轮廓样式关键字与边框样式关键字基本上相同，视觉效果也类似。另一个区别是，只能为一个outline-style值指定一个关键字（边框可以指定最多四个关键字） 轮廓宽度 outline-width 值： thin \ medium \ thick \ \ inherit 初始值： medium 应用于： 所有元素 继承值： 无 计算值： 绝对长度；如果轮廓样式为none则为0 设置轮廓颜色 outline-color 值： \ invert \ inherit 初始值： invert(或用户代理特定的值；见正文说明) 应用于： 所有元素 继承值： 无 计算值： 根据指定确定 边框和轮廓最有意思的差别：默认值invert。其导致对轮廓“后面”的像素完成反色反转。当然想为轮廓定义一种特定的颜色，只需使用任何合法的颜色值 12345a &#123; outline-color: red; outline-color: #000; outline-color: rgb(50,50,50);&#125; 类似轮廓样式和宽度，对整个轮廓只能定义一种颜色 汇总类似于设置边框样式的border属性，轮廓也有一个简写属性outline，允许一次就完成轮廓样式、宽度和颜色的设置 outline 值： [ \ \ ] \ inherit 初始值： 对简写属性未定义 应用于： 所有元素 继承值： 无 计算值： 见各个属性 小结]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSS权威指南】第十二章学习笔记：列表和生成内容]]></title>
    <url>%2F2018%2F08%2F12%2F%E3%80%90CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%97%E8%A1%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[先讨论基本的列表样式，再讨论内容和计数器的生成]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSS权威指南】第十一章学习笔记：表布局]]></title>
    <url>%2F2018%2F08%2F12%2F%E3%80%90CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%A1%A8%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[并非一直极力避免的“表布局”，本章介绍CSS中表本身如何布局。与文档布局的其他方面比，表很特别，它本身就能够确定其他元素的元素大小，它还有其他一些特殊性规则和行为 本章奖介绍表在视觉上如何组装，另外会介绍绘制单元格边框的两种方法，还将介绍确定表及其内部元素高度和宽度的机制 表格式化与表布局不同，表格式化指组装表的基本方法，表中元素的相互关系。之后再介绍表布局 表的视觉编排表的编排有6个规则。这些规则的基础是“表格单元”。它是理论上的构造，不能为它设置样式，甚至不能通过文档对象模型来访问。这些构造只是用于描述如何组装表 表编排规则： 每个行框包含一行表格单元。表中所有行框按其在源文档中出现的顺序从上到下地填充表。因此有多少个行元素，表中就包含多少个表个行 一个行组包含多少个行框，该行组框就包含多少个表格单元 列框包含一列或者多列表格单元。所有列框按其出现的顺序依次出现的顺序依次相邻放置 列组中包含多少个列框，该列组框中就包含多少个表格单元 尽管单元格可以跨多行或者多列，不过不是CSS来定义而是文档语言来定义跨行或者跨列。每个框行或跨列的单元格是一个矩形框，其宽度或者高度分别是一个或多个单元格。这个矩形框的顶行在作为该单元格父元素的行中 单元格框不能超出表或者行组的最后一个行框。如果表结构可能造成这种情况，单元格则必须缩小，使之能放在包含它的表或行组中 表显示值 display 值： none \ inline \ block \ inline-block \ list-item \ run-in \ tabel \ inline-table \ table-row-group \ table-header-group \ table-footer-group \ table-row \ table-column-group \ table-column \ table-cell \ table-caption \ inherit 初始值： inline 应用于： 所有元素 继承值： 无 计算值： 对于浮动、定位和根元素，计算值可变（章9.7节）；否则，根据指定决定 这一章中，只讨论与表有关的值： table 这个值指定一个元素定义了一个块级表。定义了一个生成块框的矩形块，相应的HTML元素是table inline-table 这个值指定一个元素定义了一个行内级表。定义了一个生成行内框的矩形块，与之最接近的HTML元素是table，不过默认情况下HTML表不是行内元素 table-row 这个值指定一个元素是一个单元格的行，对应HTML元素是tr table-row-group 这个值指定一个元素是一个或多个行的组，对应HTML的值是tbody table-header-group 这个值与table-row-group非常相似，只是格式化方面有所不同，标题行组总是在所有其他行和行组之前显示。标题组可以包含多个行。对应HTML元素是thead table-footer-group 这个值与table-header-group很类似，脚注行组总是在所有其他行和行组之后显示。标题组可以包含多个行。对应HTML元素是tfoot table-column 这个值声明元素描述了一个单元格的列。这个display值并不显示，主要为了帮助定义列中单元格的表示。对应HTML元素是col table-column-group 这个值指定一个元素是一个或多个列的组。类似table-column元素，table-column-group元素也不显示，不过这个值有组有定义组中元素的表示。对应HTML元素是colgroup table-cell 这个值指定一个元素表示表中的单个单元格。 HTML元素th和td都属于table-cell元素 table-caption 这个值定义一个表的总标题 HTML4.0中表值的一般效果总结： 123456789table &#123;display: table;&#125;tr &#123;display: table-row;&#125;thead &#123;display: table-header-group;&#125;tbody &#123;display: table-row-group;&#125;tfoot &#123;display: table-footer-group;&#125;col &#123;display: table-column;&#125;colgroup &#123;display: table-column-group;&#125;td,th &#123;display: table-cell;&#125;caption &#123;display: table-caption;&#125; 以行为主CSS将其表模型定义为“以行为主”，这个模型假设创作人员创建的标记语言会显式声明行，而列是从单元格行的布局推导出来的。如第一列由各行中的第一个单元格组成 列虽然CSS表模型是面向行的，列在布局中仍有很重要的地位。虽然单元格在文档源中是行元素的后代，但它也可同是属于两个上下文。列和列组只能接受四种样式：border、background、width、visibility 匿名表对象标记语言中可能未包含足够的元素，以至于无法按 CSS的定义充分表示表，也可能创作人员没有加入所有必要的元素。考虑到这种可能性，CSS定义了一种机制，可以将“遗漏的”组件作为匿名对象插入。 对象插入规则： 如果一个table-cell元素的父元素不是table-row元素，则会在该元素及其父元素之间插入一个匿名table-row对象。所插入的这个对象将包含该table-cell元素所有的连续兄弟 如果一个table-row元素的父元素不是table、inline-table或table-row-group元素，则会在该元素及其父元素之间插入一个匿名table元素。所插入的这个对象将包含该table-row元素所有的连续兄弟 如果一个table-column元素的父元素不是table、inline-table或table-row-group元素，则会在该元素及其父元素之间插入一个匿名table元素。所插入的这个对象将包含该table-column元素所有的连续兄弟 如果一个table-row-group、table-header-group、table-footer-group、table-column-group或table-caption元素的父元素不是table元素，则会在该元素及其父元素之间插入一个匿名table元素 如果一个table或inline-table元素的子元素不是table-row-group、table-header-group、table-footer-group、table-column-group或table-caption元素，则会在该table元素及其子元素之间插入一个匿名table-row对象。这个匿名对象将包含该子元素的所有不是table-row-group、table-header-group、table-footer-group、table-column-group或table-caption元素的连续兄弟 如果一个table-row-group、table-header-group、table-footer-group、元素的子元素不是table-row元素，则在该元素和其子元素之间插入一个匿名table-row对象，这个匿名对象包含该子元素的所有本身非table-row对象的连续兄弟 如果一个table-row元素的子元素不是table-cell元素，则在该元素和其子元素之间插入一个匿名table-cell元素，这个匿名对象包含该子元素的所有本身非table-cell对象的连续兄弟 表层为了完成表的显示，CSS定义了6个不同的“层”，可以分别放表的不同方面 表标题表标题是一小段文本，描述了表内容的本质。利用属性caption-side可以把这个元素放在table上面／下面不论该表标题出现在表结构中哪个位置（在HTML中，caption元素只能出现在开始table元素的后面，其他语言可能不同） caption-side 值： top \ bottom 初始值： top 应用于： display值为table-caption的元素 继承值： 有 计算值： 根据指定确定 表单元格边框CSS有两种截然不同的边框模型。按布局来讲，如果单元格相互之间是分隔的，就是分隔边框模型在起作用。另一种选择是合并边框模型，采用这种模型，单元格之间没有可见的间隔 border-collapse 值： collapse \ separate \ inherit 初始值： separate 应用于： display值为table或inline-table的元素 继承值： 有 计算值： 根据指定确定 说明： 在CSS2中，默认值是collapse 分隔单元格边框边框间隔 border-spacing 值： ? \ inherit 初始值： 0 应用于： display值为table或inline-table的元素 继承值： 有 计算值： 两个绝对长度 说明： 除非border-collapse值为separate，否则会忽略该属性 ### 处理空白单元格 empty-cells 值： show \ hide \ inherit 初始值： show 应用于： display值为table-cell的元素 继承值： 有 计算值： 根据指定确定 说明： 除非border-collapse值为separate，否则会忽略该属性 ### 合并单元格边框合并单元格模型基本上描述了没有单元间隔是HTML表通常如何布局，以下规则使合并单元格边框与分隔单元格边框有所区别： display值为table或inline-table的元素不能有任何内边距，不过可以有外边距。因此表的外围边框与其最外单元格的边界之间不会有任何间隔 边框可以应用到单元格、行、行组、列和列组。表元素本身通常都有一个边框 单元格边框之间绝对不会有任何间隔。实际上，如果边框相邻，就会相互合并，只画出其中一个边框 一旦合并，单元格之间的边框会在单元格之间的假想表格线上居中 合并边框布局row width=(0.5 border-width0) + padding-left1 + width1 + padding-right1 + border-width1 + padding-left2 + … + padding- rightn + (0.5 border-widthn) border-widthi是指单元格i与下一个单元格之间的边距 边框合并 如果每个合并边框的border-style为hidden，它会优先于所有其他合并边框，这个位置上的所有边框都隐藏 如果某个合并边框的border-style为none，它的优先级最低 如果至少有一个合并边框的border-style值不是none，而且所有合并边框的border-style值都不是hidden，则窄边框不敌宽边框。若边框宽度相同，则考虑边框样式，按以下优先顺序：double、solid、dashed、dotted、ridge、outset、groove、inset 如果合并边框和样式都一样，但是颜色不同，按以下优先顺序使用元素的颜色：cell、row、row group、column、column group、table 表大小已经讨论过表的格式化和单元格边框显示，下面需要了解如何确定表及其内部元素的大小。确定表的宽度有两种方法：固定宽度布局和自动宽度布局。不论使用哪一种宽度算法，高度都自动计算 宽度使用属性table-layout来声明采用哪种方法来计算表宽度 table-layout 值： auto \ fixed \ inherit 初始值： auto 应用于： display值为table或inline-table的元素 继承值： 有 计算值： 根据指定确定 两者最显著的差异是速度。使用固定宽度表布局时，用户代理可以更快地计算出表的布局 固定布局固定布局之所以快主要原因是布局不依赖于表格单元内容，其布局是根据该表以及表中列和单元格的width值决定的 固定布局模型的工作包括以下简单步骤： width属性值不是auto的所有列会根据width值设置该列的宽度 如果一个列的宽度是auto——但表首行中位于该列的单元格width不是auto——则根据该单元格的宽度设置此列的宽度。如果这个单元格跨多列，则宽度在这些列上平均分配 在以上两步后，列的宽度仍然为auto，会自动确定其大小，使其宽度尽可能相等 此时表的宽度设置为表的width值或列宽度之和（取其中较大者）。如果表宽度大于其列宽总和，则将二者之差除以列数，加到所有列上 自动布局高度对齐小结]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSS权威指南】第十章学习笔记：浮动和定位]]></title>
    <url>%2F2018%2F08%2F12%2F%E3%80%90CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E7%AC%AC%E5%8D%81%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%B5%AE%E5%8A%A8%E5%92%8C%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[通过字体改变、背景和所有其他属性，CSS能让内容看上去不错，不过CSS在完成基本布局任务方面怎么样呢？接下来看浮动和定位。 定位的思想很简单，它允许你定义元素框相对于其正常位置应该出现在哪里，或者相对于父元素、另一个元素甚至相对于浏览器窗口。 浮动不完全是定位，不过它也不是正常流布局。 浮动过去，只能浮动图像。但CSS允许浮动任何元素，从图像到段落再到列表，所有元素都可以浮动 float 值： left \ right \ none \ inherit 初始值： none 应用于： 所有元素 继承值： 无 计算值： 根据指定确定 浮动元素对于浮动元素，有几点要记住。首先会以某种方式将浮动元素从文档的正常流中删除，不过它还是会影响布局。要浮动一个非替换元素，必须为该元素申明一个width。浮动元素的外边距并不会合并 不浮动float: none用于防止元素浮动 浮动的详细内幕深入讨论浮动的详细内容之前，首先建立包含块（containning block）的概念。浮动元素的包含块是其最近的块级祖先元素。浮动元素会生成一个块级框，不论这个元素本身是什么 控制浮动元素摆放的特定规则： 浮动元素的左（右）外边界不能超出其包含块的左（右）内边界 浮动元素的左（右）外边界必须是原文档中之前出现的左（右）浮动元素的右（左）外边界，除非后出现的浮动元素的顶端在先出现浮动元素的底端下面 左浮动元素的右外边界不会在其右边右浮动元素的左外边界的右边。一个右浮动元素的左外边界不会在其左边左浮动元素的右外边界的左边 一个浮动元素的顶端不能比其父元素的内顶端更高。如果一个浮动元素在两个合并外边距之间，放置这个浮动元素时就好像在两个元素中间有一个块级父元素 浮动元素的顶端不能比之前所有浮动元素或块级元素的顶端更高 如果一源文档中一个浮动元素之前出现另一个浮动元素，浮动元素的顶端不能比包含该元素生成框的任何行框的顶端更高 左（右）浮动元素的左（右）边有一个浮动元素，前者的右外边界不能在其包含块的右（左）边界的右边（左边） 浮动元素必须尽可能高地放置 左浮动元素必须向左尽可能远，右浮动元素则必须向右尽可能远。位置越高，就会向右或向左浮动得越远 实用行为当浮动元素超出其父元素的底端：浮动元素的延伸问题。通过将父元素设置为浮动元素，就可以把浮动元素包含在其 父元素内。 负外边距有意思的是，负元外边可能导致浮动元素移到其父元素内边距外边。 浮动元素、内容和重叠如果一个浮动元素与正常流中的内容发生重叠会怎么样呢？ 行内框与一个浮动元素重叠时，其边框、背景、内容都在该浮动元素“之上”显示 块框与一个浮动元素重叠时，其块框和背景在该浮动元素“之下”显示，而内容在浮动元素“之上”显示 清除并不总是希望内容流过浮动元素流过浮动元素，可以利用clear属性完成，设置一个元素禁止浮动元素出现在它旁边 clear 值： left \ right \ both \ none \ inherit 初始值： none 应用于： 块级元素 继承值： 无 计算值： 根据指定确定 1h3 &#123;clear: both;&#125; 定位利用定位可以准确地定义元素框相对于其正常位置应该出现在哪里，或者相对于父元素、另一个元素甚至相对于浏览器窗口本身的位置 基本概念定位的类型通过使用position属性，可以选择4种不同类型的定位，这会影响元素生成的方式 position 值： static \ relative \ absolute \ fixed \ inherit 初始值： static 应用于： 所有元素 继承值： 无 计算值： 根据指定确定 position值的含义： static 元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分。行内元素创建一个或多个行框，置于其父元素中 relative 元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留 absolute 元素框从文档流完全删除，并相对于其包含块定位，包含块可能是文档中的另一个元素或者是初始包含块（见下一节的介绍）。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，不论其原来在正常流中是何种类型 fixed 元素框的表现类似于将position设置为absolute，不过其包含块是视窗本身 包含块本章较早前讨论过浮动元素的包含块，其包含块定义是最近的块级祖先元素。对于定位，情况就没有这么简单： “根元素”的包含块（也称初始包含块）由用户代理建立。在HTML中，根元素就是html元素。在大多数浏览器中，初始包含块是一个视窗大小的矩形 非根元素，如果其position值是relative或static，其包含块由最近的块级框、表单元格或行内块祖先框的内容边界构成 非根元素，如果其position值是absolute，包含块设置为最近的position值不是static的祖先元素（可以是任何类型） “包含块”一词实际上是“定位上下文” 偏移属性上一节的三种定位机制（relative、absolute和fixed）使用了4个属性来描述定位元素相各边相对于其包含块的偏移，称为偏移属性： top、right、bottom、left 值： \ \ auto \ inherit 初始值： auto 应用于： 定位元素（也就是position值不是static的元素） 继承值： 无 百分数： 对于top和bottom，相对于包含块的高度；对于right和left，相对于包含块的宽度 计算值： 对于相对定位元素，见以下说明；对于static元素为auto；对于长度值，是相应的绝对长度；对于百分数值，则为指定的值；否则为auto 说明： 计算值取决于一系列因素；见附录A中的相关例子 正值会导致向内偏移，使边界朝着包含块的中心移动，而负值会导致向外偏移 宽度和高度设置宽度和高度尽管有时候设置一个元素的宽高很重要，但对于定位元素却不一定，例一个绝对定位元素从上到下填充其包含块的左半部分： 1234567p &#123; position: absolute; top: 0; bottom: 0; left: 0; right:50%;&#125; 就像使用了width: 50%; height: 100%; 限制宽度和高度若有必要或需要，可以对元素宽高进行一些限制，利用最小最大属性 min-width、min-height 值： \ \ inherit 初始值： 0 应用于： 除了非替换行内元素和表元素以外的所有元素 继承值： 无 百分数： 相对于包含块的宽度 计算值： 对于百分数，根据指定确定；对于长度值，则为绝对长度；否则，为none max-width、max-height 值： \ \ inherit 初始值： 0 应用于： 除了非替换行内元素和表元素以外的所有元素 继承值： 无 百分数： 相对于包含块的宽度 计算值： 对于百分数，根据指定确定；对于长度值，则为绝对长度；否则，为none 【这些属性值不能为负】 内容溢出和剪裁如果一个元素内容对于元素来说过大，就可能溢出元素本身，CSS2允许你从中选择，还允许定义一个裁剪区域 溢出 overflow 值： visible \ hidden \ scroll \ auto \ inherit 初始值： visible 应用于： 块级元素和替换元素 继承值： 无 计算值： 根据指定确定 如果overflow设置为scroll，元素会在元素框边界处剪裁。。 内容裁剪如果一个绝对定位元素的内容溢出其内容框，而且overflow设置为要求裁剪该内容，通过属性clip可以改变裁剪区域的形状 clip 值： rect(top, right,bottom,left) \ auto \ inherit 初始值： auto 应用于： 绝对定位元素 继承值： 无 计算值： 对于矩形，4个计算长度表示裁剪矩形区域的4个边；否则，根据指定确定 （。。。） 元素可见性 visibility 值： visible \ hidden \ collapse \ inherit 初始值： visible 应用于： 所有元素 继承值： 有 计算值： 根据指定确定 绝对定位包含块和绝对定位元素元素绝对定位时，会从文档流中完全删除。然后相对于其包含块定位，其边界根据偏移属性（top、left等）放置。定位元素不会流入其他元素的内容，反之亦然。这说明定位元素可能覆盖其他元素或者被其他元素覆盖（本章后面讲到覆盖顺序的改变） 绝对定位元素的包含块是最近的position值不为static的祖先元素。创作人员通常会选择一个元素作为绝对定位元素的包含块，将其position指定为relative而且没有偏移 绝对定位元素的放置和大小4个偏移属性均指定时，元素框的宽高均由此放置绝对，若再显示设置宽高，下一节将介绍如何处理 自动边偏移绝对定位一个元素时，偏移属性未指定的，与其“静态”位置一致。这种情况下通常对定位元素的尺寸没有什么限制，假设有一些限制的话下一节介绍如何处理 非替换元素的放置和大小一般地，元素的大小和位置取决于其包含块。各个属性（width、right、padding-left等）的值也会有一些影响，不过最主要的还是其包含块 绝对定位元素会“恰当收放”以满足垂直或水平方向上各属性值和为包含块的width。在水平／垂直过度受限的情况下忽略“right”／“bottom”的值 替换元素的放置和大小替换元素和非替换元素的定位规则大不相同。因为其有固定的高宽，没有“恰当收放”行为的概念。确定替换元素的位置和大小，涉及到的行为规则： u z轴上的放置对于所有定位，最后都不免遇到这样一种情况：两个元素视图放在同一个位置上，使用z-index属性控制谁在“上层” visibility 值： \ auto \ inherit 初始值： auto 应用于： 所有元素 继承值： 无 计算值： 根据指定确定 有较高z-index值的元素离读者更近。所有整数都可以作为z-index的值，包括负数 固定定位从上一节可知，固定定位与绝对定位很类似，不过固定定位的包含块时视窗。固定定位时，元素会从文档流中去除，不会有相对于文档中任何部分的位置 相对定位理解起来相对简单的定位机制是相对定位。采用这种机制是，将通过使用偏移属性移动定位元素 小结]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSS权威指南】第九章学习笔记：颜色和背景]]></title>
    <url>%2F2018%2F08%2F12%2F%E3%80%90CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E7%AC%AC%E4%B9%9D%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%A2%9C%E8%89%B2%E5%92%8C%E8%83%8C%E6%99%AF%2F</url>
    <content type="text"><![CDATA[CSS允许向一个页面应用多种不同的颜色和背景，而且不需要任何的FONT\TABLE标记 颜色在CSS中，可以为任何元素设置前景色和背景色，从body到强调元素、超链接元素，再到几乎所有一切（列表项、整个列表、标题、表单元格，甚至从某种程度上图像也可以设置前景色和背景色）。要理解这是如何工作，需要理解元素前景中有什么，没有什么 一般来说，前景是元素的文本，不过前景还包括元素周围的边框。因此有两种方式可以影响元素的前景色：可以使用color属性，或使用某个边框属性设置颜色 前景色要设置一个元素的前景色，最容易的办法是利用属性color color 值： \ inherit 初始值： 用户代理特定的值 应用于： 所有元素 继承值： 有 计算值： 根据指定确定 在章4曾讨论过，这个属性接受任何合法颜色类型的值，例如#FF0066或rgb(1,2,30%)，也可以接受章13将介绍的系统颜色关键字 对于非替换元素，color设置了元素中文本的颜色 替换属性color有很多用法，最重要的是替换HMTL 3.2的BODY属性TEXT、LINK、ALINK、VLINK。利用伪锚类，color完全可以替换这些BODY属性 1&lt;body text="black" link="#808080" alink="silver" vlink="#333"&gt; 1234body &#123;color: black;&#125;a:link &#123;color: #808080;&#125;a:active &#123;color: silver;&#125;a:visited &#123;color: #333;&#125; 影响边框color值还可以影响元素周围的边框 影响表单元素（从理论上讲）也可以为表单元素设置color值，声明select元素有暗灰色文本很简单 1select &#123;color: rgb(33%,33%,33%);&#125; 还可以设置input元素的前景色等 继承颜色由color的定义可知，这个属性是可以继承的 背景元素的背景区包括前景之下直到边框边界的所有空间，因此内容框和内边距都是元素背景的一部分，且边框画在背景之上 CSS允许应用纯色作为背景，也允许使用背景图像创建相当复杂的效果；CSS在这方面的能力远超HTML 背景色类似于设置前景色，可以为元素声明一个背景色，使用background-color属性，它接受所有合法的颜色，还可以接受一个使背景透明的关键字 background-color 值： \ transparent \ inherit 初始值： transparent 应用于： 所有元素 继承值： 无 计算值： 根据指定确定 如果希望背景色从元素中的文本下向外稍延伸，只需要增加一些内边距。可以为几乎所有元素设置背景色，但background-color不能继承，其默认值是transparent 结合效果只需结合color和background-color就可以创造一些有用的效果 背景图像在HTML3.2中，可以通过 BODY属性的background属性向文档背景关联一个 图像 1&lt;body background="bg23.gif"&gt; 这会使用户代理加载文件bg23.gif然后把它“平铺”在文档背景中，沿水平方向和垂直方向重复放置这个图像，填满文档的整个背景。这种效果CSS也能达到，不过CSS能做到更多 使用图像 background-image 值： \ none \ inherit 初始值： none 应用于： 所有元素 继承值： 无 计算值： 绝对URI 类似于background-color，background-image也不能继承，实际上，所有的背景属性都不能继承。还需记住，指定背景图像的URL时，相对路径是结合样式表而言的 为什么背景不能继承之前专门指出过，背景不能继承。从背景图像可以了解到为什么继承背景不是一件好事。假设背景确实能继承，而且向body应用的了一个背景图像，这个图像将用于文档所有元素的背景，而且每个元素都完成自己的平铺，类似以下语句效果： 1* &#123;background-image: url(yinyang.gif);&#125; 关于背景的良好实践图像放在指定的背景颜色上。如果完全平铺不透明图象颜色倒是不会透出来，但包含alpha通道的图像格式如png，可以与背景色结合。也能使图像加载失败的时候 有方向的重复 background-repeat 值： repeat \ repeat-x \ repea-y \ no-repea \ inherit 初始值： repeat 应用于： 所有元素 继承值： 无 计算值： 根据指定确定 背景定位 background-position 值： \ \ left \ center \ right \ top \ bottom \ inherit 初始值： 0% 0% 应用于： 块级元素和替换元素 继承值： 无 百分数： 相对于元素和原图像上的相应点（见本章后的“百分数值”一节的解释） 计算值： 如果指定了，则为绝对长度偏移；否则，是百分数值 关键字图像放置关键字最容易理解。例如top right使原图放在元素内边距区的右上角。如果只出现了一个关键字，则认为另一个关键字是center 百分数值百分数值和关键字紧密相关，不过表现方式更为复杂。百分数值同时应用于元素和原图像 1p &#123;background-position: 50% 50%;&#125; //图像中描述为50%50%的点（中心点）与元素中描述为50%50%的点（中心点）对齐 长度值最后看定位的长度值。在原图像的位置提供长度值时，这些长度值将解释为从元素内边距区左上角的偏移。 如果使用长度值或百分数值，可以使用负值把原图像拉出元素的背景区（部分出现） 有方向的重复（深入）之前介绍的背景重复，对于其关键值repeat、repeat-x等总是从包含元素的左上角开始。利用background-position移动图像位置，就能使重复从其指定的位置开始 关联现在已经知道可以将背景原题像放在元素背景上的任何位置，可以控制（某种程度上）平铺。但图像往往随着文档滚动，每次用户滚动超过图像的位置，图像就会消失。使用background-attachment可以防止这种滚动 background-attatchment 值： scroll \ fixd \ inherit 初始值： scroll 应用于： 所有元素 继承值： 无 计算值： 根据指定确定 通过使用属性background-attachment可以声明原图像相对于【可视区】是固定的（fixed）不受滚动的影响 123456body &#123; background-image: url(bigyinyang.gif); background-repeat: no-repeat; background-position: center; background-attachment: fixd;&#125; 有意思的效果技术上讲，一个图像背景已经固定（fixed），它会相对于可视区定位，而不是相对于包含该图像的元素定位。不过背景将只在其包含元素中可见 汇总与字体属性一样，背景属性可以汇总到一个简写属性：background。这个属性可以 从各个其他背景属性取一个值，而且可以采用任何顺序 background 值： [ \ \ \ \ \ \ \ \ ] \ inherit 初始值： 根据单个属性 应用于： 所有元素 继承值： 无 百分数： 允许的值 计算值： 见单个属性 小结CSS给元素应用样式，除了在元素周围放置边框、额外的内外边距，还可以向任何元素设置颜色和背景 甚至可以“浮动”元素，下一章介绍]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSS权威指南】第八章学习笔记：内边距、边框和外边距]]></title>
    <url>%2F2018%2F08%2F12%2F%E3%80%90CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%86%85%E8%BE%B9%E8%B7%9D%E3%80%81%E8%BE%B9%E6%A1%86%E5%92%8C%E5%A4%96%E8%BE%B9%E8%B7%9D%2F</url>
    <content type="text"><![CDATA[上个世纪的web设计人员，页面很可能全部用表来建立布局。之所以这样设计，原因是表可以用来创建边栏，还可以为整个页面的外观建立一种复杂的结构。 CSS的作者认为直接创建一种框更容易。所以下了很大功夫，允许你现在为段落、div、锚和图像（几乎是web页面可以包含的一切）定义边框。这些边框可以将一个元素与其他元素分开，强调其外观，将某类数据标志为有改变，或者达到其他效果。 CSS还允许在一个元素外围定义一些区域，来控制如何相对于内容摆放边框，以及其他元素与该元素边框可以有多近。在一个元素的内容及其边框之间，可以看到元素的内边距（padding），边框外则是外边距。当然这些属性影响着整个文档如何布局，不过更重要的是，它们会严重影响元素的外观。 基本元素框上一章曾讨论过，所有文元素都生成一个矩形框，这成为元素框。描述了一个元素在文档布局中所占的空间大小，影响着其他元素的框的形状和大小 默认地，一个可以显示的文档由多个矩形框组成，这些矩形框分布开，从而不会相互重叠 宽度和高度一个元素的width被定义为从左侧内边距到右内边距的距离，height被定义为上内边界到下内边界的距离，但它们不能应用到行内非替换元素 width 值： \ \ auto \ inherit 初始值： auto 应用于： 块级元素和替换元素 继承值： 无 百分数： 相对于包含块的width 计算值： 对于auto和百分数值，根据指定确定；否值是一个绝对长度，除非元素不能应用该属性（此时为auto） height 值： \ auto \ inherit 初始值： auto 应用于： 块级元素和替换元素 继承值： 无 百分数： 相对于包含块的height 计算值： 对于auto和百分数值，根据指定确定；否值是一个绝对长度，除非元素不能应用该属性（此时为auto） 外边距和内边距元素框在元素之间只提供了很少的空间，有三种方法可以在元素周围生成额外的空间： 增加内边距 增加边框 增加外边距 接下来了解使用这些属性 外边距 margin 值： [ \ \ auto ]{1,4} \ inherit 初始值： 未定义 应用于： 所有元素 继承值： 无 百分数： 相对于包含块的width 计算值： 见各个属性 长度值和外边距设置元素外边距时，可以使用任何长度值 12img &#123;margin: 2em;&#125;h1 &#123;margin: 10px 15px 15px 5px;&#125; //顺序是上右下左 百分数和外边距对元素外边距设置百分数值，是相对于父元素的width计算，不仅适用于左右外边距，也适用于【上下外边距】！（定位元素的上下边距如果是百分数值，其处理会有所不同，章10讨论） 12div &#123;width: 200px;&#125;div &gt; p &#123;margin: 10%;&#125; //200*10%=20px; 值复制1h1 &#123;margin: 10px 1.5em 10px 1.5em;&#125; 有时为外边距输入的值会有些重复，不过不必像上面这样重复地键入这对数字，直接： 1h1 &#123;margin: 10px 1.5em;&#125; 这两个值足以取代前面的四个值。值复制的规则如下： 单边外边距属性幸运的是，确实有一种办法可以为元素单边上的外边距设置值。 margin-top、margin-right、margin-bottom、margin-left 值： \ \ auto \ inherit 初始值： 未定义 应用于： 所有元素 继承值： 无 百分数： 相对于包含块的width 计算值： 对于百分数，根据指定确定；否则，为绝对长度 负外边距和合并外边距章7曾经讨论过，可以为元素设置负外边距。这会导致元素超出其父元素，或者与其他元素重叠，但并不违反框模型 正常流中垂直相邻外边距会合并 外边距和行内元素外边距还能应用到行内元素，不过效果稍有不同。 这在规范中是允许的，向一个行内非替换元素应用外边距，它对行高没有任何影响（），其原因就在于行内非替换元素的外边距不会改变一个元素的行高。这只对行内非替换元素的上下边成立，左右两边则会增加或减少相应的距离 替换元素又有不同：为其设置外边距确实会影响行高 边框元素外边距内就是元素的边框。围绕着元素内容和内边距的一条或多条线。每个边框有三个方面：宽度或粗细、样式或外观、以及颜色 边框和背景CSS2.1明确指出，元素的背景是内容、内边距和边框区的背景 有样式的边框先来讨论边框的样式，这是边框最重要的一个方面，并不只是因为样式控制着边框的显示，而是因为如果没有样式，将根本没有边框 border-style 值： [ none \ hidden \ dotted \ dashed \ solid \ double \ groove \ ridge \ inset \ outset ]{1,4} \ inherit 初始值： 对简写属性没有没有定义 应用于： 所有元素 继承值： 无 计算值： 见各个属性（border-top-style等） 你不一定能看到边框，因为其默认样式是none 多种样式可以为边框定义多个样式： 1p &#123;border-style: solid dashed dotted solid;&#125; 关于外边距和内边距值复制的规则同样适用于边框样式 单边样式有时你可能只想为元素框的一边设置边框样式 border-top-style、border-right-style、border-bottom-style、border-left-style 值： none \ hidden \ dotted \ dashed \ solid \ double \ groove \ ridge \ inset \ outset \ inherit 初始值： none 应用于： 所有元素 继承值： 无 计算值： 根据指定确定 边框宽度一旦为边框指定一个样式，下一步就是适用border-width为它指定一个宽度 border-width 值： [ thin \ medium \ thick \ ]{1,4} \ inherit 初始值： 对简写属性没有定义 应用于： 所有元素 继承值： 无 计算值： 见各个属性（border-top-width） border-top-width、border-right-width、border-bottom-width、border-left-width 值： thin \ medium \ thick \ \ inherit 初始值： medium 应用于： 所有元素 继承值： 无 计算值： 绝对长度；如果边框样式为none或hidden则为0 根本没有边框样式为none的边框不存在，边框宽度自动设置为0 1p &#123;border-style: none; border-width: 20px;&#125; //边框宽度为0 如果希望边框出现，【必须设置边框样式】 边框颜色默认的边框颜色是元素前景色，设置颜色也很简单，利用属性border-color border-color 值： [ \ transparent ]{1,4} \ inherit 初始值： 对简写属性没有定义 应用于： 所有元素 继承值： 无 计算值： 见各个属性（border-top-color） border-top-color、border-right-color、border-bottom-color、border-left-color 值： transparent \ \ inherit 初始值： 元素的color值 应用于： 所有元素 继承值： 无 计算值： 如果没有指定值，则使用同一元素的color属性的计算值；否则，根据指定确定 透明边框你应该还记得，如果一个边框没有样式，就没有宽度。不过可以通过边框颜色值transparent创建一个有宽度的不可见框 简写边框属性 border-top、border-right、border-bottom、border-left 值： [ \ \ \ \ ] \ inherit 初始值： 对简写属性没有定义 应用于： 所有元素 继承值： 无 计算值： 见各个属性（border-width等） 全局边框 border 值： [ \ \ \ \ ] \ inherit 初始值： 根据单个属性 应用于： 所有元素 继承值： 无 计算值： 根据指定确定 使用border的缺点在于，指定定义“全局”的样式、颜色和宽度，为border提供的值将完全相等地应用到所有4个边。不过可以充分利用层叠 边框和行内元素对于处理边框和行内元素我们应该很熟悉了，很大程度上与外边距和行内元素的相应规则相同，在章7介绍过。不论为行内元素的边框指定怎样的宽度，元素的行高都不会改变。同样的，这也只对行内元素的上下边成立，左右距离会受到影响 内边距元素框的内边距在边框和内容区之间 padding 值： [ \ ]{1,4} \ inherit 初始值： 对简写元素未定义 应用于： 所有元素 继承值： 无 百分数： 相对于包含元块的width 计算值： 见单个属性（padding-top等） 说明： 内边距绝对不能为负 【内边距不合并】 百分数值和内边距为元素的内边距设置百分数，同外边距一样，百分数值要相对于其父元素的width计算 单边内边距 padding-top、padding-right、padding-bottom、padding-left 值： \ \ inherit 初始值： 0 应用于： 所有元素 继承值： 无 百分数： 相对于包含元块的width 计算值： 对于百分数值，根据指定确定；对于长度值，则为绝对长度 说明： 内边距绝对不能为负 内边距和行内元素对于行内元素，外边距和内边距存在一个重要的区别。虽然也不改变行高，但有背景色和内边距的行内非替换元素，背景可以上下延伸 内边距和替换元素不论替换元素是块级元素还是行内元素，内边距都会围绕其内容 小结能够向所有元素应用外边距、边框和内边距，是CSS超越传统web标记语言的要素之一。]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSS权威指南】第七章学习笔记：基本视觉格式化]]></title>
    <url>%2F2018%2F08%2F12%2F%E3%80%90CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%9F%BA%E6%9C%AC%E8%A7%86%E8%A7%89%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前几章中，针对CSS如何处理文档中的文本和字体介绍了很多实用知识，这一章介绍视觉表现和前面为了强调CSS如何实现而跳过的一些问题。 视觉表现的一些理论方面，掌握视觉模型如何工作 基本框CSS假定每个元素都会生成一个或多个矩形框，这称为元素框。元素框中心有一个内容区（content area），这个内容区周围有可选的内边距、边框和外边距 内容的背景也会应用到内边距。外边距通常是透明的。内边距和边框宽度不能是负值，但外边距可以 包含块包含块就是一个元素的“布局上下文”，每个元素都相对于其包含块摆放 包含块由最近的块级祖先框、表单元格或行内块祖先框的内容边界构成 快速复习P167 正常流 非替换元素 替换元素 块级元素 行内元素 根元素 块级元素一般地，一个元素的width被定义为从左内边界到右内边界的距离，height则是从上内边界到下内边界的距离。不同高宽、内外边距相结合就可以确定文档的布局。大多数情况下，文档的高度和宽度由浏览器自动确定，这要基于可用的显示区域和其他一些因素。当然CSS下可用更直接的控制元素大小及其显示方式 对于水平和垂直布局，可以选择不同的效果： 水平格式化水平格式化复杂性在于width影响的是内容区的宽度，而不是整个可见的元素框 简单规则：正常流中块级元素元素框的水平部分总和就等于父元素的width 水平属性margin-left、bolder-left、padding-left、width、padding-right、bolder-right、margin-right这7个属性的值加起来必须是元素包含块的宽度，往往是块元素的父元素的width（块级元素的父元素几乎都是块级元素） 使用auto只有width、margin-left、margin-right可以设置为auto。 如果设置其中一个值为auto，会弥补实际值与所需总和的差距 若三个都不为auto，此时总会把margin-right强制为auto 不止一个auto时， 只有width非auto，则左右margin相等，能将元素在其父元素居中（不同于text-align只应用于块级元素的内联内容） ； 将某个外边距和width设置为auto，则设置为auto的外边距会减为0； 三个均为auto，外边距均会减为0 负外边距负外边距使子元素可能宽过父元素 百分数width、内边距和外边距设置为包含块宽度的百分数占比 替换元素非替换块级元素的所有规则同样适用于替换块级元素，其width如果设置为auto，高度也会成比例一起变化 垂直格式化一个元素的默认高度由其内容决定，高度还会受内容宽度的影响。在CSS中，可以对任何块级元素设置显式高度，高度不匹配时用户代理对大余的高度显示的视觉效果好像有额外的内边距一样，小于的高度用户代理可能会取决于overflow的值为内容区增加滚动条（以及用户代理对overflow属性的支持程度） 垂直属性margin-top、bolder-top、padding-top、width、padding-bottom、bolder-bottom、margin-bottom这7个属性的值加起来必须是元素包含块的高度，往往是块元素的父元素的height（块级元素的父元素几乎都是块级元素） 百分数一个块级正常流元素的height设置为一个百分数，则这个值是包含块height的一个百分数 auto高度在最简单的情况下，如果块级正常流元素设置height: auto，显示时其高度将恰好足以包含其内联内容（包括文本）的行盒。其默认高度是从最高块级子元素的外边框边界到最低块级子元素的外边框边界，所以子元素的外边距会“超出”盒。除非块级元素有上内边距或下内边距，上内边框或下内边框（隔开父子两个外边距，避免合并）其高度是从最高块级子元素的上边距边界到最低块级子元素的下边距边界 合并垂直外边距合并行为只应用于外边距，如果元素有内边距和边框，它们绝对不会合并 1li &#123;margin-top: 10px; margin-bottom: 15px&#125; //每项间隔15px 如果相邻块级元素垂直外边距都设置为正值，取大值 负外边距如果相邻块级元素垂直外边距都设置为负值，浏览器会选取绝对值最大的那个值；一正一负，取和 列表项列表项通常前面有一个标志“·”，其不是列表项内容区的一部分，属性list-style-position可将其放入内容内部，那么列表项整体就像一个块元素 行内元素为行内元素设置框属性，非替换元素和替换元素在内联内容方面的处理稍有不同 行布局P187 基本术语和概念P142很直观 匿名文本 所有未包含在行内元素中的字符串 123&lt;p&gt; i'm &lt;em&gt;so&lt;/em&gt; happy! //i'm和happy是匿名文本&lt;/p&gt; em框 font-size的值确定各个em框的高度 内容区 在非替换元素中，即元素中各字符的em框串在一起构成的框 在替换元素中的固有高度再加上可能有的外边距，边框或内边距 行间距 行间距只应用在非替换元素，行间距是font-height和font-size的差值，分为两部分，顶部和底部 行内框 通过向内容区增加行间距来描述。非替换元素的行内框高度即line-height的值。替换元素，行内框的高度等于内容区的高度（行间距不应用到替换元素） 行框 这是包含该行中出现的行内框的最高点和最低点的最小框。 如何逐步构造一个行框，通过这这个过程来了解一行的各部分如何共同确定其高度： 按以下步骤确定行中各元素行内框的高度： 得到各行内非替换元素及其不属于后代行内元素的所有文本的font-size值和line-height值 得到各替换元素的height、margin、border、padding值，把它们加在一起 对于各内容区，将这些元素基线与父元素基线对齐 对于指定了vertical-align值的元素，确定其垂直偏移量，改变其与基线的垂直距离 已经知道所有行内框的摆放，计算行框高度。只需将基线与最高行内框顶端之间的距离加上基线与最低行内框底端的距离 行内格式化行内非替换元素如果行中只包含非替换元素（或匿名文本）将如何构造 建立框对于非替换元素或匿名文本某一部分，font-size确定了内容区的高度，即em框高度；line-height确定了其行内框的高度 垂直对齐如果改变行内框的垂直对齐，会应用同样的高度确定原则，影响整个行框高度 管理line-height之前了解到改变一个行内元素的line-height可以导致文本重叠，不过都是针对单个元素的。如何以一种更一般的方式影响元素的line-height而避免内容重叠呢？ 对font-size有改变的元素结合使用em单位 12p &#123;font-size: 24px; line-height: 1em;&#125;big &#123;font-size: 250%; line-height&#125; //为big元素设置行高用以提高整个行框的总高度 直接改变父元素的line-height以容纳行内元素的改变 缩放行高可以看到，设置line-height最好的方式是使用一个原始数字值（缩放因子），因为改因子是一个继承值而非计算值，能应用到后代所有元素中。缩放因子在元素间逐层传递，在各层上，这个因子都作为一个乘数各元素的font-size相乘 增加框属性内边距、边框和外边距都可以应用到行内非替换元素，但不会影响行框的高度。可以影响元素左右两端距离 行内替换元素一般认为行内替换元素（如图像）有固有的高度和宽度，可能导致行框比正常要高，但不会改变行内任何元素的ling-height值，包括替换元素本身 替换元素的行内框由其内容、内外边距、边框定义 增加框属性内边距和边框像平常一样应用到行内替换元素，且其确实会影响行框的高度，因为它们作为行内替换元素的行内框的一部分；外边距也包含在行框中，它稍微特殊一点就是可以为负 替换元素和基线默认地，行内替换元素位于基线上，若增加下内边距／外边距／边框，内容区会上移。替换元素没有自己的基线，一般将其行内框的底端（实际上是下外边距边界）与基线对齐 改变元素显示章1简单提到过可以使用属性display设置一个值来影响用户代理显示的方式 display 值： none \ inline \ block \ inline-block \ list-item \ run-in \ tabel \ inline-table \ table-row-group \ table-header-group \ table-footer-group \ table-row \ table-column-group \ table-column \ table-cell \ table-caption \ inherit 初始值： inline 应用于： 所有元素 继承值： 无 计算值： 对于浮动、定位和根元素，计算值可变（章9.7节）；否则，根据指定决定 我们将忽略与表有关的值（章11）、值list-item（章12）。已经花了很大篇幅讨论了块级元素和行内元素，下面介绍inline-block元素，不过在那之前先花点时间介绍改变元素显示角色将如何改变布局 改变角色12li &#123;display: inline;&#125;a &#123;display: block;&#125; 【注意】改变的只是元素的显示角色，而不是其本质。例让一个段落生成行内框并不会把这个段落真正变成一个行内元素。display只影响元素如何显示 行内块元素实际上，行内块元素会作为替换元素放在行中。在行内块内部，会像块级元素一样设置内容的格式，就像所有块级元素或行内替换元素一样，也有属性width和height，如果比周围内容高，这些属性会使行高增加 小结尽管CSS格式化模型某些方面看起来不太直观，最初看起来没道理甚至荒谬的规则最后看来确实是合理的。很多方面块级元素都很容易理解和便于调整布局，行内元素则可能很难管理，因为有很多影响因素，还包括元素是替换还是非替换元素。 现在我们对文档布局的基础知识有所了解，下面关注如何使用各种布局属性，后几章都在讨论这个方面，首先看看最常用的框属性：内边距、边框和外边距]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSS权威指南】第六章学习笔记：文本属性]]></title>
    <url>%2F2018%2F08%2F12%2F%E3%80%90CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%96%87%E6%9C%AC%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[文本和字体不同：文本是内容，字体用于显示这个内容。使用文本属性，可以控制文本相对于该行余下内容的位置、使其作为上标、加下划线、以及改变大小写等。甚至还可以有限地模拟打字机的Tab键的使用 缩进和水平对齐如何影响文本在【行】中的水平定位。 缩进文本将Web页面上一个段落的第一行进行缩进，这是一种常用的文本格式化效果（去除段落之间的空行是第二常用的方法，章7会讨论）。实现文本缩进很好的方法是用test-indent属性 test-indent 值： \ \ inherit 初始值： 0 应用于： 块级元素 继承值： 有 百分数： 相对于包含块的宽度 计算值： 对于百分数值，根据指定确定；对于长度值，则为绝对长度 1p &#123;text-indent: 3em;&#125; 水平对齐text-align影响一个元素中的文本行相互之间的对齐方式 test-align CSS2.1值： left \ center \ right \ justify \ inherit CSS2值： left \ center \ right \ justify \ \ inherit 初始值： 用户代理特定的值；还可能取决于书写方向 应用于： 块级元素 继承值： 有 计算值： 根据指定确定 说明： CSS2.1去除一个值，因为没有相应实现 text-align: center与元素大不相同：不仅影响文本，还会把整个元素居住。test-align不会控制元素的对齐，而只影响其内部内容 垂直对齐简单概述垂直对齐，文本行的构造会在章7详细讨论 行高line-height属性是指文本行基线之间的距离，不是字体的大小，确定了将各个元素框的高度增加或减少多少。line-height的值和字体大小之差才是行间距 line-height 值： \ \ \ normal \ inherit 初始值： normal 应用于： 所有元素（不过请参考替换元素和块级元素的介绍） 继承值： 有 百分数： 相对于元素的字体大小 计算值： 对于长度和百分数值是绝对数值；否值，根据指定确定 在应用到块级元素时，定义的是元素中文本基线之间的最小距离，而不是一个绝对数值，文本基线拉开的距离可能比line-height值更大。应用到替换元素，章7讨论 构造文本行文本行中的每个元素都会生成一个内容区，这由字体大小确定。内容区则会生成一个行内框（inline box），如果不存在其他因素，这个行内框就完全等于该元素的内容区。line-height产生的行间距就是在增加或减少各行内框高度因素之一 P142图片很直观 指定line-height的值默认值normal由用户代理计算，通常是字体大小的1.2倍，使得行内框高于给定元素的font-size值 行高和继承当一个块级元素从另一个元素继承line-height时，要从父元素字体大小计算，而不是子元素上计算。如果line-height小，font-size大就会出现一些问题。 12345&lt;div&gt; &lt;p&gt; this text for test &lt;/p&gt;&lt;/div&gt; 123body &#123;font-size: 10px;&#125;div &#123;line-height: 1em;&#125; //字体大小继承body，行高为10*1=10pxp &#123;font-size: 18px;&#125; //字体大于行高，文本行之间有交叠 显式地为每个元素设置line-height不如指定一个缩放因子（number）： 123body &#123;font-size: 10px;&#125;div &#123;line-height: 1;&#125; //指定一个数p &#123;font-size: 18px;&#125; line-height指定一个数时，缩放因子将是继承值而不是计算值。这个数会应用到该元素及其所有子元素，所以各元素都根据自己的font-size计算line-height 垂直对齐文本在CSS中vertical-align属性只能应用于行内元素和替换元素，且不能继承 vertical-align 值： baseline \ sub \ super \ top \ next-top \ middle \ botton \ text-bottom \ \ \ inherit 初始值： baseline 应用于： 行内元素和表单元格 继承值： 无 百分数： 相对于元素的line-height值 计算值： 对于长度值和百分数，为绝对长度；否值，根据指定确定 垂直对齐会使文本行变高（文本行框描述：其高度足以包含最高行内框的顶端和最低行内框的底端，这包括因垂直对齐上升或下降的行内框） 基线对齐verticcal-align: baseline要求一个元素的基线与父元素的基线对齐。如果一个垂直对齐元素没有基线（图像或表单输入元素，或其他替换元素），则该元素底端与父元素基线对齐 上标和下标verticcal-align: sub／super声明会使一个元素变成下／上标，其基线（或替换元素底端）相对于父元素的基线降低／升高，但不会改变字体大小 底端对齐verticcal-align: bottom将元素行内框的底端与行框的底端对齐 verticcal-align: text-bottom是指将行内文本的底端（替换元素或任何其他类型的非文本元素会忽略这个值） 顶端对齐verticcal-align: top的效果与botton刚好相反。类似的verticcal-align: text-top则与verticcal-align: text-bottom作用相反 居中对齐middle把行内元素框的中点与父元素基线上方0.5ex处的一个点对齐（这里的1ex相对于父元素的font-size定义） 百分数使用百分数不能模仿图像的align=”middle”（垂直）对齐，如果为verticcal-align设置一个百分数，会把元素的基线（或替换元素的底边）相对于父元素的基线升高或降低指定的量（该元素line-height乘百分数） 长度对齐为verticcal-align设定一个长度，则把一个元素升高或降低指定的距离 字间隔和字母间隔字间隔word-spacing用于修改字间间隔，默认值normal与设置值为0等价 word-spacing 值： \ normal \ inherit 初始值： normal 应用于： 所有元素 继承值： 有 计算值： 对于normal，为绝对长度0；否值，是绝对长度 字母间隔letter-spacing与word-spacing类似，区别是字母间隔修改的是字符或字母之间的间隔 间隔和对齐word-spacing的值可能受text-align属性值的影响。如果一个元素是两端对齐的，字母和字之间的空间可能会调整，以便文本在整行中刚好放下，这可能又会改变创作人员声明的字和字母间隔。若指定了字母间隔，则只改变字间隔。 文本转换text-transform属性处理文本的大小写 text-transform 值： uppercase \ lowercase \ capitalize \ none \ inherit 初始值： none 应用于： 所有元素 继承值： 有 计算值： 根据指定确定 uppercase和lowercase将文本转化为全大／小写，capitalize将文本转化为单词首字母大写 文本装饰text-decoration属性 text-decoration 值： [ underline \ \ overline \ \ line-through \ \ blink ] \ none \ inherit 初始值： none 应用于： 所有元素 继承值： 无 计算值： 根据指定确定 underline／overline给文本加下／上划线，line-through给文本加一根贯穿线，blink会让文本闪烁 怪异的装饰text-decoration不能继承，意味着文本上画的任何装饰线（上下划线和贯穿线）与父元素的颜色相同，即使后代元素本身有其他颜色，处理一般使用覆盖（为后代元素声明不同装饰） 文本阴影 text-shadow 值： none \ [ \ \ ? , ]* [ \ \ ? ] \ inherit 初始值： none 应用于： 所有元素 继承值： 无 计算值： 根据指定确定 默认情况是文本没有阴影。否值理论上可以定义一个或多个阴影，每个阴影都由一个颜色和3个长度值来定义。前两个长度值确定了阴影和文本的偏移距离，第三个长度可选，定义了阴影的“模糊半径” 处理空白格 white-space 值： none \ nowrap \ pre \ pre-wrap \ pre-line \ inherit 初始值： normal 应用于： 所有元素 继承值： 无 计算值： 根据指定确定 white-space可以影响浏览器处理字之间和文本行之间空白格的方式。 值 空白符 换行符 自动换行 pre-line 合并 保留 允许 normal 合并 忽略 允许 nowrap 合并 忽略 不允许 pre 保留 保留 不允许 pre-wrap 保留 保留 允许 文本方向大部分语言阅读流向都是从左到右，从上到下。不过也不是所有语言都如此 direction 值： ltr \ rtl \ inherit 初始值： ltr 应用于： 所有元素 继承值： 有 计算值： 根据指定确定 direction属性影响块级元素中文本的书写方向、表中列布局的方向、内容水平填充其元素框的方向，以及两端对齐元素中最后一行的位置。对于行内元素，只有当unicode-bidi属性设置为embed或bidi-override时才会应用direction属性 unicode-bidi 值： normal \ embed \ bidi-override \ inherit 初始值： normal 应用于： 所有元素 继承值： 无 计算值： 根据指定确定 P164 小结改变文本的外观，除了字体还有很多方法来改变文本的外观。除了一些经典的效果（如下划线），CSS还允许在文本上画线，或穿越文本画线；改变单词和字母间的间隔大小；将段落（或其他块级元素）的首行缩进；将文本左对齐右对齐等等。甚至可以修改文本行间的间隔大小，不过这个操作太过复杂，在第7章再详细说明。 但这些行为有些得到了很好的支持，有些则根本不支持。在本章中提到过，行布局比我们谈到的更复杂，在下一章将介绍行这个过程的详细内容，同时介绍很多其他知识。]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSS权威指南】第五章学习笔记：字体]]></title>
    <url>%2F2018%2F08%2F12%2F%E3%80%90CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[CSS规范的作者清楚地认识到，字体选择是一个常见（而且重要）的特性。毕竟有多少页面分布着数十个甚至数百个标记呢？实际上，规范中“字体属性”一节最开始就有这样一句话：“设置字体属性是样式表的最常见用途之一”。 CSS试图为所有字体问题提供一些解决机制，不过它不能提供一个全面的解决方案。CSS文字处理中最复杂的部分是字体系列（font-family）匹配和字体加粗（font-weight）匹配，其次是字体大小（font-size）计算。CSS与字体相关的方面还包括字体风格（如斜体）和字体变形（如小型大写字母）。字体样式的所有方面都集中到一个属性，即font，本章后面会讨论这个 属性。 字体系列除了特定字体（Times、Verdana或Arial等），CSS还定义了5种通用字体系列： Serif： 字体成比例（字体中所有字符根据其大小不同有不同的宽度，如小写i和m有不同宽度），有衬线 Sans-serif： 成比例，无衬线 Monospace 不成比例（每个字符等宽），通常用于模拟打字机文本，可能有衬线也可能没有 Cursive 模仿人手写体 Fantasy 一些无法用任何特征来定义的字体，但无法归入上列4种 可以使用属性font-family在文档中采用上述任何字体系列 font-family 值： [[ \ ],]* [ \ ] \ inherit 初始值： 用户代理指定的值 应用于： 所有元素 继承值： 有 计算值： 根据指定确定 使用通用字体系列1body &#123;font-family: sans-serif;&#125; //从sans-serif字体系列选择一个字体应用到body 指定字体系列1h1 &#123;font-family: Georgia;&#125; //使用Georgia应用在h1上 如果Georigia字体不可用，则使用另外一种serif字体。强烈建议在所有font-family规则中都提供一个通用字体系列 字体加粗利用font-weight属性，CSS允许对字体加粗有更多控制 font-weight 值： normal \ bold \ bolder \ lighter \ 100 \ 200 \ 300 \ 400 \ 500 \ 600 \ 700 \ 800 \ 900 \ inherit 初始值： normal 应用于： 所有元素 继承值： 有 计算值： 数字值（如100等等），或某个数字值加上某个相对数（bolder或lighter） 1b &#123;font-weight: bold;&#125; 加粗如何起作用关键字100～900与一个字体内置的加粗级别：100对应最细的字体变形，900对应最粗的字体变形 如果给定的字体系列中定义的加粗度少于9种，用户代理需要以一种预定方式填补这些“空白”： 如果未指定值500的加粗度，其字体加粗度与400的相应加粗相同 如果未指定值300的加粗度，则为之指定一个比400更细的变形。如果没有更细的变形，为300指定的变形等同于400的相应变形，通常为normal或medium。这种方法同样适用于200和100 如果未指定值600的加粗度，则为之指定一个比400更粗的变形。如果没有更粗的变形，为600指定的变形等同于500的相应变形。这种方法同样适用于900、800和700 如Times的一种缩减版本，只含两种加粗变形： 字体 指定的关键字 指定的数字 TimesRegular normal 100,200,300,400,500 TimesBold bold 600,700,800,900 让字体更粗加粗上移： 若给一个元素的加粗设置为bolder，用户代理先确定其从父元素继承的font-weight值。然后选择一个数，比继承值更粗的一个字体加粗值，并且在满足条件的所有数中，选择最小那个数。若没有可用的变形字体，把该元素的加粗值设置为下一个个更大的数字值，若900不变。 让字体更细加粗下移： 与加粗上移同理反向 字体大小 font-size 值： xx-small \ x-small \ small \ medium \ large \ x-large \ xx-large \ smaller \ larger \ \ \ inherit 初始值： medium 应用于： 所有元素 百分数： 根据父元素的字体大小来计算 继承值： 有 计算值： 数字值（如100等等），或某个数字值加上某个相对数（bolder或lighter） 与font-weight关键字bolder和lighter的方式类似，属性font-size也有两个相对大小关键字：larger和smaller。类似于相对字体加粗，这些关键字会导致font-size的计算址上移或下移。首先了解一下如何确定字体大小： 实际上font-size属性和你看到的实际字体大小之间的具体关系由字体设计者决定，这种关系设置为字体本身中有一个em方框。它指示没有额外行间距（CSS中的line-height）设置字体时基线间的距离（字体的字符可能比其高／低／相等）。font-size的作用是为给定字体的em框提供一个大小，不保证实际显示的字符就是这个大小 绝对大小font-size有七个绝对大小关键字：xx-small、x-small、small、medium、large、x-large、xx-large。没有明确的定义，只有相对的定义。 根据CSS1规范，一个绝对大小与下一个绝对大小之间的差别（或缩放因子）应当是向上1.5，或向下0.66（不同用户代理的缩放因子可能不同；CSS2中缩放因子可能介于1.0～1.2之间） 假设medium等于16px，对于不同缩放因子，绝对大小如下： 关键字 缩放1.5 缩放1.2 xx-small 5px 9px x-small 7px 11px small 11px 13px medium 16px 16px large 24px 19px x-large 36px 23px xx-large 54px 28px 相对大小font-size有两个相对大小关键字：larger和smaller，使元素大小相对于其父元素的大小在绝对大小梯度上进行上移和下移，使用计算绝对大小时采用的缩放因子 不同于加粗的相对值，相对大小值不必限制在绝对大小范围内（可以超过xx-large和小于xx-small） 百分数和大小和相对大小关键字很相似。总是根据从父元素继承的大小来计算。不同于相对大小关键字的是，百分数允许对计算大小有更细的控制 字体大小和继承尽管CSS中font-size是可以继承的，但继承的是计算值而不是百分数（步步计算取整），例： 1&lt;p&gt;this text contain both&lt;em&gt;emphasis and&lt;strong&gt;strong emphasis&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; 123p &#123;font:size: 12px;&#125;em &#123;font-size: 120%;&#125; //12*120%=14.4pxstrong &#123;font-size: 135%;&#125; //14.4*135%=19.44px 可能造成问题：缩放失控（取整错误累计）。多级嵌套的元素难以阅读 使用长度单位可以使用章4讨论的任何长度值来设置font-size，以下所有font-size声明等价： 12345p.one &#123;font-size: 36pt;&#125;p.two &#123;font-size: 3pc;&#125;p.three &#123;font-size: 0.5in;&#125;p.four &#123;font-size: 1.27cm;&#125;p.five &#123;font-size: 12.7mm;&#125; 不同操作系统作用于不同分辨率的显示媒体上，显示结果与现实可能不能完全匹配（p.three可能不为半英寸），但度量彼此之间是一致的 由于这些差别，创作人员选择像素指定字体大小。如果界面上既有文本又有图像，就很适合采用这种方法。缺点是ie6之前不允许用户轻松调整用像素设置的文本大小（其他浏览器包括ie7支持）。因此使用像素来设置文本大小同其他方式一样，无法保证总有同样的大小。本章讨论的其他方法（如关键字和百分数）都更为健壮，可以用这些方法在用户默认字体大小的基础上缩放文本 风格和变形font-style和font-variant 有风格的字体font-style用于在normal文本、italic文本和oblique文本之间进行选择 font-style 值： italic \ oblique \ normal \ inherit 初始值： normal 应用于： 所有元素 继承值： 有 计算值： 根据指定确定 斜体（italic）是一种单独的字体风格，对字母的结构有所改动 倾斜（oblique）文本则是正常竖直（normal）的一个倾斜版本 字体变形 font-variant 值： small-caps \ normal \ inherit 初始值： normal 应用于： 所有元素 继承值： 有 计算值： 根据指定确定 font-variant只有两个非继承值：默认值normal和small-caps，small-caps要求使用小型大写字母文本。 拉伸和调整字体font-stretch和font-size-adjust，目前少有浏览器支持，了解 font属性font属性是涵盖所有其他字体属性（以及少数其他内容）的一个简写属性 font 值： [ \ \ \ \ ]? [ / ]? ] \ caption \ icon \ menu \ message-box \ small-caption \ status-bar \ inherit 初始值： 根据单个元素 应用于： 所有元素 继承值： 有 百分数： 对于要对于父元素计算；对于则相对于元素的计算 计算值： 见单个属性（font-style等） 前三个值允许采用任意的顺序出现，后两个更为严格，必须在font声明中出现且按这个顺序 增加行高font还可以设置line-height，尽管它不是字体属性而是一个文本属性。它是对font-size值的一个补充，并用一个斜线（／）与之分隔 适当地使用简写使用font简写时，所有被忽略的值都会被重置为其默认值 12h1, h2 &#123;font: italic small-caps 250% sans-serif;&#125;h2 &#123;font: 200% sans-serif;&#125; //h2不会有斜体和小型大写字母效果 使用系统字体一些值是Web页面结合用户操作系统的设置，font的系统字体值很方便。这些址取得操作系统的字体大小、字体系列、字体加粗、字体风格和字体变形，并将其应用到一个元素。这些值如下： caption 用于有标题的控件，如按钮 icon 用于对图标加标签 menu 用于菜单，即下拉菜单的菜单列表 messege-box 用于对话框 small-caption 用于对小控件加标签 status-bar 用于窗口状态条 例 你想把一个按钮的字体设置为与操作系统中的按钮字体完全相同： 1button &#123;font: caption;&#125; 字体匹配CSS允许匹配字体系列、加粗和变形，都是通过字体匹配完成的，接下来介绍字体匹配如何工作的 P132暂留 小结尽管创作人员不能指望文档中一定使用某个特定的字体，不过可以很容易地指定通用字体系列，且这种行为得到了很好的支持。对于字体管理的其他方面，相应的支持程度则有所不同。一般已经能很好的改变字体大小，对创作人员来说，让人困惑的往往不是以何种方式支持大小调整，而是想用的一些单位（点）在不同媒体上得到的结果往往差异很大，甚至在不同的用户代理和操作系统上也得到不同结果。在Web设计中使用长度单位通常不是一个好主意。百分数、em、ex单位往往更适合修改字体大小，因为这些单位在所有常用显示环境中能很好地缩放 为文本指定样式还有很多不涉及到字体的属性，这是下一章要讲的内容]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSS权威指南】第四章学习笔记：值和单位]]></title>
    <url>%2F2018%2F08%2F12%2F%E3%80%90CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%80%BC%E5%92%8C%E5%8D%95%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[在利用CSS能做的几乎所有工作中，其基础都是单位(units)，这是影响所有属性的颜色、距离和大小的一种元素，本章就要讨论单位。如果没有单位，就不能声明某个段落应当是紫色，或者某个图像周围应当有10像素的空白，也不能声明一个标题的文本应当是某种大小。 长度单位所有长度单位都可以表示为整数或实数，其后跟有一个两字母缩写，它表示所指定的具体长度单位，如in（英寸）或px（像素）。0后不需要跟单位 这些单位划归为两类，绝对长度单位和相对长度单位 绝对长度单位英寸（in）／厘米（cm）／毫米（mm）／点（pt）／派卡（pc） 处理绝对长度：根据单位英寸像素数（ppi）与现实世界比例拉伸。在打印文档时更为有用，在Web设计中试图使用绝对长度单位不是最佳做法 相对长度单位em／ex／px em和ex单位1“em”定义为一种给定字体的font-size值，这个值可能随元素的不同而不同 12345h1 &#123;font-size: 24px;&#125;h2 &#123;font-size: 18px;&#125;h3 &#123;font-size: 14px;&#125;h1, h2, h3 &#123;margin-left: 1em;&#125; //24px 18px 14px “ex”是指所用字体中小写x的高度 像素长度无法调整文本大小，“em”可以。但非常适合度量图像大小。 为什么像素定义为相对长度呢：CSS规范建议如果一个显示类型的设置与96ppi截然不同，用户代理应当把像素度量缩放成一种“参考像素”进行重新缩放。 如何取舍根据上述所有问题，最好的度量可能是相对度量“em”，如果合适也可以使用“px”。总的来说em是最灵活的，因为它随字体大小缩放，元素和元素操作都能更为一致；对于元素的其他方面，可能更适合使用像素，如元素的边框或定位。 URL语法：url(protocol://server/pathname)或url(pathname)，例导入外部样式表： 12@import url(sheet.css) //使用相对地址导入外部样式表body &#123;background: url(images/pictures2.jpg);&#125; //使用背景图片 关键字有一个值需要某个词来描述，这种词就称为关键词。如果一个属性接受关键字，那么其关键字只针对对该属性的作用域定义。如果两个属性都使用同一个词作为关键字，一个属性的关键字与另一个属性的统一关键字就可能有不同行为（normal对letter-spacing和font-style）。 inherit：所有属性共有的，是一个属性的值与其父元素的值相同。多数情况下不必指定，大多数属性会自然地继承。 小结单位和值的覆盖面很广，从长度单位到描述效果（如underline）的特色关键字，再到颜色单位，还包括文件（如图像）的位置。 这些单位都各有优缺点，这取决于它们在什么场合下使用，我们已经了解了这样一些环境，本书余下的内容将重点讨论这些场合，首先从CSS属性开始，CSS属性描述了如何改变文本的显示方式]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSS权威指南】第三章学习笔记：结构和层叠]]></title>
    <url>%2F2018%2F08%2F12%2F%E3%80%90CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BB%93%E6%9E%84%E5%92%8C%E5%B1%82%E5%8F%A0%2F</url>
    <content type="text"><![CDATA[第2章介绍了如何利用文档结构和CSS选择器为元素应用各种丰富的样式。每个合法的文档都会生成一个结构树，了解了这一点，就能根据元素的祖先、属性、兄弟元素等等创建选择器来选择元素。有了这个结构树，选择器才能起作用，这也是CSS另一个重要方面（继承）的核心。 继承是从一个元素向其后代元素传递属性值所采用的机制。确定应当向一个元素应用哪些值时，用户代理不仅要考虑继承,还要考虑声明的特殊性，另外还需要考虑声明本身的来源。这个过程称为层叠，接下来讨论这3种机制之间的关联。 特殊性从章2了解到可以使用多种不同方法选择元素，一个元素可以用多个规格来选择，每个规则都有自己的选择器。如果一个元素有两个或多个冲突的属性声明，用户代理通过计算特殊性决定哪个声明胜出 选择器的特殊性由选择器本身的组件确定 规则 特殊性值 内联样式 1,0,0,0 选择器中给定的ID属性值 0,1,0,0 选择器中给定的各个类属性值、属性选择或伪类 0,0,1,0 选择器中给定的各个元素和伪元素 0,0,0,1 结合符、通配选择器 0,0,0,0 重要声明声明的结束分号前插有!important的声明，没有特殊的特殊性值，与非重要声明分开考虑。但一个重要声明和一个非重要声明冲突，重要声明总是胜出 继承继承机制，样式不仅应用到指定的元素，还会应用到它的后代元素（有些属性不能继承：如大多数框模型属性） 继承的值没有特殊性（不同于通配符的0特殊性，0特殊性强于没有特殊性），例： 1&lt;h1 id="page-title"&gt;Meerkat&lt;em&gt;Central&lt;/em&gt;&lt;/h1&gt; 12* &#123;color: gray;&#125;h1#page-title &#123;color: black;&#125; “Central”颜色会是灰色，因为em元素获得的h1元素继承值没有特殊性 层叠特殊性相等的多个规则应用于同一个元素如何解决冲突：层叠规则 找出所有相关规则，这些规则都包含一个与给定元素匹配的选择器 按权重和来源排序：从大到小 读者的重要声明 创作人员的重要声明 创作人员的正常声明 读者的正常声明 用户代理声明 按特殊性排序：权重来源相同，特殊性大的优先 按顺序排序：权重、来源、特殊性均相同，最后出现的规则优先 非CSS表现提示：文档可能包含一些非CSS表现提示如font元素。其被处理的特殊性为0并出现在创作人员样式表的最前面，只要有创作人员或读者样式就会被覆盖 小结层叠样式表最基本的一个方面就是层叠了——冲突的声明要通过这个层叠过程排序，并由此确定最终的文档表示。这个过程的核心是选择器及其相关声明的特殊性，以及继承机制 在下一章中，将介绍多种用于为属性值提供含义的单位。就能清楚地了解全部基础知识，并做好进一步学习指定文档样式的属性的准备]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSS权威指南】第二章学习笔记：选择器]]></title>
    <url>%2F2018%2F08%2F12%2F%E3%80%90CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[CSS的主要优点之一（特别对于设计人员来说），就是它能很容易地向所有同类型的元素应用一组样式。利用CSS能更容易地完成一些全局性的修改。所以下面来介绍选择器与结构。 基本规则例 为了使所有h2显示为灰色，没有CSS的情况，需要给每一个h2元素插入font元素： 1&lt;h2&gt;&lt;font color="gray"&gt;This is h2 text&lt;font&gt;&lt;/h2&gt; 利用CSS规则： 1h2 &#123;color: gray;&#125; 规则结构 声明 关键字规则的结构： 1选择器 &#123;声明块&#125; 声明块由一个或多个声明构成，声明的结构： 1属性: 值; 几乎在所有情况下，值要么是一个关键字，要么是该属性可取关键字的一个列表（包含一个或多个关键字），关键字之间用空格分隔 分组选择器分组：为多个元素应用同一个声明 1h1, h2 ,h3 &#123;color: gray;&#125; 声明分组：为元素一次应用多个声明 1234h1 &#123; color: gray; font: 18px Helvetica;&#125; 结合两种分组 1234h1, h2 ,h3 &#123; color: gray; font: 18px Helvetica; &#125; 元素选择器选择器直接指示文档元素： 1h1 &#123;color: gray;&#125; 类选择器和ID选择器独立于元素进行选择，实际是对具体属性（class/id）的属性值进行选择 类选择器类选择器使用“.”引用元素class属性中的值 12&lt;p class="warning"&gt;the possibility of implosion is very real!&lt;/p&gt;&lt;p&gt;the possibility of &lt;span class="warning"&gt;implosion&lt;/span&gt; is very real!&lt;/p&gt; 12.warning &#123;color: red;&#125; //class属性值包含warning的元素字体为红p.warning &#123;font-weight: bold;&#125; //class属性值包含warning的p元素字体加粗 多类选择器class值包含一个词列表，类选择器也可链接多个（顺序不限制），意为class中同时包含链接词的元素 1.warning.help &#123;color: red;&#125; //class值同时包含warning和help的元素前景色为红色 ID选择器类选择器使用“#”引用元素id属性中的值 类选择器还是ID选择器 类选择器 ID选择器 多个元素指定为同一类且文档可含多个 指定一个元素且一个文档只使用一次 可以链接使用 不可以链接使用（id属性不支持词列表） 属性选择器独立于元素进行选择，对属性及属性值进行选择 简单属性选择选择包含某个属性的元素 123[title] &#123;bolder: 3px solid red;&#125;img[alt] &#123;bolder: black;&#125;a[href][title] &#123;font-weight: bold;&#125; 根据具体属性值选择选择包含某个具体属性值的元素 1p[class="warning"] &#123;font-weight: bold;&#125; 根据部分属性值选择如果属性能接受词列表（词之间用空格分隔），可以根据其中任意一个词进行选择 1p[class～="warning"] &#123;font-weight: bold;&#125; 类型 描述 [foo~=”bar”] 选择foo属性值包含“bar”的所有元素 [foo^=”bar”] 选择foo属性值以“bar”开头的所有元素 [foo$=”bar”] 选择foo属性值以“bar”结尾的所有元素 [foo*=”bar”] 选择foo属性值包含子串“bar”的所有元素 特定属性选择一般的，[att|=”val”]可以用于任何属性及其值 1*[lang|="en"] &#123;color: red;&#125; 最常见用语匹配语言值，本章后面还会介绍 使用文档结构理解父子结构父子结构是祖先-后代关系的特例 后代选择器（上下文选择器）在后代选择器中，规则左边的选择器一端包含两个或多个用空格结合符分隔的左到右有祖先-后代关系的选择器 1h1 em &#123;color: red;&#125; //h1元素的所有子孙em元素 选择子元素不希望选择任一一个后代，缩小范围只想选择一个元素的子元素，使用子结合符，即大于号（&gt;） 1p &gt; span &#123;color: red;&#125; //p元素的所有儿子span元素 选择相邻兄弟元素想选择一个元素后紧接的兄弟元素，使用相邻兄弟结合符，即加号（+） 1h1 + p &#123;color: red;&#125; //h1后的所有p元素，且和h1元素同父元素 伪类和伪元素伪元素为文档中“不一定存在的结构”指定样式 伪类为某些元素（甚至文档本身）的状态所指示的幻想类指定样式 伪类选择器伪类选择器使用“:”引用元素伪类 考虑锚元素（a），基本上有两种锚类型：已访问的和未访问的。这些类型称为伪类，使用这些伪类的选择器称为伪类选择器 链接伪类： 伪类名 描述 :link 指示作为超链接（即有一个href属性）并指向一个未访问地址的所有锚 :visited 指示作为已访问地址超链接的锚 动态伪类 伪类名 描述 :hover 指示鼠标指针停留在哪个元素上 :active 指示被用户输入激活的元素 动态伪类可能带来一些实际问题：引起文档重绘 选择第一个子元素1p:fisrt-child &#123;color: red;&#125; //作为第一个子元素的所有p元素（看起来像给这个p元素加上了一个名为“fisrt-child”的类） 根据语言选择:lang()伪类选择器类似|=属性选择器，主要差别在于语言信息可以从很多来源得到，不一定只有lang属性中，伪类选择器更健壮 1:lang(fr) &#123;font-style: italic;&#125; //选择语言为法语的元素 伪元素选择器就像伪类为锚指定幻想类一样，伪元素能够在文档中插入假想元素 设置首字母样式1p:first-letter &#123;color: red;&#125; //为所有p元素的第一个字母设为红色（看起来像为p元素内容的第一个字母套上了"&lt;first-letter&gt;"元素） 设置第一行样式1p:first-line &#123;color: red;&#125; //为所有p元素的第一行设为红色（看起来像为p元素内容的第一个行套上了"&lt;first-line&gt;"元素） 设置之前和之后的样式12h2:before &#123;content: "&#125;"; color: silver&#125; //在每个h2元素前加一个银色中括号body:after &#123;content: "The End.";&#125; //给文档末尾加一个结束语 小结通过根据文档的内容来使用选择器，创作人员可以创建丰富的CSS规则。可以对少量元素或大量元素应用简单规则，还可以对规则和选择器分组使得样式表简洁灵活，缩短文件大小和下载时间 要正确理解选择器以及如何组合选择器，需要深入地掌握选择器和文档结构的关系，并了解继承和层叠机制在确定如何为元素设置样式时有怎样的作用。这正是下一章要讨论的内容]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSS权威指南】第一章学习笔记：CSS和文档]]></title>
    <url>%2F2018%2F08%2F12%2F%E3%80%90CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%91%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9ACSS%E5%92%8C%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[Cascading Style Sheets (CSS) 是一个能够变换文档和文档集合呈现方式的强大工具，它几乎已经扩展到 web 的每个角落，包括许多看起来不是 web 环境的地方。例如，基于 Gecko1 的浏览器通过 CSS 影响 chrome 浏览器自身的呈现，许多 RSS 客户端允许你将 CSS 应用于推送内容，一些即时通讯客户端使用 CSS 来变换聊天窗口。JavaScript 框架（如 jQuery ）甚至 JavaScript 本身所使用的语法中，都有 CSS 的踪迹。它无处不在！ Web的衰落一片混乱 非结构化页面建立索引困难 非结构化降低访问性 高级页面表现只能应用结构化 结构化更易维护 CSS作救星丰富的样式易于使用在多个页面使用样式：引用层叠：冲突规则缩减文件大小：更少的元素为将来做准备：去除样式元素元素元素是文档结构的基础；每个元素生成一个框（box，也称为盒） 替换和非替换元素替换元素：替换元素内容的部分并非由文档内容直接表示 非替换元素：其内容由用户代理（通常为一个浏览器）在元素本身生成的框中显示 元素显示角色块级元素：生成一个元素框默认填满父元素的内容区（理解：在元素框前后生成“分隔符”） 行内元素：在一个文本行内生成元素框 display其他值：章2、7详细讨论 结合CSS和HTML@import指令用于导入外部样式表，放在元素中，所有其他CSS规则之前。 1@import url(sheet.css) link元素用于导入外部样式表，必须放在head元素中 1&lt;link rel="stylesheet" type="text/css" href="xxxx.css" /&gt; 候选样式表： 候选样式表的rel属性值设为“alternate alternate”即可在浏览器中选择不同样式表显示，值为“Default”的为首选样式表 123&lt;link rel="stylesheet" type="text/css" href="xxxx1.css" title="Default" /&gt;&lt;link rel="alternate alternate" type="text/css" href="xxxx2.css" title="Big Test!" /&gt;&lt;link rel="alternate alternate" type="text/css" href="xxxx3.css" title="Crazy colors!" /&gt; style元素文档样式表直接嵌套在文档之中 1&lt;style type="text/css"&gt;&lt;/style&gt; 内联样式放在元素开元素style属性中，为单个元素指定样式，不需要嵌套和外部样式表 1&lt;p style="color:gray;"&gt;嘻嘻嘻&lt;/p&gt; 具体的样式规则见章2 CSS注释1/*this is a comment*/ 小结利用CSS，可能会完全改变用户代理表现元素的方式。用户不会知道是通过外部样式表还是嵌套样式表甚至是内联样式完成的。外部样式真正的意义在于，它允许创作人员将网站的所有表现信息都放在同一个位置，将所有文档都指向这个位置。这使得网络的更新和维护变得容易，还有助于节省带宽，因为文档中去除了表现信息 为了充分利用CSS的强大功能，创作人员需要了解如何将一组样式与文档中的元素相关联。CSS以何种方式选择文档中要应用样式的部分，这正是下一章的主题]]></content>
      <categories>
        <category>前端</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>

<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>【JavaScript权威指南】面向对象的程序设计 | 一零</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">【JavaScript权威指南】面向对象的程序设计</h1><a id="logo" href="/.">一零</a><p class="description">慢速成长中</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">【JavaScript权威指南】面向对象的程序设计</h1><div class="post-meta">Aug 25, 2018<span> | </span><span class="category"><a href="/categories/前端/">前端</a><a href="/categories/前端/读书笔记/">读书笔记</a></span></div><div class="post-content"><p>本章内容：</p>
<ul>
<li>理解对象属性</li>
<li>理解并创建对象</li>
<li>理解继承</li>
</ul>
<p>面向对象的语言有一个标志，那就是它们都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。前面提到过，ECMAScript中没有类的概念，因此它的对象也与基于类的语言中的对象有所不同。</p>
<p>ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因），我们可以把ECMAScript的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数。</p>
<p>每个对象都是基于一个引用类型创建的，这个引用类型可以是第5章讨论的原生类型，也可以是开发人员定义的类型。<a id="more"></a></p>
<h2 id="6-1-理解对象"><a href="#6-1-理解对象" class="headerlink" title="6.1 理解对象"></a>6.1 理解对象</h2><p>上一章介绍过，创建自定义对象最简单的方式就是创建一个Object的实例，然后再为它添加属性和方法；对象字面量创建对象更为常用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br><span class="line">person.jon = <span class="string">"Software Engineer"</span>;</span><br><span class="line"></span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"Software Engineer"</span>,</span><br><span class="line">    </span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>person对象包含一些属性和方法。这些属性在创建时都带有一些“特征值”，JavaScript通过这些特征值来定义它们的行为</p>
<h3 id="6-1-1-属性类型"><a href="#6-1-1-属性类型" class="headerlink" title="6.1.1 属性类型"></a>6.1.1 属性类型</h3><p>ECMA-262描述了属性的各种特征的【特性】，属于内部特性，在JavaScript中不能直接访问它们。ECMAScript中有两种属性：数据属性和访问器属性</p>
<p>1、数据属性</p>
<p>数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性：</p>
<ul>
<li>[[Configurable]]：表示能否通过delete删除属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性的默认值时true；</li>
<li>[[Enumerable]]：表示能否通过for-in循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性的默认值时true；</li>
<li>[[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性的默认值时true；</li>
<li>[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置度；写入属性值的时候，把新值保存在这个位置。这个特性的默认值是undefined。</li>
</ul>
<p>要修改属性的默认的特性，必须使用ECMAScript5的Object.defineProperty()方法。这个方法接收三个参数Object.defineProperty(属性所在的对象，属性的名字，描述符对象)，描述符对象的属性必须是：configurable、enumerable、writable和value</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</span><br><span class="line">    writeble:<span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(person.name);    <span class="comment">//"Nicholas"</span></span><br><span class="line">person.name=<span class="string">"Greg"</span>;</span><br><span class="line">alert(person.name)    <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>
<p>2、访问器属性</p>
<p>访问器属性不包含数据值；它们包含一对儿getter和setter函数（不过，这两个函数都不是必须的）。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性：</p>
<ul>
<li>[[Configurable]]：表示能否通过delete删除属性，能否修改属性的特性，或者能否把属性修改为访问器属性。对于直接在对象上定义的属性，它们的这个特性的默认值是true；</li>
<li>[[Enumerable]]：表示能否通过for-in循环返回属性。对于直接在对象上定义的属性，它们的这个特性的默认值是true；</li>
<li>[[Get]]：在读取属性时调用的函数。默认值为undefined；</li>
<li>[[Set]]：在写入属性时调用的函数。默认值为undefined。</li>
</ul>
<p>访问器属性不能直接定义，必须使用Object.defineProperty()方法来定义。示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    _year: <span class="number">2004</span>,    <span class="comment">//"_"常用来表示只能通过对象方法访问的属性</span></span><br><span class="line">    edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;    <span class="comment">//访问器属性“year”</span></span><br><span class="line">    get: funtion()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: funtion()&#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>._year = newValue;</span><br><span class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition);    <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>以上是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化</p>
<h3 id="6-1-2-定义多个属性"><a href="#6-1-2-定义多个属性" class="headerlink" title="6.1.2 定义多个属性"></a>6.1.2 定义多个属性</h3><p>ECMAScript5定义一个defineProperties()方法，利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：defineProperties(要添加和修改其属性的对象，往第一个对象中要添加和修改的属性)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">    _year: &#123;    <span class="comment">//数据属性</span></span><br><span class="line">        value: <span class="number">2004</span>,</span><br><span class="line">        writable: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition: &#123;    <span class="comment">//数据属性</span></span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year: &#123;    <span class="comment">//访问器属性</span></span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>._year = newValue;</span><br><span class="line">                <span class="keyword">this</span>.edition += newValue <span class="number">-2004</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="6-1-3-读取属性的特性"><a href="#6-1-3-读取属性的特性" class="headerlink" title="6.1.3 读取属性的特性"></a>6.1.3 读取属性的特性</h3><p>ECMAScript5中Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、writable和value：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">    _year: &#123;    <span class="comment">//数据属性</span></span><br><span class="line">        value: <span class="number">2004</span>,</span><br><span class="line">        writable: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition: &#123;    <span class="comment">//数据属性</span></span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year: &#123;    <span class="comment">//访问器属性</span></span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>._year = newValue;</span><br><span class="line">                <span class="keyword">this</span>.edition += newValue <span class="number">-2004</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"_year"</span>);</span><br><span class="line">alert(descriptor.value);    <span class="comment">//2004</span></span><br><span class="line">alert(descriptor.configurable);    <span class="comment">//false</span></span><br><span class="line">alert(descriptor.get);    <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"year"</span>);</span><br><span class="line">alert(descriptor.value);    <span class="comment">//undefined</span></span><br><span class="line">alert(descriptor.configurable);    <span class="comment">//false</span></span><br><span class="line">alert(descriptor.get);    <span class="comment">//"function"</span></span><br></pre></td></tr></table></figure>
<h2 id="6-2-创建对象"><a href="#6-2-创建对象" class="headerlink" title="6.2 创建对象"></a>6.2 创建对象</h2><p>虽然Object构造函数或对象字面量都可以用来创建单个对象，但是这些方式有明显的缺点：使用同一个接口创建很多对象，会产生大量重复代码。为解决这个问题，人们开始使用工厂模式的一种变体</p>
<h3 id="6-2-1-工厂模式"><a href="#6-2-1-工厂模式" class="headerlink" title="6.2.1 工厂模式"></a>6.2.1 工厂模式</h3><p>工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。考虑到ECMAScript中无法创建类，开发人员救发明了一种函数，用函数来封装以特定接口创建对象的细节：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name=name;</span><br><span class="line">    o.age=age;</span><br><span class="line">    o.job=job;</span><br><span class="line">    o.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1=createPerson(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2=createPerson(<span class="string">"Greg"</span>,<span class="number">27</span>,<span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>
<p>函数createPerson能根据接收的参数来构建一个包含所有必要信息的Person对象。每次返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（如何知道对象的类型）</p>
<h3 id="6-2-2-构造函数模式"><a href="#6-2-2-构造函数模式" class="headerlink" title="6.2.2 构造函数模式"></a>6.2.2 构造函数模式</h3><p>前几章介绍过ECMAScript中的构造函数可以用来创建特定类型的对象。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。此外也可以自定义构造函数，从而定义自定义对象类型的属性和方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.job=job;</span><br><span class="line">    <span class="keyword">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>,<span class="number">27</span>,<span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>
<p>要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历以下4个步骤：</p>
<p>1、创建一个新对象；</p>
<p>2、将构造函数的作用域赋给新对象（因此这个this指向了这个新对象）</p>
<p>3、执行构造函数中的代码（为这个新对象添加属性）</p>
<p>4、返回新对象</p>
<p>在前面例子的最后，person1和person2分别保存着Person的一个不同实例。这两个对象都有一个constructor（构造函数）属性，该属性指向Person</p>
<p>创建自定义的构造函数意味着可以使用其示例标识为一种特定的类型，工厂模式就不行</p>
<h4 id="1、将构造函数当作函数"><a href="#1、将构造函数当作函数" class="headerlink" title="1、将构造函数当作函数"></a>1、将构造函数当作函数</h4><p>构造函数和其他函数的唯一区别就是调用方式不同。任何函数只要通过new操作符调用，它就可以作为构造函数；任何函数只要不通过new操作符调用，它就跟普通函数没有什么区别</p>
<h4 id="2、构造函数的问题"><a href="#2、构造函数的问题" class="headerlink" title="2、构造函数的问题"></a>2、构造函数的问题</h4><p>每个方法都要在每个实例上重新创建一遍</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.job=job;</span><br><span class="line">    <span class="keyword">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    <span class="comment">//等于this.sayName = new Function(" alert(this.name);")</span></span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>,<span class="number">27</span>,<span class="string">"Doctor"</span>);</span><br><span class="line"></span><br><span class="line">alert(person1.sayName==person2.sayName)    <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-3-原型模式"><a href="#6-2-3-原型模式" class="headerlink" title="6.2.3 原型模式"></a>6.2.3 原型模式</h3><p>每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有示例所共享的属性和方法。即prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处就是可以让所有对象实例共享它所包含的属性和方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name=<span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age=<span class="number">29</span>;</span><br><span class="line">Person.prototype.job=<span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();    <span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();    <span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line">alert(person1.sayName==person2.sayName)    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>所有的属性和方法都直接添加到Person的prototype属性中，构造函数成了空函数。新对象的属性和方法是所有实例共享的。要理解原型模式的原理，先要了解原型对象的性质：</p>
<h4 id="1、理解原型对象"><a href="#1、理解原型对象" class="headerlink" title="1、理解原型对象"></a>1、理解原型对象</h4><p>无论什么时候只要创建了一个新函数，就会为（自动）该函数创建一个prototype属性，这个属性指向新函数的原型对象。默认情况下，所有原型对象都会自动获得一个constructor属性，包含一个指向 <code>指向自己的 prototype属性 所在的函数</code> 的指针</p>
<p>虽然这两个实例都不包含属性和方法，但我们却可以调用person1.sayName()，这是通过查找对象属性的过程来实现的。虽然在所有实现中都无法访问到[[prototype]]，但是可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系。ECMAScript5中新增了Object.getPrototypeOf()返回[[prototype]]的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(Person.isPrototypeOf(person1));    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1)==Person.prototype);    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>hasOwnProperty()方法可以检测一个属性是否存在【实例】中</p>
<h4 id="2、原型与in操作符"><a href="#2、原型与in操作符" class="headerlink" title="2、原型与in操作符"></a>2、原型与in操作符</h4><p>in操作符只要能访问到的属性就返回true，如果in操作符返回true，hasOwnProperty()方法返回false，则可以判断属性在原型中</p>
<p>使用for-in循环返回的是所有能够通过对象访问的、可枚举的属性；ECMAScript5中新增了Object.keys()方法返回一个对象里所有可枚举属性组成的数组；hasOwnPropertyNames()方法返回所有属性，不管可不可以枚举</p>
<h4 id="3、更简单的原型语法"><a href="#3、更简单的原型语法" class="headerlink" title="3、更简单的原型语法"></a>3、更简单的原型语法</h4><p>用一个包含所有属性和方法的对象字面量</p>
<h4 id="4、原型的动态性"><a href="#4、原型的动态性" class="headerlink" title="4、原型的动态性"></a>4、原型的动态性</h4><p>对原型对象所做的任何修改，都能立即从实例上反映出来</p>
<h4 id="5、原生对象的原型"><a href="#5、原生对象的原型" class="headerlink" title="5、原生对象的原型"></a>5、原生对象的原型</h4><p>原型模式的重要性不仅体现在自定义类型方面，原生的引用类型，都是采用这种模式船舰的。所有原生引用类型（Object、Array、String等）都在其构造函数的原型上定义了方法</p>
<h4 id="6、原型对象的问题"><a href="#6、原型对象的问题" class="headerlink" title="6、原型对象的问题"></a>6、原型对象的问题</h4><p>省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下取得相同的属性值，和</p>
<p>1、包含引用类型的值的原型属性被共享</p>
<p>2、创建子类型的实例时，不能向超类型的构造函数传递参数</p>
<h3 id="6-2-4-组合使用构造函数模式和原型模式"><a href="#6-2-4-组合使用构造函数模式和原型模式" class="headerlink" title="6.2.4 组合使用构造函数模式和原型模式"></a>6.2.4 组合使用构造函数模式和原型模式</h3><p>组合使用构造函数模式和原型模式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.job=job;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype&#123;</span><br><span class="line">    constuctor: Person,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>,<span class="number">27</span>,<span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="6-2-5-动态原型模型"><a href="#6-2-5-动态原型模型" class="headerlink" title="6.2.5 动态原型模型"></a>6.2.5 动态原型模型</h3><p>封装构造函数和原型，通过把所有信息都封装在构造函数中，在构造函数中初始化原型（仅在必要情况下），又保持了同时使用构造函数和原型的优点</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.job=job;</span><br><span class="line">    <span class="keyword">if</span>(typeOf(<span class="keyword">this</span>.sayName != <span class="string">"undefined"</span>))&#123;</span><br><span class="line">        Person.prototype.sayName= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-6-寄生构造函数模式"><a href="#6-2-6-寄生构造函数模式" class="headerlink" title="6.2.6 寄生构造函数模式"></a>6.2.6 寄生构造函数模式</h3><p>其实寄生构造函数就是在原生构造函数上的一个扩展，也就是你可以利用寄生构造函数来自定义一种引用类型，实现自己想要达到的效果</p>
<h3 id="6-2-7-稳妥构造函数模式"><a href="#6-2-7-稳妥构造函数模式" class="headerlink" title="6.2.7 稳妥构造函数模式"></a>6.2.7 稳妥构造函数模式</h3><p>所谓稳妥对象， 指的是<strong>没有公共属性</strong>， 而且其方法也不引用this的对象。稳妥对象函数遵循与寄生构造函数类似的模式， 但有两点不同： 一是新创建对象的实例方法不引用this； 二是不使用new操作符调用构造函数。</p>
<p>最近在浏览博客时发现很多人好像理解错这个稳妥构造函数了， 这个函数与在《javascript 高级程序设计》中提到的其他构造函数的一大特点在于可以利用js作用域实现<strong>私有变量化</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Process</span> (<span class="params">nameF</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="keyword">var</span> name = nameF;<span class="comment">//1</span></span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(name);<span class="comment">//2</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = Process(<span class="string">'Nick'</span>);</span><br><span class="line">friend.sayName();  <span class="comment">//"Nick"</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.name);<span class="comment">//undefined//3</span></span><br></pre></td></tr></table></figure>
<p>注意： （以下3点）</p>
<ol>
<li><p>在稳妥构造函数中变量不能挂到要返回的对象o中</p>
</li>
<li><p>在稳妥构造函数中的自定义函数操作元素时使用不要用this</p>
</li>
<li><p>在函数外部使用稳妥构造函数时不用new。</p>
</li>
</ol>
<h2 id="6-3-继承"><a href="#6-3-继承" class="headerlink" title="6.3 继承"></a>6.3 继承</h2><p>由于函数没有签名，在ECMAScript中无法实现接口继承，只支持实现继承，而且其实现继承主要是依靠原型链来实现的</p>
<h3 id="6-3-1-原型链"><a href="#6-3-1-原型链" class="headerlink" title="6.3.1 原型链"></a>6.3.1 原型链</h3><p>使用一个原型的实例作为另一个函数的原型</p>
<h4 id="1、别忘记默认的原型"><a href="#1、别忘记默认的原型" class="headerlink" title="1、别忘记默认的原型"></a>1、别忘记默认的原型</h4><h4 id="2、确定原型与实例的关系"><a href="#2、确定原型与实例的关系" class="headerlink" title="2、确定原型与实例的关系"></a>2、确定原型与实例的关系</h4><p>instanceof操作符，isPrototypeOf()方法</p>
<h4 id="3、谨慎地定义方法"><a href="#3、谨慎地定义方法" class="headerlink" title="3、谨慎地定义方法"></a>3、谨慎地定义方法</h4><p>给原型添加方法的代码一定要放在替换原型的语句之后</p>
<h4 id="4、原型链的问题"><a href="#4、原型链的问题" class="headerlink" title="4、原型链的问题"></a>4、原型链的问题</h4><p>1、包含引用类型的值的原型属性被共享</p>
<p>2、创建子类型的实例时，不能向超类型的构造函数传递参数</p>
<h3 id="6-3-2-借用构造函数"><a href="#6-3-2-借用构造函数" class="headerlink" title="6.3.2 借用构造函数"></a>6.3.2 借用构造函数</h3><p>也称为伪造对象或经典继承。在子类型构造函数的内部调用超类型构造函数（使用apply()和call()）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>,<span class="string">"Nicholas"</span>);    <span class="comment">//继承了SuperType还传递了参数</span></span><br><span class="line">    <span class="keyword">this</span>.age=<span class="number">29</span>;    <span class="comment">//实例属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存在的问题：方法都在构造函数中定义，函数复用无从谈起</p>
<h3 id="6-3-3-组合继承"><a href="#6-3-3-组合继承" class="headerlink" title="6.3.3 组合继承"></a>6.3.3 组合继承</h3><p>也叫伪经典继承，即原型链+构造函数。使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承</p>
<h3 id="6-3-4-原型式继承"><a href="#6-3-4-原型式继承" class="headerlink" title="6.3.4 原型式继承"></a>6.3.4 原型式继承</h3><h3 id="6-3-5-寄生式继承"><a href="#6-3-5-寄生式继承" class="headerlink" title="6.3.5 寄生式继承"></a>6.3.5 寄生式继承</h3><h3 id="6-3-6-寄生组合式继承"><a href="#6-3-6-寄生组合式继承" class="headerlink" title="6.3.6 寄生组合式继承"></a>6.3.6 寄生组合式继承</h3><h2 id="6-4-小结"><a href="#6-4-小结" class="headerlink" title="6.4 小结"></a>6.4 小结</h2></div><div class="tags"><a href="/tags/JavaScript/">JavaScript</a></div><div class="post-nav"><a class="pre" href="/2018/08/25/ES5和ES6的继承/">ES5和ES6的继承</a><a class="next" href="/2018/08/25/【JavaScript权威指南】变量、作用域和内存问题/">【JavaScript权威指南】变量、作用域和内存问题</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'zmysb',
  repo: 'zmysb.github.io',
  oauth: {
    client_id: '0c1d3880d2ff18d6d737',
    client_secret: '93e80999306a8023541f9317b8e2db01e454583c',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/前端/读书笔记/">读书笔记</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/影评/" style="font-size: 15px;">影评</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/Javascript/" style="font-size: 15px;">Javascript</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/03/09/刷题啦/">刷题啦</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/03/【你不知道的JavaScript中】/">【你不知道的JavaScript中】</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/【你不知道的JavaScript上】/">【你不知道的JavaScript上】</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/深入浅出React和Redux/">深入浅出React和Redux</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/【JavaScript权威指南】新兴的API/">【JavaScript权威指南】新兴的API</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/【JavaScript权威指南】最佳实践/">【JavaScript权威指南】最佳实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/【JavaScript权威指南】离线应用与客户端存储/">【JavaScript权威指南】离线应用与客户端存储</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/【JavaScript权威指南】高级技巧/">【JavaScript权威指南】高级技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/【JavaScript权威指南】Ajax与Comet/">【JavaScript权威指南】Ajax与Comet</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/【JavaScript权威指南】JSON/">【JavaScript权威指南】JSON</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://weibo.com/u/3837485237?refer_flag=1001030101_&amp;is_all=1" title="广告位 一" target="_blank">广告位 一</a><ul></ul><a href="https://weibo.com/u/3837485237?refer_flag=1001030101_&amp;is_all=1" title="广告位 二" target="_blank">广告位 二</a><ul></ul><a href="https://weibo.com/u/3837485237?refer_flag=1001030101_&amp;is_all=1" title="广告位 三" target="_blank">广告位 三</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">一零.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
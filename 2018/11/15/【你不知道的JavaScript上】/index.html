<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>【你不知道的JavaScript上】 | 一零</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">【你不知道的JavaScript上】</h1><a id="logo" href="/.">一零</a><p class="description">慢速成长中</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">【你不知道的JavaScript上】</h1><div class="post-meta">Nov 15, 2018<span> | </span><span class="category"><a href="/categories/前端/">前端</a><a href="/categories/前端/读书笔记/">读书笔记</a></span></div><div class="post-content"><h2 id="第一部分-作用域和闭包"><a href="#第一部分-作用域和闭包" class="headerlink" title="第一部分 作用域和闭包"></a>第一部分 作用域和闭包</h2><h3 id="第一章-作用域是什么"><a href="#第一章-作用域是什么" class="headerlink" title="第一章 作用域是什么"></a>第一章 作用域是什么</h3><p>一套设计良好的规则：存储变量，和在哪里找到这些变量。</p>
<h4 id="1-1-编译原理"><a href="#1-1-编译原理" class="headerlink" title="1.1 编译原理"></a>1.1 编译原理</h4><p>尽管JavaScript归类为“动态”或“解释执行语言”，但事实上它是一门编译语言。</p>
<p>传统编译语言（提前编译）执行前的编译（静态）有三步：</p>
<ul>
<li>分词/词法分析：将字符组成的字符串（如var a = 2;）分解成有意义的代码块（var、a、=、2、;），这种代码块被称为词法单元（token）；</li>
<li><p>解析/语法分析：将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树(AST，<a href="https://segmentfault.com/a/1190000016231512" target="_blank" rel="noopener">示例讲解</a>)”（var a = 2;的抽象语法树可能有一个叫做VariableDeclaretion的顶级节点，接下来是一个叫做Identifier（它的值是a）的子节点，以及一个叫做AssignmentExpression的子节点。AssignmentExpression节点有一个叫做NumericLiteral（它的值是2）的子节点）；</p>
</li>
<li><p>代码生成：将AST转换为可执行代码的过程被称为代码生成，这个过程与语言、目标平台等息息相关（抛开具体细节，简单来说就是有某种方法可以将var a=2;的AST转化为一组机器指令，用来创建一个叫做a的变量（包括分配内存等），并将一个值储存在a中）。</p>
</li>
</ul>
<p>JavaScript的编译不是发生在构建前，是在执行前几微秒甚至更短，其引擎要更加复杂比如在语法分析和代码生成阶段有特定步骤对性能进行优化；简单地说，任何JavaScript代码片段在执行前都要进行编译（通常就在执行前）（JavaScript编译器首先会对var a = 2;进行编译，然后做好执行它的准备，并且通常马上就会执行它）。</p>
<h4 id="1-2-理解作用域"><a href="#1-2-理解作用域" class="headerlink" title="1.2 理解作用域"></a>1.2 理解作用域</h4><ul>
<li>引擎：从头到尾负责整个JavaScript程序的编译及执行过程</li>
<li>编译器：负责语法分析及代码生成</li>
<li>作用域：负责收集并维护所有申明的标志符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标志符的访问权限</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有申明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它进行赋值。</p>
<p>编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量a来判断它是否已经声明过。查找的过程由作用域进行协助，但引擎执行怎样的查找，会影响最终的查找结果。</p>
<ul>
<li>LHS查询：赋值操作的目标是谁（找到变量容器本身）</li>
<li>RHS查询：谁是赋值操作的源头（查找到某个变量的值）</li>
</ul>
<h4 id="1-3-作用域嵌套"><a href="#1-3-作用域嵌套" class="headerlink" title="1.3 作用域嵌套"></a>1.3 作用域嵌套</h4><p>上文说过：作用域是根据名称查找变量的一套规则。实际情况中，通常要同时顾及几个作用域（ES5中<del>没有</del>（不绝对）块级作用域，函数内部是局部作用域，最外层是全局作用域）。</p>
<p>在一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。</p>
<p>遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找（RHS和LHS）过程都会停止。</p>
<h4 id="1-4-异常"><a href="#1-4-异常" class="headerlink" title="1.4 异常"></a>1.4 异常</h4><p>为何区分RHS和LHS呢，因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( a + b );   <span class="comment">//b的第一次查找是RHS</span></span><br><span class="line">    b = a;  <span class="comment">//第二次是LHS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RHS在查询所有嵌套的作用域中遍寻不到所需的变量，引擎就回抛出ReferenceError异常；LHS查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有改名称的变量（非严格模式下）。</p>
<p>接下来，如果RHS查询到一个变量，但你尝试对这个变量进行不合理的操作，比如对一个非函数类型的值进行函数调用，那么引擎会抛出TypeError异常。</p>
<p>总：ReferenceError同作用域判别识别相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或者不合理的。</p>
<h4 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h4><p>作用域是一套规则，用于确定在何处以及如何查找变量（标志符）。如果查找的目的是对变量进行赋值（=操作符或调用函数时传入参数都会导致关联作用域的赋值操作），那么就回使用LHS查询；如果目的是获取变量值，就会使用RHS查询。</p>
<p>JavaScript引擎首先会在代码执行前对其进行编译，在这个过程中，像var a = 2;这样的声明会被分解成两个独立的步骤：</p>
<ul>
<li>首先，var a在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。</li>
<li>接下来，a = 2 会查询（LHS查询）变量a并对其进行赋值。</li>
</ul>
<p>RHS和LHS查询都会在当前执行作用域中开始，如果有需要（没有找到所需的标志符），就会向上级作用域继续查找目标标志符，这样每次上升一级作用域（一层），最后抵达全局作用域（顶层），无论找到没找到都将停止。</p>
<p>不成功的RHS引用会导致抛出ReferenceError异常。不成功的LHS引用会导致自动隐式地创建一个全局变量（非 严格模式下），该变量使用LHS引用的目标作为标志符，或者抛出ReferenceError异常（严格模式下）。</p>
<h3 id="第二章-词法作用域"><a href="#第二章-词法作用域" class="headerlink" title="第二章 词法作用域"></a>第二章 词法作用域</h3><h4 id="2-1-词法阶段"><a href="#2-1-词法阶段" class="headerlink" title="2.1 词法阶段"></a>2.1 词法阶段</h4><p>第一章介绍过，大部分标准语言编译器的第一个工作阶段叫词法化（也叫单词化）。词法化的过程会对源代码中的字符进行检查。这个概念是理解词法作用域及其名称来历的基础。</p>
<p>简单说，词法作用域就是定义在词法阶段的作用域。它在你写代码时将变量和块作用域写在哪里来决定，因此在词法分析器处理代码时，会保持作用域不变（大部分情况下）。</p>
<h6 id="查找"><a href="#查找" class="headerlink" title="查找"></a><strong>查找</strong></h6><p>作用域的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标志符的位置。</p>
<p>作用域查找会在找到第一个匹配的标识符时停止。</p>
<p>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</p>
<p>词法作用域查找只会查找一级标志符，比如foo.bar只会查找foo，找到这个变量之后对象属性访问规则就会接管对bar属性的访问</p>
<h4 id="2-2-欺骗词法"><a href="#2-2-欺骗词法" class="headerlink" title="2.2 欺骗词法"></a>2.2 欺骗词法</h4><p>词法作用域完全由写代码期间函数所声明的位置来定义，在怎样能在运行时“修改”（也可以说欺骗）词法作用域呢？</p>
<h5 id="2-3-1-evel"><a href="#2-3-1-evel" class="headerlink" title="2.3.1 evel"></a>2.3.1 evel</h5><p>eval函数动态插入代码。</p>
<p>如果eval(..)中所执行的代码包含一个或多个声明（无论是变量还是函数），就会对eval(..)所在的词法作用域进行修改。</p>
<p>setTimeout(..)和setInterval(..)、new Function(..)的功能效果与eval类似，它们某个参数可以是字符串，就可以是一段动态生成的函数代码，这种用法要避免使用！</p>
<h5 id="2-3-2-with"><a href="#2-3-2-with" class="headerlink" title="2.3.2 with"></a>2.3.2 with</h5><p>with关键字。</p>
<p>with通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。</p>
<p>with可以将一个没有或者多个属性的对象处理为一个完全隔离的词法作用域，因此对这个对象的属性也会被处理为定义在这个作用域中的词法标志符，其内部存在对变量的引用（LHS）查找失败时，会创建全局变量。</p>
<h5 id="2-3-3-性能"><a href="#2-3-3-性能" class="headerlink" title="2.3.3 性能"></a>2.3.3 性能</h5><p>eval(..)函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而with声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。</p>
<p>JavaScript引擎会在编译阶段进行数项的性能优化。有些优化依赖于根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标志符。</p>
<h4 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h4><p>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标志符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。</p>
<p>JavaScript有两个机制可以“欺骗”词法作用域：eval(..)和with。</p>
<p>这两个机制的副作用是引擎无法在编译时对作用域查找进行优化</p>
<h3 id="第三章-函数作用域和块作用域"><a href="#第三章-函数作用域和块作用域" class="headerlink" title="第三章 函数作用域和块作用域"></a>第三章 函数作用域和块作用域</h3><p>第二章讲了，作用域作为包含标识符（变量、函数）定义的容器，相互嵌套排列，排列的结构是在写代码时定义的。</p>
<p>但是，究竟如何生成一个新的作用域？只有函数可以生成作用域吗？JavaScript中的其他结构能生成作用域气泡吗？</p>
<h4 id="3-1-函数中的作用域"><a href="#3-1-函数中的作用域" class="headerlink" title="3.1 函数中的作用域"></a>3.1 函数中的作用域</h4><p>对于以上疑问，最常见的答案是JavaScript只有基于函数的作用域，并不完全正确。</p>
<p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数范围内使用及复用（事实上在嵌套的作用域中也可以使用）。这种设计方案非常有用，能充分利用JavaScript变量可以根据需要改变值类型的“动态”特性。</p>
<h4 id="3-2-隐藏内部实现"><a href="#3-2-隐藏内部实现" class="headerlink" title="3.2 隐藏内部实现"></a>3.2 隐藏内部实现</h4><p>可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域来“隐藏”它们。为什么隐藏它们是一个有用的技术？</p>
<p>软件设计中，最小授权/最小暴露原则，如模块设计或对象的API设计。</p>
<p>这个原则延伸在如何选择作用域包含变量和函数。暴漏过多的变量和函数会破坏这个原则，并不是所有变量和函数都应该在全局作用域中。</p>
<h5 id="具体内容私有化"><a href="#具体内容私有化" class="headerlink" title="具体内容私有化"></a><strong>具体内容私有化</strong></h5><h5 id="规避冲突"><a href="#规避冲突" class="headerlink" title="规避冲突"></a><strong>规避冲突</strong></h5><p>1、全局命名空间</p>
<p>2、<a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="noopener">模块管理</a></p>
<h4 id="3-3-函数作用域"><a href="#3-3-函数作用域" class="headerlink" title="3.3 函数作用域"></a>3.3 函数作用域</h4><p>我们已经知道，在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。</p>
<p>但这不是最理想的方案，这会导致一些额外问题：必须声明一个具名函数，这个函数名标志符本身“污染”了所在作用域；其次，必须显式地通过函数名调用这个函数才能运行其中的代码。</p>
<p>如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行，这将会更加理想，JavaScript提供了解决方案</p>
<p>将包装函数声明放在()中，函数会被当作【函数表达式】而不是一个标准的函数声明来处理，它们的重要区别是名称标识符绑定不同，函数表达式的函数名被绑定在函数表达式自身的函数中而不是所在作用域中。</p>
<p>即，(function foo(){..})作为函数表达式意味着foo只能在..所代表的位置中被访问，外部作用域则不行。foo变量名被隐藏在自身中意味着不会非必要地污染外部作用域。</p>
<h5 id="3-3-1-匿名和具名"><a href="#3-3-1-匿名和具名" class="headerlink" title="3.3.1 匿名和具名"></a>3.3.1 匿名和具名</h5><p>函数表达式可以是匿名的，而函数声明则不可以省略函数名——在JavaScript的语法中这是非法的。</p>
<p>匿名函数表达式书写起来简单快捷，但有几个缺点：</p>
<ul>
<li>栈追踪不会显示有意义的函数名，调试困难</li>
<li>引用自身只能使用argument.callee，比如递归和事件触发解绑</li>
<li>可读性/可理解性低</li>
</ul>
<p>【行内函数表达式】非常强大且有用——匿名和具名之间的区别不会对这点有任何影响。始终个函数表达式命名是一个最佳实践。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timeroutHandler</span>(<span class="params"></span>)</span>&#123; <span class="comment">// &lt;--快看我有名字了！</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"I wanted 1 second!"</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h5 id="3-3-2-立即执行函数表达式"><a href="#3-3-2-立即执行函数表达式" class="headerlink" title="3.3.2 立即执行函数表达式"></a>3.3.2 立即执行函数表达式</h5><p>由于函数被包含在一对()括号内部因此成为了一个表达式，通过在末尾加上另外一个()可以立即执行这个函数，这种模式叫做：IIFE，立即执行函数表达式。</p>
<p>(function foo(){..})()或(function foo(){..}())</p>
<p>IIEF普遍的进阶用法：</p>
<ul>
<li>把它们当作函数调用并传递参数进去（如解决undefined标志符的默认值被错误覆盖的异常）</li>
<li>倒置代码的运行顺序</li>
</ul>
<h4 id="3-4-块作用域"><a href="#3-4-块作用域" class="headerlink" title="3.4 块作用域"></a>3.4 块作用域</h4><p>尽管函数作用域是最常见的作用域单元，也是现行大多数JavaScript中最普遍的设计方法，但其他类型的作用域单元也是存在的，并且通过使用其他类型的作用域单元甚至可以实现维护起来更加优秀、简洁的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(foo)&#123;</span><br><span class="line">    <span class="keyword">var</span> bar = foo * <span class="number">2</span>;  <span class="comment">// bar属于外部作用域，在外部确保没有同名参数只能依靠自觉性，很容易产生冲突</span></span><br><span class="line">    bar = something(bar);</span><br><span class="line">    <span class="built_in">console</span>.log(bar)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);   <span class="comment">//只在内部使用的i变量污染了外部作用域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>块作用域是一个用来对之前的最小授权原则进行扩展的工具，将代码从在函数中隐藏信息扩展为在块中隐藏信息</p>
<p>表面上JavaScript并没有块作用域的相关功能，除非你更加深入的研究</p>
<h5 id="3-4-1-with"><a href="#3-4-1-with" class="headerlink" title="3.4.1 with"></a>3.4.1 with</h5><p>第二章讨论过with关键字，它是块级作用域的一个例子（块作用域的一种形式）</p>
<h5 id="3-4-2-try-catch"><a href="#3-4-2-try-catch" class="headerlink" title="3.4.2 try/catch"></a>3.4.2 try/catch</h5><p>JavaScript的ES3规范中规定try/catch的catch分句会创建一个块作用域，其中声明的变量仅在catch内部有效。看起来没有什么用处，实际上在ES6环境以前使用块作用域都是靠转换为try/catch实现的。</p>
<h5 id="3-4-3-let"><a href="#3-4-3-let" class="headerlink" title="3.4.3 let"></a>3.4.3 let</h5><p>幸好ES6改变了现状，引入了新的let关键字，提供了除var以外的另一种变量声明方式。它可以将变量绑定到所在的任意作用域中（通常是{..}内部）。</p>
<p>但【使用let进行的声明不会在块作用域中进行提升】（第四章会讲提升），声明的代码运行前，声明并不“存在”</p>
<p>1、垃圾收集</p>
<p>2、let循环</p>
<h5 id="3-4-4-const"><a href="#3-4-4-const" class="headerlink" title="3.4.4 const"></a>3.4.4 const</h5><p>除了let以外，ES6还引入了const，可以用来创建块作用域常量。</p>
<h4 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h4><p>函数是JavaScript中最常见的作用域单元。本质上，声明一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。</p>
<p>但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，还可以属于某个代码块（通常指{..}内部）。</p>
<p>从ES3开始，try/catch结构在catch分句中具有块作用域。</p>
<p>在ES6中引入了let关键字（var 关键字的表亲），用来在任意的代码块中声明变量。if(..){let a=2;}会声明一个劫持了if的{..}块的变量，并且将这个变量添加到这个块中。</p>
<p>块级作用域和函数作用域应该根据情况选择，创造可读、可维护的优良代码</p>
<h3 id="第四章-提升"><a href="#第四章-提升" class="headerlink" title="第四章 提升"></a>第四章 提升</h3><p>作用域同其中的变量声明出现的位置有某种微妙的联系，这个细节正式我们要讨论的内容</p>
<h4 id="4-1-先有鸡还是先有蛋"><a href="#4-1-先有鸡还是先有蛋" class="headerlink" title="4.1 先有鸡还是先有蛋"></a>4.1 先有鸡还是先有蛋</h4><p>直觉上会认为JavaScript代码在执行时是由上到下一行一行执行的。但实际上并不完全正确，有一种特殊情况会导致这个假设是错误的。</p>
<p>【声明会提前】</p>
<h4 id="4-2-编译器再度来袭"><a href="#4-2-编译器再度来袭" class="headerlink" title="4.2 编译器再度来袭"></a>4.2 编译器再度来袭</h4><p>回顾第一章关于编译器的内容，引擎会在解释JavaScript代码之前首先对其进行编译。编译阶段的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。第二章展示了这个机制，也正是词法作用域的核心内容。</p>
<p>因此，正确的思考思路是，包含变量和函数在内的所有声明都会在任何代码被执行前首先被处理，这个过程就像变量和函数声明从它们在代码中出现的位置被“移动”到了其作用域的最上面。这个过程就叫做提升。</p>
<h4 id="4-3-函数优先"><a href="#4-3-函数优先" class="headerlink" title="4.3 函数优先"></a>4.3 函数优先</h4><p>函数声明和变量声明都会被提升。但一个细节值得注意（有多个“重复”声明时），是函数会首先被提升，然后才是变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-小结"><a href="#4-4-小结" class="headerlink" title="4.4 小结"></a>4.4 小结</h4><p>我们习惯将var a  = 2;看作一个声明，而实际上JavaScript引擎将其分成两个任务，第一个是编译阶段的任务，第二个是执行阶段的任务。</p>
<p>这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先被“移动”到各自作用域的顶端。可以将这个过程称为提升。</p>
<p>声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。</p>
<p>要注意避免重复声明，特别是当普通的var声明和函数声明混合在一起时。</p>
<h3 id="第五章-作用域闭包"><a href="#第五章-作用域闭包" class="headerlink" title="第五章 作用域闭包"></a>第五章 作用域闭包</h3><p>接下来的内容需要对作用域工作原理相关的基础知识有非常深入的理解。</p>
<h4 id="5-1-启示"><a href="#5-1-启示" class="headerlink" title="5.1 启示"></a>5.1 启示</h4><p>闭包是基于词法作用域书写代码时所产生的自然结果。</p>
<h4 id="5-2-实质问题"><a href="#5-2-实质问题" class="headerlink" title="5.2 实质问题"></a>5.2 实质问题</h4><p>定义：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p>
<p>无论通过何种手段将内部函数传递到所在词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。</p>
<h4 id="5-3-现在我懂了"><a href="#5-3-现在我懂了" class="headerlink" title="5.3 现在我懂了"></a>5.3 现在我懂了</h4><p>本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！</p>
<h4 id="5-4-循环和闭包"><a href="#5-4-循环和闭包" class="headerlink" title="5.4 循环和闭包"></a>5.4 循环和闭包</h4><h4 id="5-5-模块"><a href="#5-5-模块" class="headerlink" title="5.5 模块"></a>5.5 模块</h4><h5 id="5-5-1-现代的模块机制"><a href="#5-5-1-现代的模块机制" class="headerlink" title="5.5.1 现代的模块机制"></a>5.5.1 现代的模块机制</h5><h5 id="5-5-2-未来的模块机制"><a href="#5-5-2-未来的模块机制" class="headerlink" title="5.5.2 未来的模块机制"></a>5.5.2 未来的模块机制</h5><h4 id="5-6-小结"><a href="#5-6-小结" class="headerlink" title="5.6 小结"></a>5.6 小结</h4><h2 id="第二部分-this和对象原型"><a href="#第二部分-this和对象原型" class="headerlink" title="第二部分 this和对象原型"></a>第二部分 this和对象原型</h2><h3 id="第一章-关于this"><a href="#第一章-关于this" class="headerlink" title="第一章 关于this"></a>第一章 关于this</h3><p>this关键字是JavaScript中最复杂的机制之一。它是一个很特别的关键字，被自动定义在所有函数的作用域中。</p>
<h4 id="1-1-为什么要用this"><a href="#1-1-为什么要用this" class="headerlink" title="1.1 为什么要用this"></a>1.1 为什么要用this</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> greeting = <span class="string">"Hello, I'm"</span> + identify.call(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(greeting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = &#123;</span><br><span class="line">    name: <span class="string">"Kyle"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> you = &#123;</span><br><span class="line">    name: <span class="string">"Reader"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">identify.call(me);    <span class="comment">//KYLE</span></span><br><span class="line">identify.call(you);   <span class="comment">//READER</span></span><br><span class="line"></span><br><span class="line">speak.call(me);       <span class="comment">//Hello, I'm KYLE</span></span><br><span class="line">speak.call(you);       <span class="comment">//Hello, I'm READER</span></span><br></pre></td></tr></table></figure>
<p>这段代码可以在不同的【上下文对象】（you和me）中重复使用函数identify和speak，不用针对每个对象编写不同版本的函数。如果不使用this，就需要显式地给两个函数传入一个上下文对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> context.name.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> greeting = <span class="string">"Hello, I'm"</span> + identify(context);</span><br><span class="line">    <span class="built_in">console</span>.log(greeting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">identify(me);    <span class="comment">//KYLE</span></span><br><span class="line">speak(you);      <span class="comment">//Hello, I'm READER</span></span><br></pre></td></tr></table></figure>
<p>this提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将API设计得更加简洁并易于复用</p>
<h4 id="1-2-误解"><a href="#1-2-误解" class="headerlink" title="1.2 误解"></a>1.2 误解</h4><p>有两种关于this的常见解释都是错误的</p>
<h5 id="1-2-1-指向自身"><a href="#1-2-1-指向自身" class="headerlink" title="1.2.1 指向自身"></a>1.2.1 指向自身</h5><h5 id="1-2-2-它的作用域"><a href="#1-2-2-它的作用域" class="headerlink" title="1.2.2 它的作用域"></a>1.2.2 它的作用域</h5><p>第二种常见的误解，this指向函数的作用域。【this在任何情况下都不指向函数的词法作用域】。在JavaScript内部，作用域确实和对象很相似，可见的标志符都是它的属性。但作用域“对象”无法通过JavaScript代码访问，它存在于JavaScript引擎内部。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();   <span class="comment">//ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>
<p>首先，这段代码试图通过this.bar()来引用bar函数，这是绝对不可能成功的，之后会解释原因。调用bar最自然的方式是省略前面的this，直接使用词法引用标志符；此外，还试图使用this联通foo()和bar()的词法作用域，从而让bar访问foo作用域里的变量a，这是不可能实现的，你不能用this来引用一个词法作用域内部的东西。</p>
<h4 id="1-3-this到底是什么"><a href="#1-3-this到底是什么" class="headerlink" title="1.3 this到底是什么"></a>1.3 this到底是什么</h4><p>排除了一些错误理解之后，我们来看看this到底是一种什么样的机制。</p>
<h4 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h4><p>学习this的第一步是明白this既不指向函数自身也不指向函数的词法作用域，你也许被这样的解释误导过，但其实它们都是错误的。</p>
<p>this实际上是在函数被调用时发生绑定，它指向什么完全取决于函数在哪里被调用。</p>
<h3 id="第二章-this全面解析"><a href="#第二章-this全面解析" class="headerlink" title="第二章 this全面解析"></a>第二章 this全面解析</h3><h4 id="2-1-调用位置"><a href="#2-1-调用位置" class="headerlink" title="2.1 调用位置"></a>2.1 调用位置</h4><p>理解this的绑定过程之前，首先要理解调用位置：就是函数在代码中被调用的位置（而不是被声明的位置）。分析调用栈例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//当前调用栈是：baz</span></span><br><span class="line">    <span class="comment">//因此，当前调用位置是全局作用域</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"baz"</span>);</span><br><span class="line">    bar();    <span class="comment">//  &lt;-- bar的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//当前调用栈是 baz -&gt; bar</span></span><br><span class="line">    <span class="comment">//因此，当前调用位置在baz中</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar"</span>);</span><br><span class="line">    foo();    <span class="comment">//  &lt;-- foo的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//当前调用栈是 baz -&gt; bar -&gt; foo</span></span><br><span class="line">    <span class="comment">//因此，当前调用位置在bar中</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baz();    <span class="comment">//  &lt;-- baz的调用位置</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-绑定规则"><a href="#2-2-绑定规则" class="headerlink" title="2.2 绑定规则"></a>2.2 绑定规则</h4><p>函数的执行过程中调用位置如何决定this的绑定对象：</p>
<p>你必须先找到调用位置，然后判断需要应用下面四条规则中的哪一条。我们首先会分别解释这四条规则，然后解释多条规则都可用时它们的优先级如何排列。</p>
<h5 id="2-2-1-默认绑定"><a href="#2-2-1-默认绑定" class="headerlink" title="2.2.1 默认绑定"></a>2.2.1 默认绑定</h5><p>首先看最常用的函数调用类型：独立函数调用。可把这条规则看作无法应用其他规则时的默认规则。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo();    <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>this指向全局对象，严格模式下指向undefined。</p>
<h5 id="2-2-2-隐式绑定"><a href="#2-2-2-隐式绑定" class="headerlink" title="2.2.2 隐式绑定"></a>2.2.2 隐式绑定</h5><p>另一条需要考虑的规则时调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能造成一些误导。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo();   <span class="comment">//2，调用位置会使用obj上下文来引用函数，此时函数被调用时obj对象“包含”它</span></span><br></pre></td></tr></table></figure>
<h6 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a><strong>隐式丢失</strong></h6><p>一个最常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把this绑定到全局对象或者undefined上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo;   <span class="comment">//函数别名!</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"opps, global"</span>;   <span class="comment">//a是全局对象的属性</span></span><br><span class="line">bar();   <span class="comment">//”opps, global“，bar引用的是foo函数本身，此时的函数调用不带任何修饰符，因此应用的默认绑定</span></span><br></pre></td></tr></table></figure>
<p>例2，传入回调函数时丢失this</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFun</span>(<span class="params">fn</span>)</span>&#123;   <span class="comment">//参数传递其实是一种隐式赋值</span></span><br><span class="line">    <span class="comment">//fn其实引用的是foo</span></span><br><span class="line">    fn();   <span class="comment">// &lt;-- 调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo;   <span class="comment">//函数别名!</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"opps, global"</span>;   <span class="comment">//a是全局对象的属性</span></span><br><span class="line">doFun(obj.foo);   <span class="comment">//”opps, global“</span></span><br></pre></td></tr></table></figure>
<h5 id="2-2-3-显式绑定"><a href="#2-2-3-显式绑定" class="headerlink" title="2.2.3 显式绑定"></a>2.2.3 显式绑定</h5><p>如上在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并且通过这个属性简洁引用函数，从而把this间接（隐式）绑定到这个对象上。</p>
<p>如果不想在对象内部包含函数引用，而想在某个对象上强制调用函数，JavaScript提供的绝大多数函数和你自己创建的函数都可以使用函数的call(..)和apply(..)方法。</p>
<p>这两个方法的第一个参数是一个对象，它们会把这个对象绑定到this，接着在调用函数指定这个this。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.call(obj);   <span class="comment">//2，如果传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作this的绑定对象，这个原始值会被转换成它的对象形式（new String(..)、new Boolean(..)或者new Number(..)）</span></span><br></pre></td></tr></table></figure>
<p>可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题。</p>
<h6 id="1、硬绑定"><a href="#1、硬绑定" class="headerlink" title="1、硬绑定"></a>1、硬绑定</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a, something );</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + somethig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo.apply(obj,<span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>);  <span class="comment">//2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<p>一种显式的强制绑定，典型应用时创建一个包裹函数，传入所有的参数并返回接收到的所有值。</p>
<p>由于硬绑定是一种非常常用的模式，所以在ES5中提供了内置的方法Function.prototype.bind，用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a, something );</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + somethig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>);  <span class="comment">//2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<h6 id="2、API调用的“上下文”"><a href="#2、API调用的“上下文”" class="headerlink" title="2、API调用的“上下文”"></a>2、API调用的“上下文”</h6><p>第三方库和JavaScript语言以及宿主环境很多内置函数，都提供了一个可选的参数“上下文”（context），其作用和bind(..)一样，确保你的回调函数使用指定的this，举例来说：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( el, <span class="keyword">this</span>.id );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    id: <span class="string">"awesome"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用foo(..)时把this绑定到obj</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].forEach(foo,obj);   <span class="comment">//1 awesome 2 awesome 3 awesome</span></span><br></pre></td></tr></table></figure>
<p>这些函数实际上就是通过call(..)或者apply(..)实现了显式绑定</p>
<h5 id="2-2-4-new绑定"><a href="#2-2-4-new绑定" class="headerlink" title="2.2.4 new绑定"></a>2.2.4 new绑定</h5><p>这是最后一条this的绑定规则。首先重新定义一下JavaScript中的“构造函数”，在JavaScript中构造函数只是一些使用new操作符时被调用的普通函数，所以包括内置对象函数（比如Number(..)）在内的所有函数都可以用new来调用，这种函数调用被称为构造函数调用：实际上并不存在所谓的“构造函数”，只有对与函数的“构造调用”。</p>
<p>使用new来调用函数，或者发生构造函数调用时，会自动执行下面的操作：</p>
<ol>
<li>创建（或者说构造）一个全新的对象</li>
<li>这个新对象会被执行[[ 原型 ]]连接</li>
<li>这个新对象会被绑定到函数调用的this</li>
<li>如果这个函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>);  <span class="comment">//创建一个新对象并把它绑定到foo(..)调用中的this上</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.a)   <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<h4 id="2-3-优先级"><a href="#2-3-优先级" class="headerlink" title="2.3 优先级"></a>2.3 优先级</h4><p>new绑定&gt;显式绑定&gt;隐式绑定&gt;默认绑定</p>
<h4 id="2-4-绑定例外"><a href="#2-4-绑定例外" class="headerlink" title="2.4 绑定例外"></a>2.4 绑定例外</h4><p>规则总有例外，这里也一样。某些场景下this的绑定行为会出乎意料 ，你认为应该应用其他绑定规则时，实际上应用的可能是默认绑定规则。</p>
<h5 id="2-4-1-被忽略的this"><a href="#2-4-1-被忽略的this" class="headerlink" title="2.4.1 被忽略的this"></a>2.4.1 被忽略的this</h5><p>如果把null和undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo.call(<span class="literal">null</span>)   <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>那么什么情况下会传入null呢？一种非常常见的做法是使用apply(..)来“展开数组”（【注意：现在ES6有更好的展开做法】），并且当作参数传入一个函数。类似地，bind(..)可以对参数进行柯里化（预先设置一些参数），这种方法有时非常有用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"a:"</span> + a + <span class="string">",b:"</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把数组“展开”成参数</span></span><br><span class="line">foo.apply(<span class="literal">null</span>,[<span class="number">2</span>,<span class="number">3</span>]);   <span class="comment">//a:2,b:3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用bind(..)进行柯里化</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(<span class="literal">null</span>,<span class="number">2</span>);</span><br><span class="line">bar(<span class="number">3</span>);   <span class="comment">//a:2,b:3</span></span><br></pre></td></tr></table></figure>
<p>这两种 方法都需要传入一个参数当作this的绑定对象。如果函数并不关心this的话，传入null是个不错的选择。然而总是使用null来忽略this绑定可能产生一些副作用。如果某个函数确实使用了this（比如第三方库的一个函数），那默认的绑定规则会把this绑定到全局对象，这将导致不可预计的后果（比如修改全局对象）</p>
<h6 id="更安全的this"><a href="#更安全的this" class="headerlink" title="更安全的this"></a><strong>更安全的this</strong></h6><p>一种更安全的做法是传入一个特殊的对象，把this绑定到这个“DMZ”对象——一个空的非委托对象（委托在第四章第五章介绍）。</p>
<h5 id="2-4-2-间接引用"><a href="#2-4-2-间接引用" class="headerlink" title="2.4.2 间接引用"></a>2.4.2 间接引用</h5><p>有可能不小心创建一个函数的“间接引用”，比如赋值的时候（this丢失），会应用默认绑定。</p>
<h5 id="2-4-3-软绑定"><a href="#2-4-3-软绑定" class="headerlink" title="2.4.3 软绑定"></a>2.4.3 软绑定</h5><p>之前我们已经看到过，硬绑定可以把this强制绑定到指定的对象（除了使用new时），防止函数调用应用默认绑定规则。但它会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或显式绑定来修改this。</p>
<p>如果可以给默认绑定制定一个全局对象和undefined以外的值，那就可以实现和硬绑定相同的效果同时保留隐式绑定和显式绑定修改this的能力</p>
<h4 id="2-5-this词法"><a href="#2-5-this词法" class="headerlink" title="2.5 this词法"></a>2.5 this词法</h4><p>之前介绍的四条规则已经可以包含所有正常的函数。但是在ES6中介绍了一种无法使用这些规则的特殊函数类型：箭头函数。</p>
<p>箭头函数并不是使用function关键字定义的，而是使用称为“胖箭头”的操作符 =&gt; 定义的。箭头函数不使用this的四种标准规则，而是根据外层（函数或者全局）作用域来决定this。箭头函数的绑定无法被修改。（new也不行！）</p>
<h4 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h4><p>如果要判断一个运行中函数的this绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺心应用下面这四条规则来判断this的绑定对象：</p>
<ol>
<li>由new调用？绑定到新创建的对象。</li>
<li>由call或者apply（或者bind）调用？绑定到指定的对象。</li>
<li>由上下文对象调用 ？绑定到那个上下文对象。</li>
<li>默认：在严格模式下绑定到undefined，否则绑定到全局对象</li>
</ol>
<p>一定要注意有些调用可能在无意中使用了默认绑定规则。如果想“更安全”地忽略this绑定，你可以使用一个DMZ对象以保护全局对象。</p>
<p>ES6中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定this，具体来说，箭头函数会继承外层函数调用的this绑定（无论this绑定到什么）。这其实和ES6之前代码中的self=this机制一样。</p>
<h3 id="第三章-对象"><a href="#第三章-对象" class="headerlink" title="第三章 对象"></a>第三章 对象</h3><p>在第一章和第二章中，我们介绍了函数调用位置的不同会造成this绑定对象的不同。但是对象到底是什么，为什么我们需要绑定它们呢？</p>
<h4 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h4><p>对象可以通过两种形式定义：声明（文字）形式和构造形式。前者更为常见。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    key: value</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">myObj.key = value;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-类型"><a href="#3-2-类型" class="headerlink" title="3.2 类型"></a>3.2 类型</h4><p>对象是JavaScript的基础。在JavaScript中一共有六种主要类型（术语是“语言类型”）：</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>object</li>
</ul>
<p>注意，简单基本类型（string、boolean、number、null、undefined）本身并不是对象，常见的错误说法“JavaScript中万物皆对象”。实际上JavaScript中有许多特殊的对象子类型，我们可以称之为复杂基本类型如函数、数组。在调用普通基本类型的“方法”时，JavaScript会自动转换其为复杂基本类型。</p>
<h5 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a><strong>内置对象</strong></h5><p>JavaScript中还有一些对象子类型，通常被称为为内置对象。有些内置对象的名字看起来和简单基础类型一样，不过实际它们的关系更复杂，下面详细介绍</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Function</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
<li>Error</li>
</ul>
<h4 id="3-3-内容"><a href="#3-3-内容" class="headerlink" title="3.3 内容"></a>3.3 内容</h4><p>之前提到过，对象的内容是由一些存储在特定命名位置的（任意类型的）值组成的，我们称之为属性。存储在对象容器内部的是这些属性的名称，它们就像指针（从技术角度来说就是引用）一样，指向这些真正的存储位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject.a;   <span class="comment">//2</span></span><br><span class="line">myObject[<span class="string">"a"</span>];   <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>使用.操作符或者[]操作符能访问属性值，前者被称为“属性访问”，后者“键访问”。主要区别在于.操作符要求属性名满足标识符的命名规范，而[“..”]语法可以接受任意UTF-8/Unicode字符串作为属性名，该字符串还可以在程序中构造。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject[prefix + name];</span><br></pre></td></tr></table></figure>
<p>【在对象中，属性名永远都是字符串】。即使数字也不例外，在数组下标访问时其实被转化成字符串了，当心不要搞混对象和数组中数字的用法。</p>
<h5 id="3-3-1-可计算属性名-ES6"><a href="#3-3-1-可计算属性名-ES6" class="headerlink" title="3.3.1 可计算属性名(ES6)"></a>3.3.1 可计算属性名(ES6)</h5><p>在文字【声明】对象时使用[]包裹一个表达式来作为属性名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prefix = <span class="string">"foo"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    [prefix + <span class="string">"bar"</span>]: <span class="string">"Hello"</span>,</span><br><span class="line">    [prefix + <span class="string">"baz"</span>]: <span class="string">"World"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject[<span class="string">"foobar"</span>];   <span class="comment">//Hello</span></span><br><span class="line">myObject[<span class="string">"foobaz"</span>];   <span class="comment">//World</span></span><br></pre></td></tr></table></figure>
<h5 id="3-3-2-属性与方法"><a href="#3-3-2-属性与方法" class="headerlink" title="3.3.2 属性与方法"></a>3.3.2 属性与方法</h5><p>如果访问的对象属性是一个函数，从技术角度来说，函数永远都不会“属于”一个对象，所以不应该把对象内部引用的函数称为“方法”，即使一些函数具有this引用也不能把它变成一个“方法”，因为this是在运行时根据调用位置动态绑定的。属性访问返回的函数和其他函数没有任何区别（除了刚刚提到可能发生的隐式绑定）。</p>
<p>最保险的说法可能是，“函数”和“方法“在JavaScript中是可以互换的。</p>
<h5 id="3-3-3-数组"><a href="#3-3-3-数组" class="headerlink" title="3.3.3 数组"></a>3.3.3 数组</h5><p>数组也支持[]访问，不过期望的是数值（【注意，[“3”]等于[3]，上文提到过属性名永远是字符串】），虽然每个下标都是整数，但仍可给数组添加属性但不会改变length值，这不是一个好主意，最好只用对象存储键/值对，只用数组存储数值下标/值对。</p>
<h5 id="3-3-4-复制对象"><a href="#3-3-4-复制对象" class="headerlink" title="3.3.4 复制对象"></a>3.3.4 复制对象</h5><p>复制一个对象，ES6可用Object.assign(..)实现浅复制，保证对象安全的情况下还可以</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">JSON</span>.parse( <span class="built_in">JSON</span>.stringfy( someObj) );</span><br></pre></td></tr></table></figure>
<h5 id="3-3-5-属性描述符"><a href="#3-3-5-属性描述符" class="headerlink" title="3.3.5 属性描述符"></a>3.3.5 属性描述符</h5><p>在ES5之前，JavaScript语言本身并没有提供可以直接检测属性特性的方法，比如判断属性是不是只读。从ES5开始，所有属性都具备了属性描述符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor( myObject, <span class="string">"a"</span>);</span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//   value: 2,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
<p>在创建普通属性时属性描述符会使用默认值，我们也可以用Object.defineProperty(..)来添加一个新属性或者修改一个已有属性（如果它是configurable）并对特性进行设置。</p>
<h5 id="3-3-6-不变性"><a href="#3-3-6-不变性" class="headerlink" title="3.3.6 不变性"></a>3.3.6 不变性</h5><p>有时候你会希望属性或者是对象是不可改变的，ES5中有多种方法实现。很重要的一点是，所有的方法创建的都是浅不变性，也就是说它们只会影响目标对象和它的直接属性，如果目标对象引用的其他对象（数组、对象、函数等），其他对象的内容不受影响仍然是可变的。（虽然JavaScript程序中很少需要深不可变性）</p>
<h6 id="1、对象常量"><a href="#1、对象常量" class="headerlink" title="1、对象常量"></a>1、<strong>对象常量</strong></h6><p>结合writable:false和configurable:false可以创建一个真正的常量属性（不可修改、重定义或删除）。</p>
<h6 id="2、禁止扩展"><a href="#2、禁止扩展" class="headerlink" title="2、禁止扩展"></a>2、<strong>禁止扩展</strong></h6><p>如果你想禁止一个对象添加新属性并且保留已有属性，可以使用Object.preventExtension(..)。</p>
<h6 id="3、密封"><a href="#3、密封" class="headerlink" title="3、密封"></a>3、<strong>密封</strong></h6><p>Object.seal(..)会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.prebentExtension(..)并把所有现有属性标记为configurable:false。</p>
<h6 id="4、冻结"><a href="#4、冻结" class="headerlink" title="4、冻结"></a>4、<strong>冻结</strong></h6><p>Object.freeze(..)会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.seal(..)并把所有“数据访问”属性标记为writable:false。</p>
<p>这个方法是你可以应用在对象上的级别最高的不可变性。</p>
<h5 id="3-3-7-Get"><a href="#3-3-7-Get" class="headerlink" title="3.3.7 [[Get]]"></a>3.3.7 [[Get]]</h5><p>属性访问有一个细节：myObject.a这种语句并不仅仅是在myObject中查找名字为a的属性，它实际上是实现了[[Get]]操作。对象默认的内置[[Get]]操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值；没有找到，遍历可能存在的[[Prototype]]链寻找；无论如何都没有找到名称相同的属性，那么[[Get]]操作会返回值undefined。</p>
<p>【注意：这种方法与访问变量时是不一样的】如果你引用了一个当前词法作用域中不存在的变量，并不会像对象属性一样返回undefined的，而是会抛出一个ReferenceError异常</p>
<h5 id="3-3-8-Put"><a href="#3-3-8-Put" class="headerlink" title="3.3.8 [[Put]]"></a>3.3.8 [[Put]]</h5><p>有[[Get]]就会有[[Put]]操作，可能会认为对象属性赋值会触发[[Put]]来设置或者创建这个属性，并不完全这样：[[Put]]操作被触发时，实际的行为取决于很多因素，主要因素是对象中是否已经存在这个属性，若存在，[[Put]]算法大致会检查以下内容：</p>
<ol>
<li></li>
</ol>
<p>如果对象中不存在这个属性，[[Put]]操作会更加复杂，第五章讨论[[Prototype]]时会详细介绍。</p>
<h5 id="3-3-9-Getter和Setter"><a href="#3-3-9-Getter和Setter" class="headerlink" title="3.3.9 Getter和Setter"></a>3.3.9 Getter和Setter</h5><p>对象默认的[[Get]]和[[Put]]操作分别可以控制属性值的设置和获取。</p>
<p>在ES5中可以使用setter和getter部分改写默认操作，这两个是隐藏函数，会在设置/获取属性值时调用。当你给一个属性定义getter、setter或两者都有时，这个属性会被定义为“访问描述符”（和“数据描述符”相对），对于访问描述符来说，JavaScript会忽略它们的value和writable特性，取而代之是关心set和get（还有configurable和enumerable）特性。</p>
<h5 id="3-3-10-存在性"><a href="#3-3-10-存在性" class="headerlink" title="3.3.10 存在性"></a>3.3.10 存在性</h5><p>in操作符会检查属性是否存在对象及其[[Prototype]]原型链中（参见第五章）。相比之下，hasOwnProperty(..)只会检查属性是否在对象中，不会检查[[Prototype]]链</p>
<h6 id="1、枚举"><a href="#1、枚举" class="headerlink" title="1、枚举"></a>1、枚举</h6><p>“可枚举”就相当于“可以出现在对象属性的遍历中”。除了看是否出现在for..in循环（会查找原型链并且满足enumerable:true）中，还可以利用propertyIsEnumerable(..)检查给定的属性名是否直接存在于对象中（不会查找原型链）并且满足enumerable:true。</p>
<p>只在对象中查找的一些方法：Object.keys(..)会返回一个数组，包含所有可枚举属性；Object.getOwnPropertyNames(..)会返回一个数组，无论它们是否可以枚举</p>
<h4 id="3-4-遍历"><a href="#3-4-遍历" class="headerlink" title="3.4 遍历"></a>3.4 遍历</h4><p>for..in可以遍历对象的可枚举属性列表（包括[[Prototype]]链），如何遍历属性的值呢？</p>
<p>对于数值索引的数组来说，可以使用标准的for循环来遍历值；ES5中增加了一些数组的辅助迭代器，包括forEach(..)、every(..)和some(..)。</p>
<p>ES6增加了一种遍历数组的for..of循环语法（如果对象本身定义了迭代器的话也可以遍历对象）。for..of循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来遍历所有返回值。</p>
<h4 id="3-5-小结-1"><a href="#3-5-小结-1" class="headerlink" title="3.5 小结"></a>3.5 小结</h4><p>JavaScript中的对象有字面形式（比如var a={..}）和构造形式（比如var a=new Array(..)）。字面形式更常用，不过有时候构造形式可以提供更多选项。</p>
<p>“JavaScript中万物都是对象”这是错误的，对象是6个（或者7个，取决于你的观点）基础类型之一。对象有包括function在内的子类型，不同子类型具有不同的行为。</p>
<p>对象就是键/值对的集合。可以通过.propName或者[“propName”]语法来获取属性值。访问属性时，引擎实际上会调用内部默认[[Get]]操作（设置属性是[[Put]]），[[Get]]操作会检查对象本身是否包含这个属性，没有找到的话还会查找[[Prototype]]链（见第五章）。</p>
<p>属性的特性可以通过属性描述符来控制，还可以使用一些方法来设置对象（及其属性）的不可变性级别。</p>
<p>属性不一定包含值——它可能是具备getter/setter的“描述访问符”；属性可以是可枚举的或不可枚举的，这决定了它们是否会出现在for..in循环中。</p>
<p>你可以使用ES6的for..of语法来遍历数据结构（数组、对象等）中的值，for..of会寻找内置或者自定义的@@iterator对象并调用它的next()方法来遍历数据值。</p>
<h3 id="第四章-混合对象“类”"><a href="#第四章-混合对象“类”" class="headerlink" title="第四章 混合对象“类”"></a>第四章 混合对象“类”</h3><p>上一章介绍了对象，这章介绍和类相关的面向对象编程。在研究类的具体机制之前首先介绍一下面向对象的设计模式：实例化、继承和多态。</p>
<p>我们将会看到，这些概念实际上无法直接对应到JavaScript的对象机制，因此我们会介绍许多JavaScript开发者所使用的解决方法（比如混入，mixin）</p>
<h4 id="4-1-类理论"><a href="#4-1-类理论" class="headerlink" title="4.1 类理论"></a>4.1 类理论</h4><p>类/继承描述了一种代码的组织结构形式——一种在软件中对真实世界中问题领域的建模方法。</p>
<p>面向对象编程强调的是数据和操作数据的行为本质上是互相关联的（当然，不同的数据有不同的行为），因此好的设计就是把数据以及和它相关的行为打包（或者说封装）起来。这在正式的计算机科学中有时被称为数据结构。</p>
<h5 id="4-1-1-“类”设计模式"><a href="#4-1-1-“类”设计模式" class="headerlink" title="4.1.1 “类”设计模式"></a>4.1.1 “类”设计模式</h5><p>类并不是必须的编程基础，而是一种可选的代码抽象。</p>
<h5 id="4-1-2-JavaScript中的“类”"><a href="#4-1-2-JavaScript中的“类”" class="headerlink" title="4.1.2 JavaScript中的“类”"></a>4.1.2 JavaScript中的“类”</h5><p>类是一种在软件设计中可选的模式，你可以用一些方法在JavaScript中（本章之后会介绍）近似实现类的功能。为了满足对于类设计模式最普遍的需求，JavaScript提供了一些近似类的语法。</p>
<h4 id="4-2-类的机制"><a href="#4-2-类的机制" class="headerlink" title="4.2 类的机制"></a>4.2 类的机制</h4><h5 id="4-2-1-建造"><a href="#4-2-1-建造" class="headerlink" title="4.2.1 建造"></a>4.2.1 建造</h5><p>“类”和“实例”的概念来自于房屋建造。</p>
<p>一个类就是一张蓝图，为了获得真正可以交互的对象，我们必须按照类来建造（也可以说实例化）一个东西，这个东西通常被称为实例，有需要的话，我们可以直接在实例上调用方法并访问其公有数据属性。</p>
<h5 id="4-2-2-构造函数"><a href="#4-2-2-构造函数" class="headerlink" title="4.2.2 构造函数"></a>4.2.2 构造函数</h5><p>类示例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。这个方法的任务就是初始化实例需要的所有信息（状态）。</p>
<p>构造函数会返回一个对象（也就是类的一个实例）。类构造函数属于类，大多需要用new来调，这样语言引擎才知道你想要构造一个新的类实例。</p>
<h4 id="4-3-类的继承"><a href="#4-3-类的继承" class="headerlink" title="4.3 类的继承"></a>4.3 类的继承</h4><p>在面向类的语言中，你可以先定义一个类，然后定义一个继承前者的类。</p>
<h5 id="4-3-1-多态"><a href="#4-3-1-多态" class="headerlink" title="4.3.1 多态"></a>4.3.1 多态</h5><p>多态是一个非常广泛的话题，我们在JavaScript中所说的“相对多态”只是多态的一个方面：任何方法都可以引用和继承层次中高层的方法（无论高层的方法名和当前方法名是否相同）。之所以说“相对”是因为我们并不会定义想要访问的绝对继承层次（或者说类），而是使用相对引用“查找上一次层”。许多语言中可以使用super，它的含义是“超类”，表示当前类的父/祖先类。</p>
<p>多态的另一个方面是，在继承链的不同层次中一个方法名可以被多次定义，当调用方法时会自动选择合适的定义。方法的多态性取决于你是在哪个类的实例中引用它。</p>
<p>多态并不表示子类和父类有关联，子类得到的只是父类的一份副本。类的继承其实就是复制。</p>
<h5 id="4-3-2-多重继承"><a href="#4-3-2-多重继承" class="headerlink" title="4.3.2 多重继承"></a>4.3.2 多重继承</h5><p>有些面向类的语言允许你继承多个“父类”。多重继承意味着所有父类的定义都会被复制到子类中。从表面上看这个功能非常有用，可以把许多功能组合到一起。其实会带来很多复杂的问题，比如两个父类都定了同名方法，子类引用会很麻烦。</p>
<p>相比之下，JavaScript要简单得多：它本身并不提供“多重继承”功能。很多JavaScript开发者会尝试各种方法来实现多重继承，我们马上会看到。</p>
<h4 id="4-4-混入"><a href="#4-4-混入" class="headerlink" title="4.4 混入"></a>4.4 混入</h4><p>在继承会这实例化时，JavaScript的对象机制并不会自动执行复制行为。JavaScript中只有对象，并不存在可以被实例化的“类”。一个对象并不会被复制到其他对象，它们会被关联起来（第五章介绍）。</p>
<p>由于在其他语言中类表现出来的都是复制行为，因此JavaScript开发者想出一个方法来模拟类的复制行为，这个方法就是混入。接下来我们会看到两种类型的混入：显式和隐式。</p>
<h5 id="4-4-1-显式混入"><a href="#4-4-1-显式混入" class="headerlink" title="4.4.1 显式混入"></a>4.4.1 显式混入</h5><p>由于JavaScript不会自动实现复制行为，所以我们需要手动实现复制功能。这个功能在许多库和框架中被称为extend(..)，但是为了方便理解我们称之为mixin(..)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非常简单的mixin(..)例子：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params"> sourceObj, targetobj </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> sourceObjr) &#123;</span><br><span class="line">        <span class="comment">//只会在不存在的情况下复制</span></span><br><span class="line">        <span class="keyword">if</span>(!(key <span class="keyword">in</span> targetObj)) &#123;</span><br><span class="line">            tergetObj[key]=sourceObj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tergetObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="1、再说多态"><a href="#1、再说多态" class="headerlink" title="1、再说多态"></a>1、再说多态</h6><h6 id="2、混合复制"><a href="#2、混合复制" class="headerlink" title="2、混合复制"></a>2、混合复制</h6><p>现在我们分析一下mixin(..)工作原理。它遍历sourceObj的属性，如果在tergetObj没有这个属性就会进行复制。由于是在目标对象初始化之后再进行复制，因此存在覆盖目标对象的原有属性可能。</p>
<p>如果选择先复制再对目标对象进行特殊化，就可以跳过存在性检查，不过这种方法并不好而且效率低，不如第一种方法常用。</p>
<p>这两种方法都可以把不重叠的内容从源对象中复制到目标对象 。但在JavaScript中函数无法真正的复制，你只能复制对其共享函数对象的引用。如果你向目标对象中显式混入超过一个对象，就可以部分模仿多重继承行为。</p>
<h6 id="3、寄生继承"><a href="#3、寄生继承" class="headerlink" title="3、寄生继承"></a>3、寄生继承</h6><p>显式混入模式的一种变体称为“寄生继承”，既是显式的又是隐式的。</p>
<h5 id="4-4-2-隐式混入"><a href="#4-4-2-隐式混入" class="headerlink" title="4.4.2 隐式混入"></a>4.4.2 隐式混入</h5><p>隐式混入和之前提到的显式伪多态很像，因此也具备同样的问题</p>
<h4 id="4-5-小结"><a href="#4-5-小结" class="headerlink" title="4.5 小结"></a>4.5 小结</h4><h3 id="第五章-原型"><a href="#第五章-原型" class="headerlink" title="第五章 原型"></a>第五章 原型</h3><p>第三章和第四章多次提到了[[Prototype]]链，但没有说它到底是什么，现在我们来详细介绍一下它。</p>
<p>第四章介绍的所有模拟类复制行为的方法，比如各种混入，都【没有】使用[[Prototype]]链机制。</p>
<h4 id="5-1-Prototype"><a href="#5-1-Prototype" class="headerlink" title="5.1 [[Prototype]]"></a>5.1 [[Prototype]]</h4><p>JavaScript中的对象都有一个特殊的[[Prototype]]内置属性，其实就是对于其他对象的引用。</p>
<p>它有什么用呢，之前说过当试图引用对象的属性时会触发[[Get]]操作，比如myObject.a，第一步就是检查对象本身是否有个属性，有的话就使用它；但是如果a不在myObject中，就需要使用对象的[[Prototye]]链了。这个过程会持续到找到匹配的属性名或查找完整的[[Prototype]]链，仍找不到[[Get]]操作返回值undefined。</p>
<p>使用for..in遍历对象时也是这个原理，任何可以通过原型链访问（并且是enumerable）的属性都会被枚举。使用in操作符来检查属性在对象中是否存在时，同样也会查找对象的整条原型链（无论是否可枚举）。</p>
<h5 id="5-1-1-Object-prototype"><a href="#5-1-1-Object-prototype" class="headerlink" title="5.1.1 Object.prototype"></a>5.1.1 Object.prototype</h5><p>所有普通的[[Prototype]]链最终都会指向内置的Object.prototype，它包含JavaScript中许多通用的功能，比如.toString()和.valueOf()，第三章的.hasOwnProperty(..)，接下来还会介绍的.isPrototypeOf(..)等。</p>
<h5 id="5-1-2-属性设置和屏蔽"><a href="#5-1-2-属性设置和屏蔽" class="headerlink" title="5.1.2 属性设置和屏蔽"></a>5.1.2 属性设置和屏蔽</h5><p>第三章提到过给一个对象设置属性并不仅仅是添加一个新属性或者修改已有属性值，myObject.foo=”bar”完整过程：</p>
<p>如果myObject对象中包含名为foo的数据访问属性，这条赋值语句只会修改已有的属性值；</p>
<p>如果foo不是直接存在于myObject中，[[Prototype]]链就会被遍历，类似[[Get]]操作，如果原型链上找不到foo，foo就会被直接添加到myObject上；</p>
<p>如果foo既出现在myObject中也出现在myObject的[[Prototype]]链上层，那么就会发生【屏蔽】。myObject中包含的foo属性会屏蔽原型链上层的所有foo属性；</p>
<p>然而，如果foo只存在于原型链上层，myObject.foo=”bar”会出现三种情况：</p>
<ol>
<li></li>
</ol>
<p>大多数开发者都认为如果向[[Prototype]]链上层存在的属性赋值（[[Put]]），就一定会触发屏蔽，实际上只有第一种情况是这样的，如果希望在第二种第三种情况下都屏蔽foo，就不能使用=操作符来赋值，而是使用Object.defineProperty(..)来向myObject添加foo（参见第三章）。</p>
<p>如果需要对屏蔽方法进行委托委托的话就不得不使用丑陋的显式伪多态（参见第四章）。通常来说，使用屏蔽得不偿失，所以应当避免使用。第六章会介绍一种不使用屏蔽的更加简洁的设计模式。</p>
<h4 id="5-2-“类”"><a href="#5-2-“类”" class="headerlink" title="5.2 “类”"></a>5.2 “类”</h4><p>为什么一个对象需要关联到另一个对象？第四章我们说过JavaScript和面向对象的语言不同，它没有类来作为对象的抽象模式或者蓝图。JavaScript中只有对象。</p>
<h5 id="5-2-1-“类”函数"><a href="#5-2-1-“类”函数" class="headerlink" title="5.2.1 “类”函数"></a>5.2.1 “类”函数</h5><p>很多年来，JavaScript中有一种奇怪的行为被滥用，这就是模仿类，利用函数的一种特殊特性：所有函数都会拥有一个名为prototype的公有并且不可枚举的属性，它会指向另一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype; <span class="comment">//&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>这个对象通常被称为Foo的原型，非常容易造成歧义。抛开名字不谈，这个对象到底是什么？最直接的解释是，这个对象是在调用new Foo()时创建的，最后关联到这个Foo.prototype对象上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(a)===Foo.prototype;   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>在面向类的语言中，类可以被复制（或者说实例化）多次，但是在JavaScript中，并没有类的复制机制，你不能创建一个类的多个实例，只能创建多个对象，它们[[Prototype]]关联的是同一个对象。</p>
<h6 id="关于名称"><a href="#关于名称" class="headerlink" title="关于名称"></a><strong>关于名称</strong></h6><p>在JavaScript中并不会将一个对象（“类”）复制到另一个对象（“实例”），只是将它们关联起来，这个机制常常被称为原型继承，被视为动态语言版本的类继承。这个术语“原型继承”（以及使用其他面向类的术语比如“类”、“构造函数”、“实例”、“多态”等等）严重影响了大家对于JavaScript机制真实原理的理解。</p>
<p>继承意味着复制操作，JavaScript（默认）并不会复制对象属性。相反，JavaScript会在两个对象之间创建关联，这样一个对象可以通过【委托】访问另一个对象的属性和函数。【委托】这个术语可以更加精准地描述JavaScript中对象的关联机制。</p>
<h5 id="5-2-2-“构造函数”"><a href="#5-2-2-“构造函数”" class="headerlink" title="5.2.2 “构造函数”"></a>5.2.2 “构造函数”</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure>
<p>到底是什么让我们认为Foo是一个“类”呢？一个原因是使用了关键字new，在面向类的语言中构造实例时也会用到它；另一个原因是Foo()的调用方式很像初始化类时类构造函数的调用方式。</p>
<p>除了令人迷惑的“构造函数”语义外，Foo.prototype还有另一个绝招：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.constructor === Foo;  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line">a.constructor === Foo;   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>Foo.prototype默认（在代码第一行声明时！）有一个公有且不可枚举的属性.constructor，这个属性引用的是对象关联的函数（本例中是Foo）。此外，可以看到通过“构造函数”调用new Foo()创建的对象也有一个.constructor属性，指向“创建这个对象的函数”。</p>
<h6 id="构造函数还是调用"><a href="#构造函数还是调用" class="headerlink" title="构造函数还是调用"></a><strong>构造函数还是调用</strong></h6><p>上一段代码很容易让人认为Foo是一个构造函数，因为我们使用new来调用它并且看到它“构造”了一个对象。</p>
<p>实际上Foo和其他任何函数没有任何区别。函数本身并不是构造函数，使用new关键字把这个函数调用变成了一个“构造函数调用”</p>
<h4 id="5-3-（原型）继承"><a href="#5-3-（原型）继承" class="headerlink" title="5.3 （原型）继承"></a>5.3 （原型）继承</h4><h6 id="检查“类”关系"><a href="#检查“类”关系" class="headerlink" title="检查“类”关系"></a><strong>检查“类”关系</strong></h6><p>假设有对象a，如何寻找对象a委托的对象（如果存在）呢？，在传统面向类的环境中，检查一个实例（JavaScript中的对象）的继承祖先（JavaScript中的委托关联）通常被称为内省。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.blah = ...;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line">a <span class="keyword">instanceof</span> Foo；   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>第一种方法是站在“类”的角度来判断：a instanceof Foo；instanceof回答的问题是：在a的整条[[Prototype]]链中是否有指向Foo.prototype的对象？</p>
<p>可惜这个方法只能处理对象（a）和函数（带.prototype引用的Foo）之间的联系，如果想判断两个对象（比如a和b）之间是否通过[[Prototype]]链关联，只用instanceof无法实现。</p>
<p>下面是第二种判断[[Prototype]]内省的方法，它更加简洁：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo.prototype.isPrototypeOf(a);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>这个方法不需要使用函数（“类”），它直接判断对象之间的关系，isPrototypeOf问的问题是：在a的整条[[Prototype]]链中是否出现过Foo.prototype?</p>
<p>我们也可以直接获取一个对象的[[Prototype]]链：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(a);</span><br><span class="line"></span><br><span class="line">a.__proto__</span><br></pre></td></tr></table></figure>
<h4 id="5-4-对象关联"><a href="#5-4-对象关联" class="headerlink" title="5.4 对象关联"></a>5.4 对象关联</h4><p>现在知道了[[Prototype]]机制就是存在于对象中的一个内部链接，它会引用其他对象。这个链接的作用是：如果在对象上没有找到需要的属性和方法引用，引擎就会继续在[[Prototype]]关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它的[[Prototype]]，以此类推。这一系列对象的链接被称为“原型链”。</p>
<h5 id="5-4-1-创建关联"><a href="#5-4-1-创建关联" class="headerlink" title="5.4.1 创建关联"></a>5.4.1 创建关联</h5><p>[[Prototype]]机制的意义是什么呢？为什么JavaScript开发者费这么大力气（模拟类）在代码中创建这些关联呢？</p>
<h5 id="5-4-2-关联关系是备用"><a href="#5-4-2-关联关系是备用" class="headerlink" title="5.4.2 关联关系是备用"></a>5.4.2 关联关系是备用</h5><p>看起来对象之间的关联关系是处理“缺失”属性或者方法时的一种备用选项，但这并不是[[Prototype]]的本质。</p>
<h4 id="5-5-小结"><a href="#5-5-小结" class="headerlink" title="5.5 小结"></a>5.5 小结</h4><h3 id="第六章-行为委托"><a href="#第六章-行为委托" class="headerlink" title="第六章 行为委托"></a>第六章 行为委托</h3><p>第五章详细介绍了[[Prototype]]机制并说明了为什么在“类”或者“继承”的背景下讨论[[Prototype]]容易产生误解（这种不恰当方式已经持续了20年）。我们搞清楚了繁杂的语法（各种.prototype代码），也见识了各种各样的陷阱（比如出人意料的.contructor和丑陋的伪多态语法），还有用来解决这些问题的各种“混入”方法。</p>
<p>JavaScript中[[Prototype]]机制的本质就是对象之间的关联关系。这个观点对于理解本章的内容来说是非常基础并且非常重要的。</p>
<h4 id="6-1-面向委托的设计"><a href="#6-1-面向委托的设计" class="headerlink" title="6.1 面向委托的设计"></a>6.1 面向委托的设计</h4><p>为了更好地学习如何更直观地使用[[Prototype]]，我们必须认识到它代表的是一种不同于类（参见第四章）的设计模式。我们需要试着把思路从类和继承的设计模式转换到委托行为的设计模式。</p>
<h5 id="6-1-1-类理论"><a href="#6-1-1-类理论" class="headerlink" title="6.1.1 类理论"></a>6.1.1 类理论</h5><h5 id="6-1-2-委托理论"><a href="#6-1-2-委托理论" class="headerlink" title="6.1.2 委托理论"></a>6.1.2 委托理论</h5><h6 id="1、相互委托（禁止）"><a href="#1、相互委托（禁止）" class="headerlink" title="1、相互委托（禁止）"></a><strong>1、相互委托（禁止）</strong></h6><h6 id="2、调试"><a href="#2、调试" class="headerlink" title="2、调试"></a><strong>2、调试</strong></h6><h5 id="6-1-3-比较思维模型"><a href="#6-1-3-比较思维模型" class="headerlink" title="6.1.3 比较思维模型"></a>6.1.3 比较思维模型</h5><h4 id="6-2-类与对象"><a href="#6-2-类与对象" class="headerlink" title="6.2 类与对象"></a>6.2 类与对象</h4><h4 id="6-3-更简洁的设计"><a href="#6-3-更简洁的设计" class="headerlink" title="6.3 更简洁的设计"></a>6.3 更简洁的设计</h4><h4 id="6-4-更好的语法"><a href="#6-4-更好的语法" class="headerlink" title="6.4 更好的语法"></a>6.4 更好的语法</h4><h4 id="6-5-内省"><a href="#6-5-内省" class="headerlink" title="6.5 内省"></a>6.5 内省</h4><h4 id="6-6-小结"><a href="#6-6-小结" class="headerlink" title="6.6 小结"></a>6.6 小结</h4></div><div class="tags"><a href="/tags/JavaScript/">JavaScript</a></div><div class="post-nav"><a class="pre" href="/2018/12/03/【你不知道的JavaScript中】/">【你不知道的JavaScript中】</a><a class="next" href="/2018/11/15/深入浅出React和Redux/"></a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'zmysb',
  repo: 'zmysb.github.io',
  oauth: {
    client_id: '0c1d3880d2ff18d6d737',
    client_secret: '93e80999306a8023541f9317b8e2db01e454583c',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/前端/读书笔记/">读书笔记</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/影评/" style="font-size: 15px;">影评</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/Javascript/" style="font-size: 15px;">Javascript</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/03/09/刷题啦/">刷题啦</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/03/【你不知道的JavaScript中】/">【你不知道的JavaScript中】</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/【你不知道的JavaScript上】/">【你不知道的JavaScript上】</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/深入浅出React和Redux/">深入浅出React和Redux</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/【JavaScript权威指南】新兴的API/">【JavaScript权威指南】新兴的API</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/【JavaScript权威指南】最佳实践/">【JavaScript权威指南】最佳实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/【JavaScript权威指南】离线应用与客户端存储/">【JavaScript权威指南】离线应用与客户端存储</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/【JavaScript权威指南】高级技巧/">【JavaScript权威指南】高级技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/【JavaScript权威指南】Ajax与Comet/">【JavaScript权威指南】Ajax与Comet</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/【JavaScript权威指南】JSON/">【JavaScript权威指南】JSON</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://weibo.com/u/3837485237?refer_flag=1001030101_&amp;is_all=1" title="广告位 一" target="_blank">广告位 一</a><ul></ul><a href="https://weibo.com/u/3837485237?refer_flag=1001030101_&amp;is_all=1" title="广告位 二" target="_blank">广告位 二</a><ul></ul><a href="https://weibo.com/u/3837485237?refer_flag=1001030101_&amp;is_all=1" title="广告位 三" target="_blank">广告位 三</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">一零.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>